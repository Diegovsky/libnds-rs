/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _LIBNDS_MAJOR_: u32 = 1;
pub const _LIBNDS_MINOR_: u32 = 8;
pub const _LIBNDS_PATCH_: u32 = 0;
pub const _LIBNDS_STRING: &[u8; 21usize] = b"libNDS Release 1.8.0\0";
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 2;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 2usize] = b"l\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 2usize] = b"l\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 2usize] = b"l\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const COPY_MODE_HWORD: u32 = 0;
pub const COPY_MODE_COPY: u32 = 0;
pub const CARD_CR1_ENABLE: u32 = 128;
pub const CARD_CR1_IRQ: u32 = 64;
pub const SPI_EEPROM_WRSR: u32 = 1;
pub const SPI_EEPROM_PP: u32 = 2;
pub const SPI_EEPROM_READ: u32 = 3;
pub const SPI_EEPROM_WRDI: u32 = 4;
pub const SPI_EEPROM_RDSR: u32 = 5;
pub const SPI_EEPROM_WREN: u32 = 6;
pub const SPI_EEPROM_PW: u32 = 10;
pub const SPI_EEPROM_FAST: u32 = 11;
pub const SPI_EEPROM_RDID: u32 = 159;
pub const SPI_EEPROM_RDP: u32 = 171;
pub const SPI_EEPROM_DPD: u32 = 185;
pub const CARD_ACTIVATE: u32 = 2147483648;
pub const CARD_WR: u32 = 1073741824;
pub const CARD_nRESET: u32 = 536870912;
pub const CARD_SEC_LARGE: u32 = 268435456;
pub const CARD_CLK_SLOW: u32 = 134217728;
pub const CARD_SEC_CMD: u32 = 4194304;
pub const CARD_SEC_SEED: u32 = 32768;
pub const CARD_SEC_EN: u32 = 16384;
pub const CARD_SEC_DAT: u32 = 8192;
pub const CARD_BUSY: u32 = 2147483648;
pub const CARD_DATA_READY: u32 = 8388608;
pub const CARD_CMD_DUMMY: u32 = 159;
pub const CARD_CMD_HEADER_READ: u32 = 0;
pub const CARD_CMD_HEADER_CHIPID: u32 = 144;
pub const CARD_CMD_ACTIVATE_BF: u32 = 60;
pub const CARD_CMD_ACTIVATE_SEC: u32 = 64;
pub const CARD_CMD_SECURE_CHIPID: u32 = 16;
pub const CARD_CMD_SECURE_READ: u32 = 32;
pub const CARD_CMD_DISABLE_SEC: u32 = 96;
pub const CARD_CMD_DATA_MODE: u32 = 160;
pub const CARD_CMD_DATA_READ: u32 = 183;
pub const CARD_CMD_DATA_CHIPID: u32 = 184;
pub const CARD_ENABLE: u32 = 32768;
pub const CARD_SPI_ENABLE: u32 = 8192;
pub const CARD_SPI_BUSY: u32 = 128;
pub const CARD_SPI_HOLD: u32 = 64;
pub const CARD_SPICNTH_ENABLE: u32 = 128;
pub const CARD_SPICNTH_IRQ: u32 = 64;
pub const DMA_START_NOW: u32 = 0;
pub const DMA_START_CARD: u32 = 671088640;
pub const DMA_START_FIFO: u32 = 939524096;
pub const DMA_DISP_FIFO: u32 = 536870912;
pub const DMA_16_BIT: u32 = 0;
pub const DMA_SRC_INC: u32 = 0;
pub const DMA_DST_INC: u32 = 0;
pub const DMA_DST_RESET: u32 = 6291456;
pub const MAX_INTERRUPTS: u32 = 25;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const BUS_OWNER_ARM9: u32 = 1;
pub const BUS_OWNER_ARM7: u32 = 0;
pub const ARGV_MAGIC: u32 = 1600221799;
pub const BOOTSIG: u64 = 7094704827215605602;
pub const BUS_CLOCK: u32 = 33513982;
pub const TIMER_ENABLE: u32 = 128;
pub const TIMER_IRQ_REQ: u32 = 64;
pub const TIMER_CASCADE: u32 = 4;
pub const TIMER_DIV_1: u32 = 0;
pub const TIMER_DIV_64: u32 = 1;
pub const TIMER_DIV_256: u32 = 2;
pub const TIMER_DIV_1024: u32 = 3;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const M_MXFAST: u32 = 1;
pub const M_NLBLKS: u32 = 2;
pub const M_GRAIN: u32 = 3;
pub const M_KEEP: u32 = 4;
pub const M_TRIM_THRESHOLD: i32 = -1;
pub const M_TOP_PAD: i32 = -2;
pub const M_MMAP_THRESHOLD: i32 = -3;
pub const M_MMAP_MAX: i32 = -4;
pub const SCREEN_HEIGHT: u32 = 192;
pub const SCREEN_WIDTH: u32 = 256;
pub const VRAM_ENABLE: u32 = 128;
pub const ENABLE_3D: u32 = 8;
pub const DISPLAY_ENABLE_SHIFT: u32 = 8;
pub const DISPLAY_BG0_ACTIVE: u32 = 256;
pub const DISPLAY_BG1_ACTIVE: u32 = 512;
pub const DISPLAY_BG2_ACTIVE: u32 = 1024;
pub const DISPLAY_BG3_ACTIVE: u32 = 2048;
pub const DISPLAY_SPR_ACTIVE: u32 = 4096;
pub const DISPLAY_WIN0_ON: u32 = 8192;
pub const DISPLAY_WIN1_ON: u32 = 16384;
pub const DISPLAY_SPR_WIN_ON: u32 = 32768;
pub const DISPLAY_SPR_HBLANK: u32 = 8388608;
pub const DISPLAY_SPR_1D_LAYOUT: u32 = 16;
pub const DISPLAY_SPR_1D: u32 = 16;
pub const DISPLAY_SPR_2D: u32 = 0;
pub const DISPLAY_SPR_1D_BMP: u32 = 64;
pub const DISPLAY_SPR_2D_BMP_128: u32 = 0;
pub const DISPLAY_SPR_2D_BMP_256: u32 = 32;
pub const DISPLAY_SPR_1D_SIZE_32: u32 = 0;
pub const DISPLAY_SPR_1D_SIZE_64: u32 = 1048576;
pub const DISPLAY_SPR_1D_SIZE_128: u32 = 2097152;
pub const DISPLAY_SPR_1D_SIZE_256: u32 = 3145728;
pub const DISPLAY_SPR_1D_BMP_SIZE_128: u32 = 0;
pub const DISPLAY_SPR_1D_BMP_SIZE_256: u32 = 4194304;
pub const DISPLAY_SPRITE_ATTR_MASK: u32 = 2154823792;
pub const DISPLAY_SPR_EXT_PALETTE: u32 = 2147483648;
pub const DISPLAY_BG_EXT_PALETTE: u32 = 1073741824;
pub const DISPLAY_SCREEN_OFF: u32 = 128;
pub const BLEND_NONE: u32 = 0;
pub const BLEND_ALPHA: u32 = 64;
pub const BLEND_FADE_WHITE: u32 = 128;
pub const BLEND_FADE_BLACK: u32 = 192;
pub const BLEND_SRC_BG0: u32 = 1;
pub const BLEND_SRC_BG1: u32 = 2;
pub const BLEND_SRC_BG2: u32 = 4;
pub const BLEND_SRC_BG3: u32 = 8;
pub const BLEND_SRC_SPRITE: u32 = 16;
pub const BLEND_SRC_BACKDROP: u32 = 32;
pub const BLEND_DST_BG0: u32 = 256;
pub const BLEND_DST_BG1: u32 = 512;
pub const BLEND_DST_BG2: u32 = 1024;
pub const BLEND_DST_BG3: u32 = 2048;
pub const BLEND_DST_SPRITE: u32 = 4096;
pub const BLEND_DST_BACKDROP: u32 = 8192;
pub const DCAP_MODE_A: u32 = 0;
pub const DCAP_MODE_B: u32 = 1;
pub const DCAP_MODE_BLEND: u32 = 2;
pub const DCAP_SRC_A_COMPOSITED: u32 = 0;
pub const DCAP_SRC_A_3DONLY: u32 = 1;
pub const DCAP_SRC_B_VRAM: u32 = 0;
pub const DCAP_SRC_B_DISPFIFO: u32 = 1;
pub const DCAP_SIZE_128x128: u32 = 0;
pub const DCAP_SIZE_256x64: u32 = 1;
pub const DCAP_SIZE_256x128: u32 = 2;
pub const DCAP_SIZE_256x192: u32 = 3;
pub const DCAP_BANK_VRAM_A: u32 = 0;
pub const DCAP_BANK_VRAM_B: u32 = 1;
pub const DCAP_BANK_VRAM_C: u32 = 2;
pub const DCAP_BANK_VRAM_D: u32 = 3;
pub const MAP_BASE_SHIFT: u32 = 8;
pub const TILE_BASE_SHIFT: u32 = 2;
pub const DEGREES_IN_CIRCLE: u32 = 32768;
pub const DIV_64_64: u32 = 2;
pub const DIV_64_32: u32 = 1;
pub const DIV_32_32: u32 = 0;
pub const DIV_BUSY: u32 = 32768;
pub const SQRT_64: u32 = 1;
pub const SQRT_32: u32 = 0;
pub const SQRT_BUSY: u32 = 32768;
pub const LUT_SIZE: u32 = 32768;
pub const LUT_MASK: u32 = 32767;
pub const MAX_TEXTURES: u32 = 2048;
pub const GL_MAX_DEPTH: u32 = 32767;
pub const GL_FALSE: u32 = 0;
pub const GL_TRUE: u32 = 1;
pub const ATTR0_NORMAL: u32 = 0;
pub const ATTR0_ROTSCALE: u32 = 256;
pub const ATTR0_DISABLED: u32 = 512;
pub const ATTR0_ROTSCALE_DOUBLE: u32 = 768;
pub const ATTR0_TYPE_NORMAL: u32 = 0;
pub const ATTR0_TYPE_BLENDED: u32 = 1024;
pub const ATTR0_TYPE_WINDOWED: u32 = 2048;
pub const ATTR0_BMP: u32 = 3072;
pub const ATTR0_MOSAIC: u32 = 4096;
pub const ATTR0_COLOR_16: u32 = 0;
pub const ATTR0_COLOR_256: u32 = 8192;
pub const ATTR0_SQUARE: u32 = 0;
pub const ATTR0_WIDE: u32 = 16384;
pub const ATTR0_TALL: u32 = 32768;
pub const ATTR1_FLIP_X: u32 = 4096;
pub const ATTR1_FLIP_Y: u32 = 8192;
pub const ATTR1_SIZE_8: u32 = 0;
pub const ATTR1_SIZE_16: u32 = 16384;
pub const ATTR1_SIZE_32: u32 = 32768;
pub const ATTR1_SIZE_64: u32 = 49152;
pub const SPRITE_COUNT: u32 = 128;
pub const MATRIX_COUNT: u32 = 32;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const F_OK: u32 = 0;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_JOB_CONTROL: u32 = 5;
pub const _SC_SAVED_IDS: u32 = 6;
pub const _SC_VERSION: u32 = 7;
pub const _SC_PAGESIZE: u32 = 8;
pub const _SC_PAGE_SIZE: u32 = 8;
pub const _SC_NPROCESSORS_CONF: u32 = 9;
pub const _SC_NPROCESSORS_ONLN: u32 = 10;
pub const _SC_PHYS_PAGES: u32 = 11;
pub const _SC_AVPHYS_PAGES: u32 = 12;
pub const _SC_MQ_OPEN_MAX: u32 = 13;
pub const _SC_MQ_PRIO_MAX: u32 = 14;
pub const _SC_RTSIG_MAX: u32 = 15;
pub const _SC_SEM_NSEMS_MAX: u32 = 16;
pub const _SC_SEM_VALUE_MAX: u32 = 17;
pub const _SC_SIGQUEUE_MAX: u32 = 18;
pub const _SC_TIMER_MAX: u32 = 19;
pub const _SC_TZNAME_MAX: u32 = 20;
pub const _SC_ASYNCHRONOUS_IO: u32 = 21;
pub const _SC_FSYNC: u32 = 22;
pub const _SC_MAPPED_FILES: u32 = 23;
pub const _SC_MEMLOCK: u32 = 24;
pub const _SC_MEMLOCK_RANGE: u32 = 25;
pub const _SC_MEMORY_PROTECTION: u32 = 26;
pub const _SC_MESSAGE_PASSING: u32 = 27;
pub const _SC_PRIORITIZED_IO: u32 = 28;
pub const _SC_REALTIME_SIGNALS: u32 = 29;
pub const _SC_SEMAPHORES: u32 = 30;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 31;
pub const _SC_SYNCHRONIZED_IO: u32 = 32;
pub const _SC_TIMERS: u32 = 33;
pub const _SC_AIO_LISTIO_MAX: u32 = 34;
pub const _SC_AIO_MAX: u32 = 35;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 36;
pub const _SC_DELAYTIMER_MAX: u32 = 37;
pub const _SC_THREAD_KEYS_MAX: u32 = 38;
pub const _SC_THREAD_STACK_MIN: u32 = 39;
pub const _SC_THREAD_THREADS_MAX: u32 = 40;
pub const _SC_TTY_NAME_MAX: u32 = 41;
pub const _SC_THREADS: u32 = 42;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 43;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 44;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 45;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 46;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 47;
pub const _SC_THREAD_PRIO_CEILING: u32 = 47;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 48;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 49;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 50;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 51;
pub const _SC_LOGIN_NAME_MAX: u32 = 52;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 53;
pub const _SC_ADVISORY_INFO: u32 = 54;
pub const _SC_ATEXIT_MAX: u32 = 55;
pub const _SC_BARRIERS: u32 = 56;
pub const _SC_BC_BASE_MAX: u32 = 57;
pub const _SC_BC_DIM_MAX: u32 = 58;
pub const _SC_BC_SCALE_MAX: u32 = 59;
pub const _SC_BC_STRING_MAX: u32 = 60;
pub const _SC_CLOCK_SELECTION: u32 = 61;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 62;
pub const _SC_CPUTIME: u32 = 63;
pub const _SC_EXPR_NEST_MAX: u32 = 64;
pub const _SC_HOST_NAME_MAX: u32 = 65;
pub const _SC_IOV_MAX: u32 = 66;
pub const _SC_IPV6: u32 = 67;
pub const _SC_LINE_MAX: u32 = 68;
pub const _SC_MONOTONIC_CLOCK: u32 = 69;
pub const _SC_RAW_SOCKETS: u32 = 70;
pub const _SC_READER_WRITER_LOCKS: u32 = 71;
pub const _SC_REGEXP: u32 = 72;
pub const _SC_RE_DUP_MAX: u32 = 73;
pub const _SC_SHELL: u32 = 74;
pub const _SC_SPAWN: u32 = 75;
pub const _SC_SPIN_LOCKS: u32 = 76;
pub const _SC_SPORADIC_SERVER: u32 = 77;
pub const _SC_SS_REPL_MAX: u32 = 78;
pub const _SC_SYMLOOP_MAX: u32 = 79;
pub const _SC_THREAD_CPUTIME: u32 = 80;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 81;
pub const _SC_TIMEOUTS: u32 = 82;
pub const _SC_TRACE: u32 = 83;
pub const _SC_TRACE_EVENT_FILTER: u32 = 84;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 85;
pub const _SC_TRACE_INHERIT: u32 = 86;
pub const _SC_TRACE_LOG: u32 = 87;
pub const _SC_TRACE_NAME_MAX: u32 = 88;
pub const _SC_TRACE_SYS_MAX: u32 = 89;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 90;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 91;
pub const _SC_V7_ILP32_OFF32: u32 = 92;
pub const _SC_V6_ILP32_OFF32: u32 = 92;
pub const _SC_XBS5_ILP32_OFF32: u32 = 92;
pub const _SC_V7_ILP32_OFFBIG: u32 = 93;
pub const _SC_V6_ILP32_OFFBIG: u32 = 93;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 93;
pub const _SC_V7_LP64_OFF64: u32 = 94;
pub const _SC_V6_LP64_OFF64: u32 = 94;
pub const _SC_XBS5_LP64_OFF64: u32 = 94;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 95;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XOPEN_CRYPT: u32 = 96;
pub const _SC_XOPEN_ENH_I18N: u32 = 97;
pub const _SC_XOPEN_LEGACY: u32 = 98;
pub const _SC_XOPEN_REALTIME: u32 = 99;
pub const _SC_STREAM_MAX: u32 = 100;
pub const _SC_PRIORITY_SCHEDULING: u32 = 101;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 102;
pub const _SC_XOPEN_SHM: u32 = 103;
pub const _SC_XOPEN_STREAMS: u32 = 104;
pub const _SC_XOPEN_UNIX: u32 = 105;
pub const _SC_XOPEN_VERSION: u32 = 106;
pub const _SC_2_CHAR_TERM: u32 = 107;
pub const _SC_2_C_BIND: u32 = 108;
pub const _SC_2_C_DEV: u32 = 109;
pub const _SC_2_FORT_DEV: u32 = 110;
pub const _SC_2_FORT_RUN: u32 = 111;
pub const _SC_2_LOCALEDEF: u32 = 112;
pub const _SC_2_PBS: u32 = 113;
pub const _SC_2_PBS_ACCOUNTING: u32 = 114;
pub const _SC_2_PBS_CHECKPOINT: u32 = 115;
pub const _SC_2_PBS_LOCATE: u32 = 116;
pub const _SC_2_PBS_MESSAGE: u32 = 117;
pub const _SC_2_PBS_TRACK: u32 = 118;
pub const _SC_2_SW_DEV: u32 = 119;
pub const _SC_2_UPE: u32 = 120;
pub const _SC_2_VERSION: u32 = 121;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 122;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 123;
pub const _SC_XOPEN_UUCP: u32 = 124;
pub const _SC_LEVEL1_ICACHE_SIZE: u32 = 125;
pub const _SC_LEVEL1_ICACHE_ASSOC: u32 = 126;
pub const _SC_LEVEL1_ICACHE_LINESIZE: u32 = 127;
pub const _SC_LEVEL1_DCACHE_SIZE: u32 = 128;
pub const _SC_LEVEL1_DCACHE_ASSOC: u32 = 129;
pub const _SC_LEVEL1_DCACHE_LINESIZE: u32 = 130;
pub const _SC_LEVEL2_CACHE_SIZE: u32 = 131;
pub const _SC_LEVEL2_CACHE_ASSOC: u32 = 132;
pub const _SC_LEVEL2_CACHE_LINESIZE: u32 = 133;
pub const _SC_LEVEL3_CACHE_SIZE: u32 = 134;
pub const _SC_LEVEL3_CACHE_ASSOC: u32 = 135;
pub const _SC_LEVEL3_CACHE_LINESIZE: u32 = 136;
pub const _SC_LEVEL4_CACHE_SIZE: u32 = 137;
pub const _SC_LEVEL4_CACHE_ASSOC: u32 = 138;
pub const _SC_LEVEL4_CACHE_LINESIZE: u32 = 139;
pub const _SC_POSIX_26_VERSION: u32 = 140;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_ASYNC_IO: u32 = 9;
pub const _PC_PRIO_IO: u32 = 10;
pub const _PC_SYNC_IO: u32 = 11;
pub const _PC_FILESIZEBITS: u32 = 12;
pub const _PC_2_SYMLINKS: u32 = 13;
pub const _PC_SYMLINK_MAX: u32 = 14;
pub const _PC_ALLOC_SIZE_MIN: u32 = 15;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 16;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 17;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 18;
pub const _PC_REC_XFER_ALIGN: u32 = 19;
pub const _PC_TIMESTAMP_RESOLUTION: u32 = 20;
pub const DSWIFI_MAJOR: u32 = 0;
pub const DSWIFI_MINOR: u32 = 4;
pub const DSWIFI_REVISION: u32 = 2;
pub const DSWIFI_VERSION: &[u8; 6usize] = b"0.4.2\0";
pub const WIFIINIT_OPTION_USELED: u32 = 2;
pub const WIFIINIT_OPTION_USEHEAP_64: u32 = 0;
pub const WIFIINIT_OPTION_USEHEAP_128: u32 = 4096;
pub const WIFIINIT_OPTION_USEHEAP_256: u32 = 8192;
pub const WIFIINIT_OPTION_USEHEAP_512: u32 = 12288;
pub const WIFIINIT_OPTION_USECUSTOMALLOC: u32 = 16384;
pub const WIFIINIT_OPTION_HEAPMASK: u32 = 61440;
pub const WFLAG_PACKET_DATA: u32 = 1;
pub const WFLAG_PACKET_MGT: u32 = 2;
pub const WFLAG_PACKET_BEACON: u32 = 4;
pub const WFLAG_PACKET_CTRL: u32 = 8;
pub const WFLAG_PACKET_ALL: u32 = 65535;
pub const WFLAG_APDATA_ADHOC: u32 = 1;
pub const WFLAG_APDATA_WEP: u32 = 2;
pub const WFLAG_APDATA_WPA: u32 = 4;
pub const WFLAG_APDATA_COMPATIBLE: u32 = 8;
pub const WFLAG_APDATA_EXTCOMPATIBLE: u32 = 16;
pub const WFLAG_APDATA_SHORTPREAMBLE: u32 = 32;
pub const WFLAG_APDATA_ACTIVE: u32 = 32768;
pub const WFC_CONNECT: u32 = 1;
pub const INIT_ONLY: u32 = 0;
pub const MMCB_SONGREQUEST: u32 = 26;
pub const MMCB_SAMPREQUEST: u32 = 27;
pub const MMCB_DELETESONG: u32 = 28;
pub const MMCB_DELETESAMPLE: u32 = 29;
pub const MMCB_SONGMESSAGE: u32 = 42;
pub const MMCB_SONGFINISHED: u32 = 43;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_long;
pub type __uint_least64_t = ::libc::c_ulong;
pub type __intmax_t = ::libc::c_long;
pub type __uintmax_t = ::libc::c_ulong;
pub type __intptr_t = ::libc::c_long;
pub type __uintptr_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast64_t = ::libc::c_ulong;
#[doc = "! 8 bit unsigned integer."]
pub type uint8 = u8;
#[doc = "! 16 bit unsigned integer."]
pub type uint16 = u16;
#[doc = "! 32 bit unsigned integer."]
pub type uint32 = u32;
#[doc = "! 64 bit unsigned integer."]
pub type uint64 = u64;
#[doc = "! 8 bit signed integer."]
pub type int8 = i8;
#[doc = "! 16 bit signed integer."]
pub type int16 = i16;
#[doc = "! 32 bit signed integer."]
pub type int32 = i32;
#[doc = "! 64 bit signed integer."]
pub type int64 = i64;
#[doc = "! 32 bit signed floating point number."]
pub type float32 = f32;
#[doc = "! 64 bit signed floating point number."]
pub type float64 = f64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vuint8 = u8;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vuint16 = u16;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vuint32 = u32;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vuint64 = u64;
#[doc = "! 8 bit volatile signed integer."]
pub type vint8 = i8;
#[doc = "! 16 bit volatile signed integer."]
pub type vint16 = i16;
#[doc = "! 32 bit volatile signed integer."]
pub type vint32 = i32;
#[doc = "! 64 bit volatile signed integer."]
pub type vint64 = i64;
#[doc = "! 32 bit volatile signed floating point number."]
pub type vfloat32 = float32;
#[doc = "! 64 bit volatile signed floating point number."]
pub type vfloat64 = float64;
#[doc = "! 8 bit unsigned integer."]
pub type byte = u8;
#[doc = "! 8 bit unsigned integer."]
pub type u8_ = u8;
#[doc = "! 16 bit unsigned integer."]
pub type u16_ = u16;
#[doc = "! 32 bit unsigned integer."]
pub type u32_ = u32;
#[doc = "! 64 bit unsigned integer."]
pub type u64_ = u64;
#[doc = "! 8 bit signed integer."]
pub type s8 = i8;
#[doc = "! 16 bit signed integer."]
pub type s16 = i16;
#[doc = "! 32 bit signed integer."]
pub type s32 = i32;
#[doc = "! 64 bit signed integer."]
pub type s64 = i64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vu8 = u8_;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vu16 = u16_;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vu32 = u32_;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vu64 = u64_;
#[doc = "! 8 bit volatile signed integer."]
pub type vs8 = s8;
#[doc = "! 16 bit volatile signed integer."]
pub type vs16 = s16;
#[doc = "! 32 bit volatile signed integer."]
pub type vs32 = s32;
#[doc = "! 64 bit volatile signed integer."]
pub type vs64 = s64;
pub type sec_t = u32;
#[doc = "! a function pointer that takes no arguments and doesn't return anything."]
pub type VoidFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type IntFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type fp = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "\t\\brief Should return the header of a compressed stream of bytes.\n\nThe result is a word, with the size of decompressed data in bits 8-31,\nand bits 0-7 are ignored.  This value is also returned by the bios function, unless getResult is non-NULL and returns a negative value.\nThis useally returns the 4 bytes that source points to.\n\n\\param source \tA pointer to the compressed data.\n\\param dest\t\tA pointer to the space where the decompressed data should be copied to.\n\\param arg\t\tA callback value that gets passed to the bios function.\n\\return The header of the compressed data containing the length of the data and the compression type."]
pub type getHeaderCallback = ::core::option::Option<
    unsafe extern "C" fn(source: *mut u8_, dest: *mut u16_, arg: u32_) -> ::libc::c_int,
>;
#[doc = "\t\\brief Should verify the result after data got decompressed.\n\ngetResult is used to provide a result for the bios function, given the source pointer after all data has been read\n(or if getSize < 0). Its value is only returned if negative, otherwise the typical result is used, so it is likely\nsome sort of error-checking procedure.\n\n\\param source The current source address.\n\\return 0 if it went right, or a negative number if something went wrong. value will be returned from bios function if value is negative."]
pub type getResultCallback =
    ::core::option::Option<unsafe extern "C" fn(source: *mut u8_) -> ::libc::c_int>;
#[doc = "\t\\brief Should returns a raw byte of the stream.\n\\param source A pointer to the byte.\n\\return A byte."]
pub type getByteCallback = ::core::option::Option<unsafe extern "C" fn(source: *mut u8_) -> u8_>;
#[doc = "! A struct that contains callback function pointers used by the decompression functions."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DecompressionStream {
    #[doc = "!< gets called to get the header of the stream."]
    pub getSize: getHeaderCallback,
    #[doc = "!< gets called to verify the result afterwards, can be NULL (no callback)."]
    pub getResult: getResultCallback,
    #[doc = "!< gets called to get a byte of the compressed data."]
    pub readByte: getByteCallback,
}
#[doc = "! A struct that contains callback function pointers used by the decompression functions."]
pub type TDecompressionStream = DecompressionStream;
#[doc = "! A struct and struct pointer with information about unpacking data."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UnpackStruct {
    #[doc = "!< in bytes"]
    pub sourceSize: uint16,
    #[doc = "!< 1,2,4 or 8 bits."]
    pub sourceWidth: uint8,
    #[doc = "!< 1,2,4,8,16 or 32 bits."]
    pub destWidth: uint8,
    #[doc = "!< bits 0-30 are added to all non-zero destination writes, unless bit 31 is set, which does it for zeros too."]
    pub dataOffset: uint32,
}
#[doc = "! A struct and struct pointer with information about unpacking data."]
pub type TUnpackStruct = UnpackStruct;
#[doc = "! A struct and struct pointer with information about unpacking data."]
pub type PUnpackStruct = *mut UnpackStruct;
extern "C" {
    #[doc = "\\brief resets the DS."]
    pub fn swiSoftReset();
}
extern "C" {
    #[doc = "\\brief delays the code.\n\nDelays for for a period X + Y*duration where X is the swi overhead and Y is a cycle of\n<CODE><PRE>\nloop:\nsub r0, #1\nbgt loop\n</PRE></CODE>\nof thumb fetches in BIOS memory\n\\param duration length of delay\n\\note Duration should be 1 or more, a duration of 0 is a huge delay."]
    pub fn swiDelay(duration: uint32);
}
extern "C" {
    #[doc = "\\brief divides 2 numbers.\n\\param numerator\tsigned integer to divide\n\\param divisor\t\tsigned integer to divide by\n\\return numerator / divisor"]
    pub fn swiDivide(numerator: ::libc::c_int, divisor: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief calculate the remainder of an division.\n\\param numerator\tsigned integer to divide\n\\param divisor\t\tsigned integer to divide by\n\\return numerator % divisor"]
    pub fn swiRemainder(numerator: ::libc::c_int, divisor: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief divides 2 numbers and stores both the result and the remainder.\n\n\\param numerator\tsigned integer to divide\n\\param divisor\t\tsigned integer to divide by\n\\param result\t\tpointer to integer set to numerator / divisor\n\\param remainder \tpointer to integer set to numerator % divisor"]
    pub fn swiDivMod(
        numerator: ::libc::c_int,
        divisor: ::libc::c_int,
        result: *mut ::libc::c_int,
        remainder: *mut ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory.\n\\param source \tpointer to transfer source or pointer to value to fill the memory with.\n\\param dest\t\tpointer to transfer destination.\n\\param flags\tbits(0-20): size of data to copy/fill in words,\nor'd with the copy mode size (word or halfword) and type (copy or fill)."]
    pub fn swiCopy(source: *const ::libc::c_void, dest: *mut ::libc::c_void, flags: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory.\ncan only copy in word chunks.\n\\param source\tpointer to transfer source or pointer to value to fill the memory with.\n\\param dest\t\tpointer to transfer destination.\n\\param flags\tbits(0-20): size of data to copy/fill in words,\nor'd with the type (copy or fill).\n\n\\note Transfers more quickly than swiCopy, but has higher interrupt latency."]
    pub fn swiFastCopy(
        source: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        flags: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief calculates the square root.\n\\param value the value to calculate.\n\\return the square root of the value as an integer.\n\\note use fixed point math if you want more accuracy."]
    pub fn swiSqrt(value: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief calculates a CRC-16 checksum.\n\\param crc \t\tstarting CRC-16 value.\n\\param data \tpointer to data (processed nibble by nibble)\n\\param size \tsize in bytes.\n\n\\return the CRC-16 after the data has been processed."]
    pub fn swiCRC16(crc: uint16, data: *mut ::libc::c_void, size: uint32) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief returns 0 if running on a nintendo hardware debugger.\n\\return 0 if running on a debugger (8 MB of ram instead of 4 MB), else some other number."]
    pub fn swiIsDebugger() -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Unpack data stored in multiple elements in a byte to a larger space.\n\ni.e. 8 elements per byte (i.e. b/w font), into 1 element per byte.\n\n\\param source\t\t\tSource address.\n\\param destination\t\tdestination address (word aligned).\n\\param params\t\t\tpointer to an UnpackStruct."]
    pub fn swiUnpackBits(source: *mut uint8, destination: *mut uint32, params: PUnpackStruct);
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data.\n\\param source\t\tpointer to a header word, followed by compressed data.\nbit 0-7 of header is ignored.\nbit 8-31 of header is size of uncompressed data in bytes.\n\\param destination\tdestination address.\n\\note Writes data a byte at a time.\n\\see decompress.h"]
    pub fn swiDecompressLZSSWram(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data vram safe.\n\n\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset).\n\\param destination\t\tPointer to destination.\n\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer.\n\\param stream\t\t\tPointer to struct with callback function pointers.\n\n\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions.\n\\note Writes data a halfword at a time.\n\\see decompress.h"]
    pub fn swiDecompressLZSSVram(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramNTR(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramTWL(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses Huffman compressed data.\n\n\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset).\n\\param destination\t\tPointer to destination.\n\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer.\n\\param stream\t\t\tPointer to struct with callback function pointers.\n\n\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions.\n\\see decompress.h"]
    pub fn swiDecompressHuffman(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data.\n\ncompressed data format:\nbit(7): 0= uncompressed, 1= compressed.\nbit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data.\nbit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated.\n\n\\param source\t\tpointer to a header word, followed by compressed data.\nbit 0-7 of header is ignored.\nbit 8-31 of header is size of uncompressed data in bytes.\n\\param destination\tdestination address.\n\\note Writes data a byte at a time.\n\\see decompress.h"]
    pub fn swiDecompressRLEWram(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data vram safe.\n\ncompressed data format:\nbit(7): 0= uncompressed, 1= compressed.\nbit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data.\nbit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated.\n\n\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset).\n\\param destination\t\tPointer to destination.\n\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer.\n\\param stream\t\t\tPointer to struct with callback function pointers.\n\n\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions.\n\\note Writes data a halfword at a time.\n\\see decompress.h"]
    pub fn swiDecompressRLEVram(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief wait for any interrupt.\n\n\\note ARM9 exclusive."]
    pub fn swiWaitForIRQ();
}
extern "C" {
    #[doc = "\t\\brief Writes a word of the data to 0x04000300:32\n\n\\param data the word to write.\n\\note This is on the ARM9, but works differently then the ARM7 function!"]
    pub fn swiSetHaltCR(data: uint32);
}
extern "C" {
    #[doc = "\t\\brief Decodes a stream of bytes based on the difference of the bytes.\n\\param source \t\tPointer to a header word, followed by encoded data.\nword(31..8) = size of data (in bytes).\nword(7..0) = ignored.\n\\param destination\tDestination address.\n\n\\note Writes data a byte at a time.\n\\note ARM9 exclusive."]
    pub fn swiDecodeDelta8(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decodes a stream of bytes based on the difference of the bytes.\n\\param source\t\tPointer to a header word, followed by encoded data.\nword(31..8) = size of data (in bytes).\nword(7..0) = ignored.\n\\param destination\tDestination address.\n\n\\note Writes data a halfword at a time.\n\\note ARM9 exclusive."]
    pub fn swiDecodeDelta16(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    pub fn enableSlot1();
}
extern "C" {
    pub fn disableSlot1();
}
extern "C" {
    pub fn cardWriteCommand(command: *const u8_);
}
extern "C" {
    pub fn cardPolledTransfer(
        flags: u32_,
        destination: *mut u32_,
        length: u32_,
        command: *const u8_,
    );
}
extern "C" {
    pub fn cardStartTransfer(
        command: *const u8_,
        destination: *mut u32_,
        channel: ::libc::c_int,
        flags: u32_,
    );
}
extern "C" {
    pub fn cardWriteAndRead(command: *const u8_, flags: u32_) -> uint32;
}
extern "C" {
    pub fn cardParamCommand(
        command: u8_,
        parameter: u32_,
        flags: u32_,
        destination: *mut u32_,
        length: u32_,
    );
}
extern "C" {
    pub fn cardReadHeader(header: *mut u8_);
}
extern "C" {
    pub fn cardReadID(flags: u32_) -> u32_;
}
extern "C" {
    pub fn cardReset();
}
extern "C" {
    #[link_name = "\u{1}eepromWaitBusy__extern"]
    pub fn eepromWaitBusy();
}
extern "C" {
    pub fn cardReadEeprom(address: u32_, data: *mut u8_, length: u32_, addrtype: u32_);
}
extern "C" {
    pub fn cardWriteEeprom(address: u32_, data: *mut u8_, length: u32_, addrtype: u32_);
}
extern "C" {
    pub fn cardEepromReadID() -> u32_;
}
extern "C" {
    pub fn cardEepromCommand(command: u8_) -> u8_;
}
extern "C" {
    pub fn cardEepromGetType() -> ::libc::c_int;
}
extern "C" {
    pub fn cardEepromGetSize() -> u32_;
}
extern "C" {
    pub fn cardEepromChipErase();
}
extern "C" {
    pub fn cardEepromSectorErase(address: u32_);
}
extern "C" {
    pub fn nocashWrite(message: *const ::libc::c_char, len: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief Send a message to the no$gba debug window\n\\param message The message to send"]
    pub fn nocashMessage(message: *const ::libc::c_char);
}
extern "C" {
    #[doc = " \\fn void dmaCopyWords(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in words\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest word (4 bytes)"]
    #[link_name = "\u{1}dmaCopyWords__extern"]
    pub fn dmaCopyWords(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopyHalfWords(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in half words\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopyHalfWords__extern"]
    pub fn dmaCopyHalfWords(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopy(const void * source, void * dest, uint32 size)\n\\brief copies from source to destination using channel 3 of DMA available channels in half words\n\\param source the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopy__extern"]
    pub fn dmaCopy(source: *const ::libc::c_void, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn void dmaCopyWordsAsynch(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in half words.\nThis function returns immediately after starting the transfer.\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest word (4 bytes)"]
    #[link_name = "\u{1}dmaCopyWordsAsynch__extern"]
    pub fn dmaCopyWordsAsynch(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopyHalfWordsAsynch(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in half words.\nThis function returns immediately after starting the transfer.\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopyHalfWordsAsynch__extern"]
    pub fn dmaCopyHalfWordsAsynch(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopyAsynch(const void* src, void* dest, uint32 size)\n\\brief copies from source to destination using channel 3 of DMA available channels in half words.\nThis function returns immediately after starting the transfer.\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopyAsynch__extern"]
    pub fn dmaCopyAsynch(source: *const ::libc::c_void, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn void dmaFillWords( u32 value, void* dest, uint32 size)\n\\brief fills the source with the supplied value using DMA channel 3\n\n\\param value the 32 byte value to fill memory with\n\\param dest the destination to copy to\n\\param size the size in bytes of the area to fill.  Will be truncated to the nearest word (4 bytes)"]
    #[link_name = "\u{1}dmaFillWords__extern"]
    pub fn dmaFillWords(value: u32_, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn void dmaFillHalfWords( u16 value, void* dest, uint32 size)\n\\brief fills the source with the supplied value using DMA channel 3\n\n\\param value the 16 byte value to fill memory with\n\\param dest the destination to copy to\n\\param size the size in bytes of the area to fill.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaFillHalfWords__extern"]
    pub fn dmaFillHalfWords(value: u16_, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn dmaBusy(uint8 channel)\n\\brief determines if the specified channel is busy\n\\param channel the dma channel to check (0 - 3).\n\\return non zero if busy, 0 if channel is free"]
    #[link_name = "\u{1}dmaBusy__extern"]
    pub fn dmaBusy(channel: uint8) -> ::libc::c_int;
}
#[doc = "< vertical blank interrupt mask"]
pub const IRQ_VBLANK: IRQ_MASKS = 1;
#[doc = "< horizontal blank interrupt mask"]
pub const IRQ_HBLANK: IRQ_MASKS = 2;
#[doc = "< vcount match interrupt mask"]
pub const IRQ_VCOUNT: IRQ_MASKS = 4;
#[doc = "< timer 0 interrupt mask"]
pub const IRQ_TIMER0: IRQ_MASKS = 8;
#[doc = "< timer 1 interrupt mask"]
pub const IRQ_TIMER1: IRQ_MASKS = 16;
#[doc = "< timer 2 interrupt mask"]
pub const IRQ_TIMER2: IRQ_MASKS = 32;
#[doc = "< timer 3 interrupt mask"]
pub const IRQ_TIMER3: IRQ_MASKS = 64;
#[doc = "< serial interrupt mask"]
pub const IRQ_NETWORK: IRQ_MASKS = 128;
#[doc = "< DMA 0 interrupt mask"]
pub const IRQ_DMA0: IRQ_MASKS = 256;
#[doc = "< DMA 1 interrupt mask"]
pub const IRQ_DMA1: IRQ_MASKS = 512;
#[doc = "< DMA 2 interrupt mask"]
pub const IRQ_DMA2: IRQ_MASKS = 1024;
#[doc = "< DMA 3 interrupt mask"]
pub const IRQ_DMA3: IRQ_MASKS = 2048;
#[doc = "< Keypad interrupt mask"]
pub const IRQ_KEYS: IRQ_MASKS = 4096;
#[doc = "< GBA cartridge interrupt mask"]
pub const IRQ_CART: IRQ_MASKS = 8192;
#[doc = "< IPC sync interrupt mask"]
pub const IRQ_IPC_SYNC: IRQ_MASKS = 65536;
#[doc = "< Send FIFO empty interrupt mask"]
pub const IRQ_FIFO_EMPTY: IRQ_MASKS = 131072;
#[doc = "< Receive FIFO not empty interrupt mask"]
pub const IRQ_FIFO_NOT_EMPTY: IRQ_MASKS = 262144;
#[doc = "< interrupt mask DS Card Slot"]
pub const IRQ_CARD: IRQ_MASKS = 524288;
#[doc = "< interrupt mask"]
pub const IRQ_CARD_LINE: IRQ_MASKS = 1048576;
#[doc = "< geometry FIFO interrupt mask"]
pub const IRQ_GEOMETRY_FIFO: IRQ_MASKS = 2097152;
#[doc = "< interrupt mask DS hinge"]
pub const IRQ_LID: IRQ_MASKS = 4194304;
#[doc = "< SPI interrupt mask"]
pub const IRQ_SPI: IRQ_MASKS = 8388608;
#[doc = "< WIFI interrupt mask (ARM7)"]
pub const IRQ_WIFI: IRQ_MASKS = 16777216;
#[doc = "< 'mask' for all interrupt"]
pub const IRQ_ALL: IRQ_MASKS = -1;
#[doc = "! values allowed for REG_IE and REG_IF"]
pub type IRQ_MASKS = ::libc::c_int;
#[doc = "! values allowed for REG_IE and REG_IF"]
pub use self::IRQ_MASKS as IRQ_MASK;
#[doc = "< I2C interrupt mask (DSi ARM7)"]
pub const IRQ_I2C: IRQ_MASKSAUX = 64;
#[doc = "< Sdmmc interrupt mask (DSi ARM7)"]
pub const IRQ_SDMMC: IRQ_MASKSAUX = 256;
#[doc = "! values allowed for REG_AUXIE and REG_AUXIF"]
pub type IRQ_MASKSAUX = ::libc::c_uint;
#[doc = "< Disable all interrupts."]
pub const IME_DISABLE: IME_VALUE = 0;
#[doc = "< Enable all interrupts not masked out in REG_IE"]
pub const IME_ENABLE: IME_VALUE = 1;
#[doc = "! values allowed for REG_IME"]
pub type IME_VALUE = ::libc::c_uint;
extern "C" {
    pub static mut __irq_vector: [VoidFn; 0usize];
}
extern "C" {
    pub static mut __irq_flags: [vuint32; 0usize];
}
extern "C" {
    pub static mut __irq_flagsaux: [vuint32; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntTable {
    pub handler: IntFn,
    pub mask: u32_,
}
extern "C" {
    #[doc = " \\fn irqInit()\n\\brief Initialise the libnds interrupt system.\n\nThis function is called internally (prior to main()) to set up irqs\non the ARM9.  It must be called on the ARM7 prior to installing irq\nhandlers."]
    pub fn irqInit();
}
extern "C" {
    #[doc = " \\fn irqSet(u32 irq, VoidFn handler)\n\\brief Add a handler for the given interrupt mask.\n\nSpecify the handler to use for the given interrupt. This only works with\nthe default interrupt handler, do not mix the use of this routine with a\nuser-installed IRQ handler.\n\\param irq Mask associated with the interrupt.\n\\param handler Address of the function to use as an interrupt service routine\n\\note\nWhen any handler specifies using IRQ_VBLANK or IRQ_HBLANK, DISP_SR\nis automatically updated to include the corresponding DISP_VBLANK_IRQ or DISP_HBLANK_IRQ.\n\n\\warning Only one IRQ_MASK can be specified with this function."]
    pub fn irqSet(irq: u32_, handler: VoidFn);
}
extern "C" {
    pub fn irqSetAUX(irq: u32_, handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqClear(u32 irq)\n\\brief remove the handler associated with the interrupt mask irq.\n\\param irq Mask associated with the interrupt."]
    pub fn irqClear(irq: u32_);
}
extern "C" {
    pub fn irqClearAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn irqInitHandler(VoidFn handler)\n\\brief Install a user interrupt dispatcher.\n\nThis function installs the main interrupt function, all interrupts are serviced through this routine. For most\npurposes the libnds interrupt dispacther should be used in preference to user code unless you know *exactly* what you're doing.\n\n\\param handler Address of the function to use as an interrupt dispatcher\n\\note the function *must* be ARM code"]
    pub fn irqInitHandler(handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqEnable(u32 irq)\n\\brief Allow the given interrupt to occur.\n\\param irq The set of interrupt masks to enable.\n\\note Specify multiple interrupts to enable by ORing several IRQ_MASKS."]
    pub fn irqEnable(irq: u32_);
}
extern "C" {
    pub fn irqEnableAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn irqDisable(u32 irq)\n\\brief Prevent the given interrupt from occuring.\n\\param irq The set of interrupt masks to disable.\n\\note Specify multiple interrupts to disable by ORing several IRQ_MASKS."]
    pub fn irqDisable(irq: u32_);
}
extern "C" {
    pub fn irqDisableAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn swiIntrWait(u32 waitForSet, uint32 flags)\n\n\\brief wait for interrupt(s) to occur\n\n\\param waitForSet\n0: Return if the interrupt has already occured\n1: Wait until the interrupt has been set since the call\n\\param flags\ninterrupt mask to wait for"]
    pub fn swiIntrWait(waitForSet: u32_, flags: uint32);
}
extern "C" {
    #[doc = " \\fn  swiWaitForVBlank()\n\\brief Wait for vblank interrupt\n\nWaits for a vertical blank interrupt\n\n\\note Identical to calling swiIntrWait(1, 1)"]
    pub fn swiWaitForVBlank();
}
extern "C" {
    #[doc = " \\fn  VoidFn setPowerButtonCB(VoidFn CB);\n\\brief set callback for DSi Powerbutton press\n\n\\param CB\nfunction to call when power button pressed\n\\return\nthe previously set callback"]
    pub fn setPowerButtonCB(CB: VoidFn) -> VoidFn;
}
extern "C" {
    #[link_name = "\u{1}enterCriticalSection__extern"]
    pub fn enterCriticalSection() -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}leaveCriticalSection__extern"]
    pub fn leaveCriticalSection(oldIME: ::libc::c_int);
}
pub const IPC_SYNC_IRQ_ENABLE: IPC_SYNC_BITS = 16384;
pub const IPC_SYNC_IRQ_REQUEST: IPC_SYNC_BITS = 8192;
pub type IPC_SYNC_BITS = ::libc::c_uint;
extern "C" {
    #[link_name = "\u{1}IPC_SendSync__extern"]
    pub fn IPC_SendSync(sync: ::libc::c_uint);
}
extern "C" {
    #[link_name = "\u{1}IPC_GetSync__extern"]
    pub fn IPC_GetSync() -> ::libc::c_int;
}
pub const IPC_FIFO_SEND_EMPTY: IPC_CONTROL_BITS = 1;
pub const IPC_FIFO_SEND_FULL: IPC_CONTROL_BITS = 2;
pub const IPC_FIFO_SEND_IRQ: IPC_CONTROL_BITS = 4;
pub const IPC_FIFO_SEND_CLEAR: IPC_CONTROL_BITS = 8;
pub const IPC_FIFO_RECV_EMPTY: IPC_CONTROL_BITS = 256;
pub const IPC_FIFO_RECV_FULL: IPC_CONTROL_BITS = 512;
pub const IPC_FIFO_RECV_IRQ: IPC_CONTROL_BITS = 1024;
pub const IPC_FIFO_ERROR: IPC_CONTROL_BITS = 16384;
pub const IPC_FIFO_ENABLE: IPC_CONTROL_BITS = 32768;
pub type IPC_CONTROL_BITS = ::libc::c_uint;
extern "C" {
    pub fn __assert(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
        arg4: *const ::libc::c_char,
    ) -> !;
}
#[doc = "\\brief the GBA file header format.\nSee gbatek for more info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sGBAHeader {
    #[doc = "!< 32 bits arm opcode to jump to executable code."]
    pub entryPoint: u32_,
    #[doc = "!< nintendo logo needed for booting the game."]
    pub logo: [u8_; 156usize],
    #[doc = "!< 12 characters for the game title."]
    pub title: [::libc::c_char; 12usize],
    #[doc = "!< 4 characters for the game code. first character is usally A or B, next 2 characters is a short title\n!< and last character is for destination/language."]
    pub gamecode: [::libc::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: u16_,
    #[doc = "!< fixed value that is always 96h."]
    pub is96h: u8_,
    #[doc = "!< identifies the required hardware."]
    pub unitcode: u8_,
    #[doc = "!< used by nintedo's hardware debuggers. normally 0."]
    pub devicecode: u8_,
    pub unused: [u8_; 7usize],
    #[doc = "!< the version of the game."]
    pub version: u8_,
    #[doc = "!< complement checksum of the gba header."]
    pub complement: u8_,
    #[doc = "!< a 16 bit checksum? (gbatek says its unused/reserved)."]
    pub checksum: u16_,
}
impl Default for sGBAHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the GBA file header format.\nSee gbatek for more info."]
pub type tGBAHeader = sGBAHeader;
#[doc = "\\brief the NDS file header format\nSee gbatek for more info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sNDSHeader {
    #[doc = "!< 12 characters for the game title."]
    pub gameTitle: [::libc::c_char; 12usize],
    #[doc = "!< 4 characters for the game code."]
    pub gameCode: [::libc::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: [::libc::c_char; 2usize],
    #[doc = "!< identifies the required hardware."]
    pub unitCode: u8_,
    #[doc = "!< type of device in the game card"]
    pub deviceType: u8_,
    #[doc = "!< capacity of the device (1 << n Mbit)"]
    pub deviceSize: u8_,
    pub reserved1: [u8_; 9usize],
    #[doc = "!< version of the ROM."]
    pub romversion: u8_,
    #[doc = "!< bit 2: auto-boot flag."]
    pub flags: u8_,
    #[doc = "!< offset of the arm9 binary in the nds file."]
    pub arm9romOffset: u32_,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm9executeAddress: *mut ::libc::c_void,
    #[doc = "!< destination address to where the arm9 binary should be copied."]
    pub arm9destination: *mut ::libc::c_void,
    #[doc = "!< size of the arm9 binary."]
    pub arm9binarySize: u32_,
    #[doc = "!< offset of the arm7 binary in the nds file."]
    pub arm7romOffset: u32_,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm7executeAddress: *mut ::libc::c_void,
    #[doc = "!< destination address to where the arm7 binary should be copied."]
    pub arm7destination: *mut ::libc::c_void,
    #[doc = "!< size of the arm7 binary."]
    pub arm7binarySize: u32_,
    #[doc = "!< File Name Table (FNT) offset."]
    pub filenameOffset: u32_,
    #[doc = "!< File Name Table (FNT) size."]
    pub filenameSize: u32_,
    #[doc = "!< File Allocation Table (FAT) offset."]
    pub fatOffset: u32_,
    #[doc = "!< File Allocation Table (FAT) size."]
    pub fatSize: u32_,
    #[doc = "!< File arm9 overlay offset."]
    pub arm9overlaySource: u32_,
    #[doc = "!< File arm9 overlay size."]
    pub arm9overlaySize: u32_,
    #[doc = "!< File arm7 overlay offset."]
    pub arm7overlaySource: u32_,
    #[doc = "!< File arm7 overlay size."]
    pub arm7overlaySize: u32_,
    #[doc = "!< Port 40001A4h setting for normal commands (used in modes 1 and 3)"]
    pub cardControl13: u32_,
    #[doc = "!< Port 40001A4h setting for KEY1 commands (used in mode 2)"]
    pub cardControlBF: u32_,
    #[doc = "!< offset to the banner with icon and titles etc."]
    pub bannerOffset: u32_,
    #[doc = "!< Secure Area Checksum, CRC-16."]
    pub secureCRC16: u16_,
    #[doc = "!< Secure Area Loading Timeout."]
    pub readTimeout: u16_,
    #[doc = "!< ARM9 Auto Load List RAM Address (?)"]
    pub unknownRAM1: u32_,
    #[doc = "!< ARM7 Auto Load List RAM Address (?)"]
    pub unknownRAM2: u32_,
    #[doc = "!< Secure Area Disable part 1."]
    pub bfPrime1: u32_,
    #[doc = "!< Secure Area Disable part 2."]
    pub bfPrime2: u32_,
    #[doc = "!< total size of the ROM."]
    pub romSize: u32_,
    #[doc = "!< ROM header size."]
    pub headerSize: u32_,
    pub zeros88: [u32_; 14usize],
    #[doc = "!< Nintendo logo needed for booting the game."]
    pub gbaLogo: [u8_; 156usize],
    #[doc = "!< Nintendo Logo Checksum, CRC-16."]
    pub logoCRC16: u16_,
    #[doc = "!< header checksum, CRC-16."]
    pub headerCRC16: u16_,
}
impl Default for sNDSHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the NDS file header format\nSee gbatek for more info."]
pub type tNDSHeader = sNDSHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __DSiHeader {
    pub ndshdr: tNDSHeader,
    #[doc = "!< debug ROM offset."]
    pub debugRomSource: u32_,
    #[doc = "!< debug size."]
    pub debugRomSize: u32_,
    #[doc = "!< debug RAM destination."]
    pub debugRomDestination: u32_,
    pub offset_0x16C: u32_,
    pub zero: [u8_; 16usize],
    pub global_mbk_setting: [[u8_; 4usize]; 5usize],
    pub arm9_mbk_setting: [u32_; 3usize],
    pub arm7_mbk_setting: [u32_; 3usize],
    pub mbk9_wramcnt_setting: u32_,
    pub region_flags: u32_,
    pub access_control: u32_,
    pub scfg_ext_mask: u32_,
    pub offset_0x1BC: [u8_; 3usize],
    pub appflags: u8_,
    pub arm9iromOffset: *mut ::libc::c_void,
    pub offset_0x1C4: u32_,
    pub arm9idestination: *mut ::libc::c_void,
    pub arm9ibinarySize: u32_,
    pub arm7iromOffset: *mut ::libc::c_void,
    pub offset_0x1D4: u32_,
    pub arm7idestination: *mut ::libc::c_void,
    pub arm7ibinarySize: u32_,
    pub digest_ntr_start: u32_,
    pub digest_ntr_size: u32_,
    pub digest_twl_start: u32_,
    pub digest_twl_size: u32_,
    pub sector_hashtable_start: u32_,
    pub sector_hashtable_size: u32_,
    pub block_hashtable_start: u32_,
    pub block_hashtable_size: u32_,
    pub digest_sector_size: u32_,
    pub digest_block_sectorcount: u32_,
    pub banner_size: u32_,
    pub offset_0x20C: u32_,
    pub total_rom_size: u32_,
    pub offset_0x214: u32_,
    pub offset_0x218: u32_,
    pub offset_0x21C: u32_,
    pub modcrypt1_start: u32_,
    pub modcrypt1_size: u32_,
    pub modcrypt2_start: u32_,
    pub modcrypt2_size: u32_,
    pub tid_low: u32_,
    pub tid_high: u32_,
    pub public_sav_size: u32_,
    pub private_sav_size: u32_,
    pub reserved3: [u8_; 176usize],
    pub age_ratings: [u8_; 16usize],
    pub hmac_arm9: [u8_; 20usize],
    pub hmac_arm7: [u8_; 20usize],
    pub hmac_digest_master: [u8_; 20usize],
    pub hmac_icon_title: [u8_; 20usize],
    pub hmac_arm9i: [u8_; 20usize],
    pub hmac_arm7i: [u8_; 20usize],
    pub reserved4: [u8_; 40usize],
    pub hmac_arm9_no_secure: [u8_; 20usize],
    pub reserved5: [u8_; 2636usize],
    pub debug_args: [u8_; 384usize],
    pub rsa_signature: [u8_; 128usize],
}
impl Default for __DSiHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type tDSiHeader = __DSiHeader;
#[doc = "\\brief the NDS banner format.\nSee gbatek for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sNDSBanner {
    #[doc = "!< version of the banner."]
    pub version: u16_,
    #[doc = "!< 16 bit crc/checksum of the banner."]
    pub crc: u16_,
    pub reserved: [u8_; 28usize],
    #[doc = "!< 32*32 icon of the game with 4 bit per pixel."]
    pub icon: [u8_; 512usize],
    #[doc = "!< the pallete of the icon."]
    pub palette: [u16_; 16usize],
    #[doc = "!< title of the game in 6 different languages."]
    pub titles: [[u16_; 128usize]; 6usize],
}
impl Default for sNDSBanner {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the NDS banner format.\nSee gbatek for more information."]
pub type tNDSBanner = sNDSBanner;
extern "C" {
    #[doc = " \\fn void sysSetCartOwner(bool arm9)\n\\brief Sets the owner of the GBA cart.  Both CPUs cannot have access to the gba cart (slot 2).\n\\param arm9 if true the arm9 is the owner, otherwise the arm7"]
    #[link_name = "\u{1}sysSetCartOwner__extern"]
    pub fn sysSetCartOwner(arm9: bool);
}
extern "C" {
    #[doc = " \\fn void sysSetCardOwner(bool arm9)\n\\brief Sets the owner of the DS card bus.  Both CPUs cannot have access to the DS card bus (slot 1).\n   \\param arm9 if true the arm9 is the owner, otherwise the arm7"]
    #[link_name = "\u{1}sysSetCardOwner__extern"]
    pub fn sysSetCardOwner(arm9: bool);
}
extern "C" {
    #[doc = " \\fn void sysSetBusOwners(bool arm9rom, bool arm9card)\n\\brief Sets the owner of the DS card bus (slot 1) and gba cart bus (slot 2).  Only one cpu may access the device at a time.\n   \\param arm9rom if true the arm9 is the owner of slot 2, otherwise the arm7\n   \\param arm9card if true the arm9 is the owner of slot 1, otherwise the arm7"]
    #[link_name = "\u{1}sysSetBusOwners__extern"]
    pub fn sysSetBusOwners(arm9rom: bool, arm9card: bool);
}
#[doc = "!<\tThe display currently in a vertical blank."]
pub const DISP_IN_VBLANK: DISP_BITS = 1;
#[doc = "!<\tThe display currently in a horizontal blank."]
pub const DISP_IN_HBLANK: DISP_BITS = 2;
#[doc = "!<\tCurrent scanline and %DISP_Y match."]
pub const DISP_YTRIGGERED: DISP_BITS = 4;
#[doc = "!<\tInterrupt on vertical blank."]
pub const DISP_VBLANK_IRQ: DISP_BITS = 8;
#[doc = "!<\tInterrupt on horizontal blank."]
pub const DISP_HBLANK_IRQ: DISP_BITS = 16;
#[doc = "!<\tInterrupt when current scanline and %DISP_Y match."]
pub const DISP_YTRIGGER_IRQ: DISP_BITS = 32;
#[doc = "! LCD Status register bitdefines"]
pub type DISP_BITS = ::libc::c_uint;
extern "C" {
    #[doc = "\\brief sets the Y trigger(?)\n\n\\param Yvalue the value for the Y trigger."]
    #[link_name = "\u{1}SetYtrigger__extern"]
    pub fn SetYtrigger(Yvalue: ::libc::c_int);
}
#[doc = "!< Power the sound hardware (needed to hear stuff in GBA mode too)."]
pub const PM_SOUND_AMP: PM_Bits = 1;
#[doc = "!< Mute the main speakers, headphone output will still work."]
pub const PM_SOUND_MUTE: PM_Bits = 2;
#[doc = "!< Enable the bottom backlight if set."]
pub const PM_BACKLIGHT_BOTTOM: PM_Bits = 4;
#[doc = "!< Enable the top backlight if set."]
pub const PM_BACKLIGHT_TOP: PM_Bits = 8;
#[doc = "!< Turn the power *off* if set."]
pub const PM_SYSTEM_PWR: PM_Bits = 64;
#[doc = "!<\tControls the power for both LCD screens."]
pub const POWER_LCD: PM_Bits = 65537;
#[doc = "!<\tControls the power for the main 2D core."]
pub const POWER_2D_A: PM_Bits = 65538;
#[doc = "!<\tControls the power for the 3D matrix."]
pub const POWER_MATRIX: PM_Bits = 65540;
#[doc = "!<\tControls the power for the main 3D core."]
pub const POWER_3D_CORE: PM_Bits = 65544;
#[doc = "!<\tControls the power for the sub 2D core."]
pub const POWER_2D_B: PM_Bits = 66048;
#[doc = "!<\tControls which screen should use the main core."]
pub const POWER_SWAP_LCDS: PM_Bits = 98304;
#[doc = "!< power just 2D hardware."]
pub const POWER_ALL_2D: PM_Bits = 66051;
#[doc = "!< power everything."]
pub const POWER_ALL: PM_Bits = 66063;
#[doc = "! Power Management control bits"]
pub type PM_Bits = ::libc::c_uint;
extern "C" {
    #[doc = "\t\\brief Causes the nds to go to sleep.\nThe nds will be reawakened when the lid is opened.\n\n\\note By default, this is automatically called when closing the lid."]
    pub fn systemSleep();
}
extern "C" {
    #[doc = "\tSet the LED blink mode\n\\param bm What to power on."]
    pub fn ledBlink(bm: ::libc::c_int);
}
extern "C" {
    #[doc = "!\tChecks whether the application is running in DSi mode."]
    #[link_name = "\u{1}isDSiMode__extern"]
    pub fn isDSiMode() -> bool;
}
extern "C" {
    #[doc = "!\tTurns on specified hardware.\n*!\tMay be called from arm7 or arm9 (arm9 power bits will be ignored by arm7, arm7 power bits\nwill be passed to the arm7 from the arm9).\n\n\\param bits What to power on.\n*/"]
    pub fn powerOn(bits: ::libc::c_int);
}
extern "C" {
    #[doc = "!\tTurns off specified hardware.\n*!\tMay be called from arm7 or arm9 (arm9 power bits will be ignored by arm7, arm7 power bits\nwill be passed to the arm7 from the arm9).\n\n\\param bits What to power on.\n*/"]
    pub fn powerOff(bits: ::libc::c_int);
}
extern "C" {
    pub fn systemMsgHandler(bytes: ::libc::c_int, user_data: *mut ::libc::c_void);
}
extern "C" {
    pub fn systemValueHandler(value: u32_, data: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "!\tSwitches the screens."]
    #[link_name = "\u{1}lcdSwap__extern"]
    pub fn lcdSwap();
}
extern "C" {
    #[doc = "!\tForces the main core to display on the top."]
    #[link_name = "\u{1}lcdMainOnTop__extern"]
    pub fn lcdMainOnTop();
}
extern "C" {
    #[doc = "!\tForces the main core to display on the bottom."]
    #[link_name = "\u{1}lcdMainOnBottom__extern"]
    pub fn lcdMainOnBottom();
}
extern "C" {
    #[doc = "! Powers down the DS"]
    #[link_name = "\u{1}systemShutDown__extern"]
    pub fn systemShutDown();
}
extern "C" {
    pub fn readFirmware(address: u32_, buffer: *mut ::libc::c_void, length: u32_);
}
extern "C" {
    pub fn writeFirmware(address: u32_, buffer: *mut ::libc::c_void, length: u32_)
        -> ::libc::c_int;
}
extern "C" {
    #[doc = "! gets the DS Battery level"]
    pub fn getBatteryLevel() -> u32_;
}
extern "C" {
    #[doc = "!\tSet the arm9 vector base\n*!\tArm9 only\n\\param highVector high vector\n*/"]
    pub fn setVectorBase(highVector: ::libc::c_int);
}
#[doc = " \\brief A struct with all the CPU exeption vectors.\neach member contains an ARM instuction that will be executed when an exeption occured.\n\nSee gbatek for more information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sysVectors_t {
    #[doc = "!< CPU reset."]
    pub reset: VoidFn,
    #[doc = "!< undefined instruction."]
    pub undefined: VoidFn,
    #[doc = "!< software interrupt."]
    pub swi: VoidFn,
    #[doc = "!< prefetch abort."]
    pub prefetch_abort: VoidFn,
    #[doc = "!< data abort."]
    pub data_abort: VoidFn,
    #[doc = "!< fast interrupt."]
    pub fiq: VoidFn,
}
#[doc = " \\brief A struct with all the CPU exeption vectors.\neach member contains an ARM instuction that will be executed when an exeption occured.\n\nSee gbatek for more information."]
pub type sysVectors = sysVectors_t;
extern "C" {
    pub static mut SystemVectors: sysVectors;
}
extern "C" {
    pub fn setSDcallback(
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    );
}
extern "C" {
    #[doc = "\\brief Sets the ARM9 clock speed, only possible in DSi mode\n\\param speed CPU speed (false = 67.03MHz, true = 134.06MHz)\n\\return The old CPU speed value"]
    pub fn setCpuClock(speed: bool) -> bool;
}
extern "C" {
    #[doc = "! returns current start of heap space"]
    pub fn getHeapStart() -> *mut u8_;
}
extern "C" {
    #[doc = "! returns current end of heap space"]
    pub fn getHeapEnd() -> *mut u8_;
}
extern "C" {
    #[doc = "! returns current heap limit"]
    pub fn getHeapLimit() -> *mut u8_;
}
#[doc = "!< low backlight setting."]
pub const BACKLIGHT_LOW: BACKLIGHT_LEVELS = 0;
#[doc = "!< medium backlight setting."]
pub const BACKLIGHT_MED: BACKLIGHT_LEVELS = 1;
#[doc = "!< high backlight setting."]
pub const BACKLIGHT_HIGH: BACKLIGHT_LEVELS = 2;
#[doc = "!< max backlight setting."]
pub const BACKLIGHT_MAX: BACKLIGHT_LEVELS = 3;
#[doc = "\t\\brief Backlight level settings.\nNote, these are only available on DS Lite."]
pub type BACKLIGHT_LEVELS = ::libc::c_uint;
#[doc = "\\brief User's DS settings.\nDefines the structure the DS firmware uses for transfer\nof the user's settings to the booted program.\n\nTheme/Color values:\n- 0 = Gray\n- 1 = Brown\n- 2 = Red\n- 3 = Pink\n- 4 = Orange\n- 5 = Yellow\n- 6 = Yellow/Green-ish\n- 7 = Green\n- 8 = Dark Green\n- 9 = Green/Blue-ish\n- 10 = Light Blue\n- 11 = Blue\n- 12 = Dark Blue\n- 13 = Dark Purple\n- 14 = Purple\n- 15 = Purple/Red-ish\n\nLanguage values:\n- 0 = Japanese\n- 1 = English\n- 2 = French\n- 3 = German\n- 4 = Italian\n- 5 = Spanish\n- 6 = Chinese(?)\n- 7 = Unknown/Reserved"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tPERSONAL_DATA {
    pub RESERVED0: [u8_; 2usize],
    #[doc = "!<\tThe user's theme color (0-15)."]
    pub theme: u8_,
    #[doc = "!<\tThe user's birth month (1-12)."]
    pub birthMonth: u8_,
    #[doc = "!<\tThe user's birth day (1-31)."]
    pub birthDay: u8_,
    pub RESERVED1: [u8_; 1usize],
    #[doc = "!<\tThe user's name in UTF-16 format."]
    pub name: [s16; 10usize],
    #[doc = "!<\tThe length of the user's name in characters."]
    pub nameLen: u16_,
    #[doc = "!<\tThe user's message."]
    pub message: [s16; 26usize],
    #[doc = "!<\tThe length of the user's message in characters."]
    pub messageLen: u16_,
    #[doc = "!<\tWhat hour the alarm clock is set to (0-23)."]
    pub alarmHour: u8_,
    #[doc = "!<\tWhat minute the alarm clock is set to (0-59)."]
    pub alarmMinute: u8_,
    pub RESERVED2: [u8_; 4usize],
    #[doc = "!<\tTouchscreen calibration: first X touch"]
    pub calX1: u16_,
    #[doc = "!<\tTouchscreen calibration: first Y touch"]
    pub calY1: u16_,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calX1px: u8_,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calY1px: u8_,
    #[doc = "!<\tTouchscreen calibration: second X touch"]
    pub calX2: u16_,
    #[doc = "!<\tTouchscreen calibration: second Y touch"]
    pub calY2: u16_,
    #[doc = "!<\tTouchscreen calibration: second X touch pixel"]
    pub calX2px: u8_,
    #[doc = "!<\tTouchscreen calibration: second Y touch pixel"]
    pub calY2px: u8_,
    pub __bindgen_anon_1: tPERSONAL_DATA__bindgen_ty_1,
    pub RESERVED3: u16_,
    #[doc = "!<\tReal Time Clock offset."]
    pub rtcOffset: u32_,
    pub RESERVED4: u32_,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tPERSONAL_DATA__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tPERSONAL_DATA__bindgen_ty_1 {
    #[inline]
    pub fn language(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_language(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn gbaScreen(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gbaScreen(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn defaultBrightness(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_defaultBrightness(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn autoMode(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoMode(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED5(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED5(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn settingsLost(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_settingsLost(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED6(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED6(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        language: ::libc::c_uint,
        gbaScreen: ::libc::c_uint,
        defaultBrightness: ::libc::c_uint,
        autoMode: ::libc::c_uint,
        RESERVED5: ::libc::c_uint,
        settingsLost: ::libc::c_uint,
        RESERVED6: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let language: u32 = unsafe { ::core::mem::transmute(language) };
            language as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gbaScreen: u32 = unsafe { ::core::mem::transmute(gbaScreen) };
            gbaScreen as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let defaultBrightness: u32 = unsafe { ::core::mem::transmute(defaultBrightness) };
            defaultBrightness as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let autoMode: u32 = unsafe { ::core::mem::transmute(autoMode) };
            autoMode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let RESERVED5: u32 = unsafe { ::core::mem::transmute(RESERVED5) };
            RESERVED5 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let settingsLost: u32 = unsafe { ::core::mem::transmute(settingsLost) };
            settingsLost as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let RESERVED6: u32 = unsafe { ::core::mem::transmute(RESERVED6) };
            RESERVED6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "\\brief User's DS settings.\nDefines the structure the DS firmware uses for transfer\nof the user's settings to the booted program.\n\nTheme/Color values:\n- 0 = Gray\n- 1 = Brown\n- 2 = Red\n- 3 = Pink\n- 4 = Orange\n- 5 = Yellow\n- 6 = Yellow/Green-ish\n- 7 = Green\n- 8 = Dark Green\n- 9 = Green/Blue-ish\n- 10 = Light Blue\n- 11 = Blue\n- 12 = Dark Blue\n- 13 = Dark Purple\n- 14 = Purple\n- 15 = Purple/Red-ish\n\nLanguage values:\n- 0 = Japanese\n- 1 = English\n- 2 = French\n- 3 = German\n- 4 = Italian\n- 5 = Spanish\n- 6 = Chinese(?)\n- 7 = Unknown/Reserved"]
pub type PERSONAL_DATA = tPERSONAL_DATA;
#[doc = "! struct containing time and day of the real time clock."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTCtime {
    #[doc = "!< add 2000 to get 4 digit year"]
    pub year: u8_,
    #[doc = "!< 1 to 12"]
    pub month: u8_,
    #[doc = "!< 1 to (days in month)"]
    pub day: u8_,
    #[doc = "!< day of week"]
    pub weekday: u8_,
    #[doc = "!< 0 to 11 for AM, 52 to 63 for PM"]
    pub hours: u8_,
    #[doc = "!< 0 to 59"]
    pub minutes: u8_,
    #[doc = "!< 0 to 59"]
    pub seconds: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __argv {
    pub argvMagic: ::libc::c_int,
    pub commandLine: *mut ::libc::c_char,
    pub length: ::libc::c_int,
    pub argc: ::libc::c_int,
    pub argv: *mut *mut ::libc::c_char,
    pub dummy: ::libc::c_int,
    pub host: u32_,
}
impl Default for __argv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __bootstub {
    pub bootsig: u64_,
    pub arm9reboot: VoidFn,
    pub arm7reboot: VoidFn,
    pub bootsize: u32_,
}
extern "C" {
    #[doc = "\\brief returns a cached mirror of an address.\n\\param address an address.\n\\return a pointer to the cached mirror of that address."]
    pub fn memCached(address: *mut ::libc::c_void) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "\\brief returns an uncached mirror of an address.\n\\param address an address.\n\\return a pointer to the uncached mirror of that address."]
    pub fn memUncached(address: *mut ::libc::c_void) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn resetARM7(address: u32_);
}
#[doc = "!< divides the timer clock by 1 (~33513.982 kHz)"]
pub const ClockDivider_1: ClockDivider = 0;
#[doc = "!< divides the timer clock by 64 (~523.657 kHz)"]
pub const ClockDivider_64: ClockDivider = 1;
#[doc = "!< divides the timer clock by 256 (~130.914 kHz)"]
pub const ClockDivider_256: ClockDivider = 2;
#[doc = "!< divides the timer clock by 1024 (~32.7284 kHz)"]
pub const ClockDivider_1024: ClockDivider = 3;
#[doc = "! allowable timer clock dividers."]
pub type ClockDivider = ::libc::c_uint;
extern "C" {
    #[doc = "\t\\brief start a hardware timer.\nCallback is tied directly to interrupt table and called directly, resulting in less latency than the attached timer.\n\\param timer \tThe hardware timer to use (0 - 3).\n\\param divider \tThe timer channel clock divider (clock will tick at 33.513982 MHz / divider)\n\\param ticks\tThe number of ticks which must elapse before the timer overflows\n\\param callback The callback to be called when the timer expires (if null, no IRQ will be generated by the timer)"]
    pub fn timerStart(timer: ::libc::c_int, divider: ClockDivider, ticks: u16_, callback: VoidFn);
}
extern "C" {
    #[doc = "\t\\brief returns the ticks elapsed since the last call to timerElapsed().\n\\param timer The hardware timer to use (0 - 3).\n\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerElapsed(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief returns the raw ticks of the specified timer.\n\\param timer The hardware timer to use (0 - 3).\n\\return the raw ticks of the specified timer data register."]
    #[link_name = "\u{1}timerTick__extern"]
    pub fn timerTick(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief pauses the specified timer.\n\\param timer The hardware timer to use (0 - 3).\n\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerPause(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief unpauses the specified timer.\n\\param timer The hardware timer to use (0 - 3)."]
    #[link_name = "\u{1}timerUnpause__extern"]
    pub fn timerUnpause(timer: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Stops the specified timer.\n\\param timer The hardware timer to use (0 - 3).\n\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerStop(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief begins cpu Timing using two timers for 32bit resolution.\n\\param timer The base hardware timer to use (0 - 2)."]
    pub fn cpuStartTiming(timer: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief returns the number of ticks which have elapsed since cpuStartTiming.\n\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuGetTiming() -> u32_;
}
extern "C" {
    #[doc = "\t\\brief ends cpu Timing.\n\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuEndTiming() -> u32_;
}
extern "C" {
    #[link_name = "\u{1}timerTicks2usec__extern"]
    pub fn timerTicks2usec(ticks: u32_) -> u32_;
}
extern "C" {
    #[link_name = "\u{1}timerTicks2msec__extern"]
    pub fn timerTicks2msec(ticks: u32_) -> u32_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_1__extern"]
    pub fn timerFreqToTicks_1(freq: ::libc::c_int) -> u16_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_64__extern"]
    pub fn timerFreqToTicks_64(freq: ::libc::c_int) -> u16_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_256__extern"]
    pub fn timerFreqToTicks_256(freq: ::libc::c_int) -> u16_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_1024__extern"]
    pub fn timerFreqToTicks_1024(freq: ::libc::c_int) -> u16_;
}
#[doc = "< \\brief fifo channel reserved for power management."]
pub const FIFO_PM: FifoChannels = 0;
#[doc = "< \\brief fifo channel reserved for sound access."]
pub const FIFO_SOUND: FifoChannels = 1;
#[doc = "< \\brief fifo channel reserved for system functions."]
pub const FIFO_SYSTEM: FifoChannels = 2;
#[doc = "< \\brief fifo channel reserved for the maxmod library."]
pub const FIFO_MAXMOD: FifoChannels = 3;
#[doc = "< \\brief fifo channel reserved for the dswifi library."]
pub const FIFO_DSWIFI: FifoChannels = 4;
#[doc = "< \\brief fifo channel reserved for dsi sdmmc control."]
pub const FIFO_SDMMC: FifoChannels = 5;
#[doc = "< \\brief fifo channel reserved for firmware access."]
pub const FIFO_FIRMWARE: FifoChannels = 6;
#[doc = "< \\brief fifo channel reserved for future use."]
pub const FIFO_RSVD_01: FifoChannels = 7;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_01: FifoChannels = 8;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_02: FifoChannels = 9;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_03: FifoChannels = 10;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_04: FifoChannels = 11;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_05: FifoChannels = 12;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_06: FifoChannels = 13;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_07: FifoChannels = 14;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_08: FifoChannels = 15;
#[doc = "! Enum values for the different fifo channels."]
pub type FifoChannels = ::libc::c_uint;
pub const SOUND_SET_PAN: FifoSoundCommand = 0;
pub const SOUND_SET_VOLUME: FifoSoundCommand = 1048576;
pub const SOUND_SET_FREQ: FifoSoundCommand = 2097152;
pub const SOUND_SET_WAVEDUTY: FifoSoundCommand = 3145728;
pub const SOUND_MASTER_ENABLE: FifoSoundCommand = 4194304;
pub const SOUND_MASTER_DISABLE: FifoSoundCommand = 5242880;
pub const SOUND_PAUSE: FifoSoundCommand = 6291456;
pub const SOUND_RESUME: FifoSoundCommand = 7340032;
pub const SOUND_KILL: FifoSoundCommand = 8388608;
pub const SOUND_SET_MASTER_VOL: FifoSoundCommand = 9437184;
pub const MIC_STOP: FifoSoundCommand = 10485760;
#[doc = "! Enum values for the fifo sound commands."]
pub type FifoSoundCommand = ::libc::c_uint;
pub const SYS_REQ_TOUCH: FifoSystemCommands = 0;
pub const SYS_REQ_KEYS: FifoSystemCommands = 1;
pub const SYS_REQ_TIME: FifoSystemCommands = 2;
pub const SYS_SET_TIME: FifoSystemCommands = 3;
pub const SDMMC_INSERT: FifoSystemCommands = 4;
pub const SDMMC_REMOVE: FifoSystemCommands = 5;
#[doc = "! Enum values for the fifo system commands."]
pub type FifoSystemCommands = ::libc::c_uint;
pub const SDMMC_HAVE_SD: FifoSdmmcCommands = 0;
pub const SDMMC_SD_START: FifoSdmmcCommands = 1;
pub const SDMMC_SD_IS_INSERTED: FifoSdmmcCommands = 2;
pub const SDMMC_SD_STOP: FifoSdmmcCommands = 3;
pub const SDMMC_NAND_START: FifoSdmmcCommands = 4;
pub const SDMMC_NAND_STOP: FifoSdmmcCommands = 5;
pub const SDMMC_NAND_SIZE: FifoSdmmcCommands = 6;
pub type FifoSdmmcCommands = ::libc::c_uint;
pub const FW_READ: FifoFirmwareCommands = 0;
pub const FW_WRITE: FifoFirmwareCommands = 1;
pub type FifoFirmwareCommands = ::libc::c_uint;
pub const PM_REQ_ON: FifoPMCommands = 65536;
pub const PM_REQ_OFF: FifoPMCommands = 131072;
pub const PM_REQ_LED: FifoPMCommands = 196608;
pub const PM_REQ_SLEEP: FifoPMCommands = 262144;
pub const PM_REQ_SLEEP_DISABLE: FifoPMCommands = 327680;
pub const PM_REQ_SLEEP_ENABLE: FifoPMCommands = 393216;
pub const PM_REQ_BATTERY: FifoPMCommands = 458752;
pub const PM_REQ_SLOT1_DISABLE: FifoPMCommands = 524288;
pub const PM_REQ_SLOT1_ENABLE: FifoPMCommands = 589824;
#[doc = "! Enum values for the fifo power management commands."]
pub type FifoPMCommands = ::libc::c_uint;
pub const WIFI_ENABLE: FifoWifiCommands = 0;
pub const WIFI_DISABLE: FifoWifiCommands = 1;
pub const WIFI_SYNC: FifoWifiCommands = 2;
pub const WIFI_STARTUP: FifoWifiCommands = 3;
#[doc = "! Enum values for the fifo wifi commands."]
pub type FifoWifiCommands = ::libc::c_uint;
#[doc = "< \\brief  Steady on"]
pub const PM_LED_ON: PM_LedBlinkMode = 0;
#[doc = "< \\brief Blinking, mostly off"]
pub const PM_LED_SLEEP: PM_LedBlinkMode = 1;
#[doc = "< \\brief Blinking, mostly on"]
pub const PM_LED_BLINK: PM_LedBlinkMode = 3;
#[doc = "! Power Management LED blink mode control bits."]
pub type PM_LedBlinkMode = ::libc::c_uint;
#[doc = "\\brief fifo callback function pointer with the sent address and the callback's user data.\n\nThe handler is called when new data arrives.\n\n\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,\nbut don't call alloc, free or printf from within them, just to be safe."]
pub type FifoAddressHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(address: *mut ::libc::c_void, userdata: *mut ::libc::c_void),
>;
#[doc = "\\brief fifo callback function pointer with the sent value and the callback's user data.\n\nThe handler is called when new data arrives.\n\n\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,\nbut don't call alloc, free or printf from within them, just to be safe."]
pub type FifoValue32HandlerFunc =
    ::core::option::Option<unsafe extern "C" fn(value32: u32_, userdata: *mut ::libc::c_void)>;
#[doc = "\\brief fifo callback function pointer with the number of bytes sent and the callback's user data\n\nThe handler is called when new data arrives.\nThis callback must call fifoGetData to actually retrieve the data. If it doesn't, the data will be destroyed on return.\n\n\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,\nbut don't call alloc, free or printf from within them, just to be safe."]
pub type FifoDatamsgHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(num_bytes: ::libc::c_int, userdata: *mut ::libc::c_void),
>;
extern "C" {
    #[doc = "\\brief Initializes the fifo system.\n\nAttempts to sync with the other CPU, if it fails, fifo services won't be provided.\n\n\\note call irqInit() before calling this function.\n\n\\return true if syncing worked, false if something went wrong."]
    pub fn fifoInit() -> bool;
}
extern "C" {
    #[doc = "\\brief Send an address to an channel.\n\nTransmits an address in the range 0x02000000-0x023FFFFF to the other CPU.\n\n\\param channel channel number to send to.\n\\param address address to send.\n\n\\return true if the address has been send, false if something went wrong."]
    pub fn fifoSendAddress(channel: ::libc::c_int, address: *mut ::libc::c_void) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a 32bit value.\n\nTransmits a 32bit value to the other CPU.\n\n\\param channel channel number to send to\n\\param value32 32bit value to send\n\n\\return true if the value has been send, false if something went wrong.\n\n\\note Transfer is more efficient if the top 8 bits are zero. So sending smaller values or bitmasks that don't include the top bits is preferred."]
    pub fn fifoSendValue32(channel: ::libc::c_int, value32: u32_) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a sequence of bytes to the other CPU.\n\nnum_bytes can be between 0 and FIFO_MAX_DATA_BYTES - sending 0 bytes can be useful sometimes...\n\n\\param channel channel number to send to\n\\param num_bytes number of bytes to send\n\\param data_array pointer to data array\n\n\\return true if the data message has been send, false if something went wrong."]
    pub fn fifoSendDatamsg(
        channel: ::libc::c_int,
        num_bytes: ::libc::c_int,
        data_array: *mut u8_,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user address message callback.\n\nSet a callback to receive incoming address messages on a specific channel.\n\n\\param channel channel number to send to.\n\\param newhandler a function pointer to the new handler function.\n\\param userdata a pointer that will be passed on to the handler when it will be called.\n\n\\return true if the handler has been set, false if something went wrong.\n\n\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetAddressHandler(
        channel: ::libc::c_int,
        newhandler: FifoAddressHandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user value32 message callback.\n\nSet a callback to receive incoming value32 messages on a specific channel.\n\n\\param channel channel number to send to.\n\\param newhandler a function pointer to the new handler function.\n\\param userdata a pointer that will be passed on to the handler when it will be called.\n\n\\return true if the handler has been set, false if something went wrong.\n\n\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetValue32Handler(
        channel: ::libc::c_int,
        newhandler: FifoValue32HandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user data message callback.\n\nSet a callback to receive incoming data messages on a specific channel.\n\n\\param channel channel number to send to.\n\\param newhandler a function pointer to the new handler function.\n\\param userdata a pointer that will be passed on to the handler when it will be called.\n\n\\return true if the handler has been set, false if something went wrong.\n\n\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetDatamsgHandler(
        channel: ::libc::c_int,
        newhandler: FifoDatamsgHandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any addresses in the fifo queue.\n\n\\param channel the channel to check.\n\n\\return true if there is any addresses in the queue and if there isn't an address handler in place for the channel."]
    pub fn fifoCheckAddress(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any values in the fifo queue.\n\n\\param channel the channel to check.\n\n\\return true if there is any values in the queue and if there isn't a value handler in place for the channel."]
    pub fn fifoCheckValue32(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any data messages in the fifo queue.\n\n\\param channel the channel to check.\n\n\\return true if there is any data messages in the queue and if there isn't a data message handler in place for the channel."]
    pub fn fifoCheckDatamsg(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief gets the number of bytes in the queue for the first data entry.\n\n\\param channel the channel to check.\n\n\\return the number of bytes in the queue for the first data entry, or -1 if there are no entries."]
    pub fn fifoCheckDatamsgLength(channel: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief Get the first address in queue for a specific channel.\n\n\\param channel the channel to check.\n\n\\return the first address in queue, or NULL if there is none."]
    pub fn fifoGetAddress(channel: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "\\brief Get the first value32 in queue for a specific channel.\n\n\\param channel the channel to check.\n\n\\return the first value32 in queue, or 0 if there is no message."]
    pub fn fifoGetValue32(channel: ::libc::c_int) -> u32_;
}
extern "C" {
    #[doc = "\\brief Reads a data message in a given buffer and returns the number of bytes written.\n\n\\param channel the channel to check.\n\\param buffersize the size of the buffer where the message will be copied to.\n\\param destbuffer a pointer to the buffer where the message will be copied to.\n\n\\return the number of bytes written, or -1 if there is no message.\n\n\\warning If your buffer is not big enough, you may lose data! Check the data length first if you're not sure what the size is."]
    pub fn fifoGetDatamsg(
        channel: ::libc::c_int,
        buffersize: ::libc::c_int,
        destbuffer: *mut u8_,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief waits for any data messages in the fifo queue.\n\n\\param channel the channel to check."]
    #[link_name = "\u{1}fifoWaitValue32__extern"]
    pub fn fifoWaitValue32(channel: ::libc::c_int);
}
#[doc = "! holds data related to the touch screen."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct touchPosition {
    #[doc = "!< Raw x value from the A2D"]
    pub rawx: u16_,
    #[doc = "!< Raw y value from the A2D"]
    pub rawy: u16_,
    #[doc = "!< Processes pixel X value"]
    pub px: u16_,
    #[doc = "!< Processes pixel Y value"]
    pub py: u16_,
    #[doc = "!< Raw cross panel resistance"]
    pub z1: u16_,
    #[doc = "!< Raw cross panel resistance"]
    pub z2: u16_,
}
#[doc = "!< Keypad A button."]
pub const KEY_A: KEYPAD_BITS = 1;
#[doc = "!< Keypad B button."]
pub const KEY_B: KEYPAD_BITS = 2;
#[doc = "!< Keypad SELECT button."]
pub const KEY_SELECT: KEYPAD_BITS = 4;
#[doc = "!< Keypad START button."]
pub const KEY_START: KEYPAD_BITS = 8;
#[doc = "!< Keypad RIGHT button."]
pub const KEY_RIGHT: KEYPAD_BITS = 16;
#[doc = "!< Keypad LEFT button."]
pub const KEY_LEFT: KEYPAD_BITS = 32;
#[doc = "!< Keypad UP button."]
pub const KEY_UP: KEYPAD_BITS = 64;
#[doc = "!< Keypad DOWN button."]
pub const KEY_DOWN: KEYPAD_BITS = 128;
#[doc = "!< Right shoulder button."]
pub const KEY_R: KEYPAD_BITS = 256;
#[doc = "!< Left shoulder button."]
pub const KEY_L: KEYPAD_BITS = 512;
#[doc = "!< Keypad X button."]
pub const KEY_X: KEYPAD_BITS = 1024;
#[doc = "!< Keypad Y button."]
pub const KEY_Y: KEYPAD_BITS = 2048;
#[doc = "!< Touchscreen pendown."]
pub const KEY_TOUCH: KEYPAD_BITS = 4096;
#[doc = "!< Lid state."]
pub const KEY_LID: KEYPAD_BITS = 8192;
#[doc = "! enum values for the keypad buttons."]
pub type KEYPAD_BITS = ::libc::c_uint;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swiSHA1context {
    #[doc = "< intermediate digest state"]
    pub state: [u32_; 5usize],
    #[doc = "< number of bytes processed"]
    pub total: [u32_; 2usize],
    #[doc = "< data block being processed"]
    pub buffer: [u8_; 64usize],
    pub fragment_size: u32_,
    #[doc = "< data block being processed"]
    pub sha_block: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut swiSHA1context, src: *const ::libc::c_void, len: usize),
    >,
}
impl Default for swiSHA1context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type swiSHA1context_t = swiSHA1context;
extern "C" {
    #[doc = " \\brief          SHA-1 context setup\n\n \\param ctx      context to be initialized"]
    pub fn swiSHA1Init(ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 process buffer\n\n \\param ctx      SHA-1 context\n \\param data     buffer to process\n \\param len      length of data"]
    pub fn swiSHA1Update(ctx: *mut swiSHA1context_t, data: *const ::libc::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief          SHA-1 final digest\n\n \\param digest   buffer to hold SHA-1 checksum result\n \\param ctx      SHA-1 context"]
    pub fn swiSHA1Final(digest: *mut ::libc::c_void, ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 checksum\n\n \\param digest   buffer to hold SHA-1 checksum result\n \\param data     buffer to process\n \\param len      length of data"]
    pub fn swiSHA1Calc(digest: *mut ::libc::c_void, data: *const ::libc::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief          SHA-1 verify\n\n \\param digest1  buffer containing hash to verify\n \\param digest2  buffer containing hash to verify"]
    pub fn swiSHA1Verify(digest1: *const ::libc::c_void, digest2: *const ::libc::c_void);
}
pub type wint_t = ::libc::c_uint;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type __blkcnt_t = ::libc::c_long;
pub type __blksize_t = ::libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::libc::c_long;
pub type __size_t = ::libc::c_ulong;
pub type _ssize_t = ::libc::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::libc::c_uchar; 4usize],
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut ::libc::c_void;
pub type __clock_t = ::libc::c_ulong;
pub type __time_t = ::libc::c_long;
pub type __clockid_t = ::libc::c_ulong;
pub type __timer_t = ::libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::libc::c_int;
pub type __nlink_t = ::libc::c_ushort;
pub type __suseconds_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_ulong;
pub type __ULong = ::libc::c_uint;
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::libc::c_int;
}
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _unspecified_locale_info: ::libc::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::libc::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::libc::c_uint,
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::libc::c_uchar; 30usize],
    pub _nmalloc: [::libc::c_uint; 30usize],
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::libc::c_int,
    pub rem: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::libc::c_longlong,
    pub rem: ::libc::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void) -> ::libc::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::libc::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::libc::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::libc::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::libc::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::libc::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::libc::c_void,
        __base: *const ::libc::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn calloc(arg1: ::libc::c_ulong, arg2: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn div(__numer: ::libc::c_int, __denom: ::libc::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::libc::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _getenv_r(arg1: *mut _reent, __string: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _findenv(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *mut ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::libc::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::libc::c_char,
        arg2: *const *mut ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn labs(arg1: ::libc::c_long) -> ::libc::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::libc::c_long, __denom: ::libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::libc::c_char, arg2: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::libc::c_char, arg3: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::libc::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::libc::c_char, arg2: wchar_t) -> ::libc::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::libc::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::libc::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut ::libc::c_char, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::libc::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::libc::c_int;
}
extern "C" {
    pub fn realloc(arg1: *mut ::libc::c_void, arg2: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn reallocarray(arg1: *mut ::libc::c_void, arg2: usize, arg3: usize)
        -> *mut ::libc::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut ::libc::c_void, arg2: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::libc::c_char,
        resolved_path: *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn srand(__seed: ::libc::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const ::libc::c_char, __end_PTR: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const ::libc::c_char, __end_PTR: *mut *mut ::libc::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn l64a(__input: ::libc::c_long) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: ::libc::c_long) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::libc::c_int, arg2: *mut ::libc::c_void),
        >,
        __arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::libc::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_void,
        arg3: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::libc::c_char,
        __value: *const ::libc::c_char,
        __overwrite: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::libc::c_char,
        __value: *const ::libc::c_char,
        __overwrite: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ::libc::c_int,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::libc::c_uint,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::libc::c_int,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::libc::c_uint,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::libc::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::libc::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::libc::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::libc::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::libc::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::libc::c_long;
}
extern "C" {
    pub fn mrand48() -> ::libc::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::libc::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::libc::c_ushort) -> *mut ::libc::c_ushort;
}
extern "C" {
    pub fn _seed48_r(arg1: *mut _reent, arg2: *mut ::libc::c_ushort) -> *mut ::libc::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::libc::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::libc::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ::libc::c_uint,
        arg2: *mut ::libc::c_char,
        arg3: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn random() -> ::libc::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn srandom(arg1: ::libc::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ::libc::c_char) -> ::libc::c_longlong;
}
extern "C" {
    pub fn _atoll_r(arg1: *mut _reent, __nptr: *const ::libc::c_char) -> ::libc::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::libc::c_longlong) -> ::libc::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: ::libc::c_longlong, __denom: ::libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::libc::c_char,
        __end_PTR: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn _unsetenv_r(arg1: *mut _reent, __string: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::libc::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: *mut ::libc::c_int,
        arg6: *mut ::libc::c_int,
        arg7: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::libc::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_void,
        arg3: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::libc::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
        arg4: *const ::libc::c_char,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::libc::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::libc::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *const ::libc::c_void,
                arg3: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char) -> u128;
}
extern "C" {
    pub fn aligned_alloc(arg1: ::libc::c_ulong, arg2: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> ::libc::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::libc::c_int);
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::libc::c_void, arg2: ::libc::c_ulong);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::libc::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
}
extern "C" {
    pub fn fls(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
}
extern "C" {
    pub fn index(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::libc::c_void,
        arg2: ::libc::c_int,
        arg3: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::libc::c_void,
        arg2: ::libc::c_int,
        arg3: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_ulong,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::libc::c_int, arg2: locale_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_int,
        arg4: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn stpcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::libc::c_char, arg2: ::libc::c_ulong) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strerror_r(arg1: ::libc::c_int, arg2: *mut ::libc::c_char, arg3: usize)
        -> ::libc::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: *mut ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strnlen(arg1: *const ::libc::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::libc::c_int) -> *mut ::libc::c_char;
}
#[doc = "! A resizable array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DynamicArray {
    #[doc = "!< pointer to array of void pointers"]
    pub data: *mut *mut ::libc::c_void,
    #[doc = "!< currently allocated size of the array"]
    pub cur_size: ::libc::c_uint,
}
impl Default for DynamicArray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief Initializes an array with the supplied initial size\n\\param v the array to initialize\n\\param initialSize the initial size to allocate\n\\return a pointer to the data, or NULL on error."]
    pub fn DynamicArrayInit(
        v: *mut DynamicArray,
        initialSize: ::libc::c_uint,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\brief Frees memory allocated by the dynamic array\n\\param v The array to delete"]
    pub fn DynamicArrayDelete(v: *mut DynamicArray);
}
extern "C" {
    #[doc = " \\brief Gets the entry at the supplied index\n\\param v The array to get from.\n\\param index The index of the data to get.\n\\return The data or NULL if v is NULL or the index is out of range."]
    pub fn DynamicArrayGet(v: *mut DynamicArray, index: ::libc::c_uint) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\brief Sets the entry to the supplied value\n\\param v The array to set\n\\param index The index of the data to set (array will be resized to fit the index).\n\\param item The data to set.\n\\return false if v is NULL or there isn't enough memory, true otherwise"]
    pub fn DynamicArraySet(
        v: *mut DynamicArray,
        index: ::libc::c_uint,
        item: *mut ::libc::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mallinfo {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
extern "C" {
    pub fn memalign(arg1: ::libc::c_ulong, arg2: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn _memalign_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn _mallinfo_r(arg1: *mut _reent) -> mallinfo;
}
extern "C" {
    pub fn malloc_stats();
}
extern "C" {
    pub fn _malloc_stats_r(arg1: *mut _reent);
}
extern "C" {
    pub fn mallopt(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn _mallopt_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: ::libc::c_int)
        -> ::libc::c_int;
}
extern "C" {
    pub fn malloc_usable_size(arg1: *mut ::libc::c_void) -> usize;
}
extern "C" {
    pub fn _malloc_usable_size_r(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> usize;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn _valloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn pvalloc(arg1: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn _pvalloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_trim(arg1: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn _malloc_trim_r(arg1: *mut _reent, arg2: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn __malloc_lock(arg1: *mut _reent);
}
extern "C" {
    pub fn __malloc_unlock(arg1: *mut _reent);
}
extern "C" {
    pub fn mstats(arg1: *mut ::libc::c_char);
}
#[doc = "! A node for the linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedList {
    #[doc = "!< A pointer to the next node."]
    pub next: *mut LinkedList,
    #[doc = "!< A pointer to the previous node."]
    pub prev: *mut LinkedList,
    #[doc = "!< A pointer to some data."]
    pub data: *mut ::libc::c_void,
}
impl Default for LinkedList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "\\brief Adds data to a linked list.\n\nThis will only store the pointer to the data, so you have to make sure that the pointer stays valid.\n\n\\param front A pointer to a pointer to the front of the linked list (or a pointer to NULL if you don't have a linked list yet).\n\\param data A pointer to the data you want to store.\n\n\\return A pointer to the new node, which is also the new front, or NULL if there is not enough memory."]
    pub fn linkedlistAdd(front: *mut *mut LinkedList, data: *mut ::libc::c_void)
        -> *mut LinkedList;
}
extern "C" {
    #[doc = "\\brief Removes a node from a linked list.\n\nThe data pointer of the node will be lost after this, so make sure you don't need it anymore.\n\n\\param node The node you want to remove."]
    pub fn linkedlistRemove(node: *mut LinkedList);
}
extern "C" {
    pub fn __sassert(
        fileName: *const ::libc::c_char,
        lineNumber: ::libc::c_int,
        conditionString: *const ::libc::c_char,
        format: *const ::libc::c_char,
        ...
    );
}
extern "C" {
    pub static mut mosaicShadow: u16_;
}
extern "C" {
    pub static mut mosaicShadowSub: u16_;
}
#[doc = "!< maps vram a to lcd."]
pub const VRAM_A_LCD: VRAM_A_TYPE = 0;
#[doc = "!< maps vram a to main engine background slot 0."]
pub const VRAM_A_MAIN_BG: VRAM_A_TYPE = 1;
#[doc = "!< maps vram a to main engine background slot 0."]
pub const VRAM_A_MAIN_BG_0x06000000: VRAM_A_TYPE = 1;
#[doc = "!< maps vram a to main engine background slot 1."]
pub const VRAM_A_MAIN_BG_0x06020000: VRAM_A_TYPE = 9;
#[doc = "!< maps vram a to main engine background slot 2."]
pub const VRAM_A_MAIN_BG_0x06040000: VRAM_A_TYPE = 17;
#[doc = "!< maps vram a to main engine background slot 3."]
pub const VRAM_A_MAIN_BG_0x06060000: VRAM_A_TYPE = 25;
#[doc = "!< maps vram a to main engine sprites slot 0."]
pub const VRAM_A_MAIN_SPRITE: VRAM_A_TYPE = 2;
#[doc = "!< maps vram a to main engine sprites slot 0."]
pub const VRAM_A_MAIN_SPRITE_0x06400000: VRAM_A_TYPE = 2;
#[doc = "!< maps vram a to main engine sprites slot 1."]
pub const VRAM_A_MAIN_SPRITE_0x06420000: VRAM_A_TYPE = 10;
#[doc = "!< maps vram a to 3d texture slot 0."]
pub const VRAM_A_TEXTURE: VRAM_A_TYPE = 3;
#[doc = "!< maps vram a to 3d texture slot 0."]
pub const VRAM_A_TEXTURE_SLOT0: VRAM_A_TYPE = 3;
#[doc = "!< maps vram a to 3d texture slot 1."]
pub const VRAM_A_TEXTURE_SLOT1: VRAM_A_TYPE = 11;
#[doc = "!< maps vram a to 3d texture slot 2."]
pub const VRAM_A_TEXTURE_SLOT2: VRAM_A_TYPE = 19;
#[doc = "!< maps vram a to 3d texture slot 3."]
pub const VRAM_A_TEXTURE_SLOT3: VRAM_A_TYPE = 27;
#[doc = "! Allowed VRAM bank A modes"]
pub type VRAM_A_TYPE = ::libc::c_uint;
#[doc = "!< maps vram b to lcd."]
pub const VRAM_B_LCD: VRAM_B_TYPE = 0;
#[doc = "!< maps vram b to main engine background slot 1."]
pub const VRAM_B_MAIN_BG: VRAM_B_TYPE = 9;
#[doc = "!< maps vram b to main engine background slot 0."]
pub const VRAM_B_MAIN_BG_0x06000000: VRAM_B_TYPE = 1;
#[doc = "!< maps vram b to main engine background slot 1."]
pub const VRAM_B_MAIN_BG_0x06020000: VRAM_B_TYPE = 9;
#[doc = "!< maps vram b to main engine background slot 2."]
pub const VRAM_B_MAIN_BG_0x06040000: VRAM_B_TYPE = 17;
#[doc = "!< maps vram b to main engine background slot 3."]
pub const VRAM_B_MAIN_BG_0x06060000: VRAM_B_TYPE = 25;
#[doc = "!< maps vram b to main engine sprites slot 0."]
pub const VRAM_B_MAIN_SPRITE: VRAM_B_TYPE = 2;
#[doc = "!< maps vram b to main engine sprites slot 0."]
pub const VRAM_B_MAIN_SPRITE_0x06400000: VRAM_B_TYPE = 2;
#[doc = "!< maps vram b to main engine sprites slot 1."]
pub const VRAM_B_MAIN_SPRITE_0x06420000: VRAM_B_TYPE = 10;
#[doc = "!< maps vram b to 3d texture slot 1."]
pub const VRAM_B_TEXTURE: VRAM_B_TYPE = 11;
#[doc = "!< maps vram b to 3d texture slot 0."]
pub const VRAM_B_TEXTURE_SLOT0: VRAM_B_TYPE = 3;
#[doc = "!< maps vram b to 3d texture slot 1."]
pub const VRAM_B_TEXTURE_SLOT1: VRAM_B_TYPE = 11;
#[doc = "!< maps vram b to 3d texture slot 2."]
pub const VRAM_B_TEXTURE_SLOT2: VRAM_B_TYPE = 19;
#[doc = "!< maps vram b to 3d texture slot 3."]
pub const VRAM_B_TEXTURE_SLOT3: VRAM_B_TYPE = 27;
#[doc = "! Allowed VRAM bank B modes"]
pub type VRAM_B_TYPE = ::libc::c_uint;
#[doc = "!< maps vram c to lcd."]
pub const VRAM_C_LCD: VRAM_C_TYPE = 0;
#[doc = "!< maps vram c to main engine background slot 2."]
pub const VRAM_C_MAIN_BG: VRAM_C_TYPE = 17;
#[doc = "!< maps vram c to main engine background slot 0."]
pub const VRAM_C_MAIN_BG_0x06000000: VRAM_C_TYPE = 1;
#[doc = "!< maps vram c to main engine background slot 1."]
pub const VRAM_C_MAIN_BG_0x06020000: VRAM_C_TYPE = 9;
#[doc = "!< maps vram c to main engine background slot 2."]
pub const VRAM_C_MAIN_BG_0x06040000: VRAM_C_TYPE = 17;
#[doc = "!< maps vram c to main engine background slot 3."]
pub const VRAM_C_MAIN_BG_0x06060000: VRAM_C_TYPE = 25;
#[doc = "!< maps vram c to ARM7 workram slot 0."]
pub const VRAM_C_ARM7: VRAM_C_TYPE = 2;
#[doc = "!< maps vram c to ARM7 workram slot 0."]
pub const VRAM_C_ARM7_0x06000000: VRAM_C_TYPE = 2;
#[doc = "!< maps vram c to ARM7 workram slot 1."]
pub const VRAM_C_ARM7_0x06020000: VRAM_C_TYPE = 10;
#[doc = "!< maps vram c to sub engine background slot 0."]
pub const VRAM_C_SUB_BG: VRAM_C_TYPE = 4;
#[doc = "!< maps vram c to sub engine background slot 0."]
pub const VRAM_C_SUB_BG_0x06200000: VRAM_C_TYPE = 4;
#[doc = "!< maps vram c to 3d texture slot 2."]
pub const VRAM_C_TEXTURE: VRAM_C_TYPE = 19;
#[doc = "!< maps vram c to 3d texture slot 0."]
pub const VRAM_C_TEXTURE_SLOT0: VRAM_C_TYPE = 3;
#[doc = "!< maps vram c to 3d texture slot 1."]
pub const VRAM_C_TEXTURE_SLOT1: VRAM_C_TYPE = 11;
#[doc = "!< maps vram c to 3d texture slot 2."]
pub const VRAM_C_TEXTURE_SLOT2: VRAM_C_TYPE = 19;
#[doc = "!< maps vram c to 3d texture slot 3."]
pub const VRAM_C_TEXTURE_SLOT3: VRAM_C_TYPE = 27;
#[doc = "! Allowed VRAM bank C modes"]
pub type VRAM_C_TYPE = ::libc::c_uint;
#[doc = "!< maps vram d to lcd."]
pub const VRAM_D_LCD: VRAM_D_TYPE = 0;
#[doc = "!< maps vram d to main engine background slot 3."]
pub const VRAM_D_MAIN_BG: VRAM_D_TYPE = 25;
#[doc = "!< maps vram d to main engine background slot 0."]
pub const VRAM_D_MAIN_BG_0x06000000: VRAM_D_TYPE = 1;
#[doc = "!< maps vram d to main engine background slot 1."]
pub const VRAM_D_MAIN_BG_0x06020000: VRAM_D_TYPE = 9;
#[doc = "!< maps vram d to main engine background slot 2."]
pub const VRAM_D_MAIN_BG_0x06040000: VRAM_D_TYPE = 17;
#[doc = "!< maps vram d to main engine background slot 3."]
pub const VRAM_D_MAIN_BG_0x06060000: VRAM_D_TYPE = 25;
#[doc = "!< maps vram d to ARM7 workram slot 1."]
pub const VRAM_D_ARM7: VRAM_D_TYPE = 10;
#[doc = "!< maps vram d to ARM7 workram slot 0."]
pub const VRAM_D_ARM7_0x06000000: VRAM_D_TYPE = 2;
#[doc = "!< maps vram d to ARM7 workram slot 1."]
pub const VRAM_D_ARM7_0x06020000: VRAM_D_TYPE = 10;
#[doc = "!< maps vram d to sub engine sprites slot 0."]
pub const VRAM_D_SUB_SPRITE: VRAM_D_TYPE = 4;
#[doc = "!< maps vram d to 3d texture slot 3."]
pub const VRAM_D_TEXTURE: VRAM_D_TYPE = 27;
#[doc = "!< maps vram d to 3d texture slot 0."]
pub const VRAM_D_TEXTURE_SLOT0: VRAM_D_TYPE = 3;
#[doc = "!< maps vram d to 3d texture slot 1."]
pub const VRAM_D_TEXTURE_SLOT1: VRAM_D_TYPE = 11;
#[doc = "!< maps vram d to 3d texture slot 2."]
pub const VRAM_D_TEXTURE_SLOT2: VRAM_D_TYPE = 19;
#[doc = "!< maps vram d to 3d texture slot 3."]
pub const VRAM_D_TEXTURE_SLOT3: VRAM_D_TYPE = 27;
#[doc = "! Allowed VRAM bank D modes"]
pub type VRAM_D_TYPE = ::libc::c_uint;
#[doc = "!< maps vram e to lcd."]
pub const VRAM_E_LCD: VRAM_E_TYPE = 0;
#[doc = "!< maps vram e to main engine background first half of slot 0."]
pub const VRAM_E_MAIN_BG: VRAM_E_TYPE = 1;
#[doc = "!< maps vram e to main engine sprites first half of slot 0."]
pub const VRAM_E_MAIN_SPRITE: VRAM_E_TYPE = 2;
#[doc = "!< maps vram e to 3d texture palette slot 0-3."]
pub const VRAM_E_TEX_PALETTE: VRAM_E_TYPE = 3;
#[doc = "!< maps vram e to main engine background extended palette."]
pub const VRAM_E_BG_EXT_PALETTE: VRAM_E_TYPE = 4;
#[doc = "! Allowed VRAM bank E modes"]
pub type VRAM_E_TYPE = ::libc::c_uint;
#[doc = "!< maps vram f to lcd."]
pub const VRAM_F_LCD: VRAM_F_TYPE = 0;
#[doc = "!< maps vram f to main engine background first part of slot 0."]
pub const VRAM_F_MAIN_BG: VRAM_F_TYPE = 1;
#[doc = "!< maps vram f to main engine background first part of slot 0."]
pub const VRAM_F_MAIN_BG_0x06000000: VRAM_F_TYPE = 1;
#[doc = "!< maps vram f to main engine background second part of slot 0."]
pub const VRAM_F_MAIN_BG_0x06004000: VRAM_F_TYPE = 9;
#[doc = "!< maps vram f to main engine background second half of slot 0."]
pub const VRAM_F_MAIN_BG_0x06010000: VRAM_F_TYPE = 17;
#[doc = "!< maps vram f to main engine background second part of second half of slot 0."]
pub const VRAM_F_MAIN_BG_0x06014000: VRAM_F_TYPE = 25;
#[doc = "!< maps vram f to main engine sprites first part of slot 0."]
pub const VRAM_F_MAIN_SPRITE: VRAM_F_TYPE = 2;
#[doc = "!< maps vram f to main engine sprites first part of slot 0."]
pub const VRAM_F_MAIN_SPRITE_0x06400000: VRAM_F_TYPE = 2;
#[doc = "!< maps vram f to main engine sprites second part of slot 0."]
pub const VRAM_F_MAIN_SPRITE_0x06404000: VRAM_F_TYPE = 10;
#[doc = "!< maps vram f to main engine sprites second half of slot 0."]
pub const VRAM_F_MAIN_SPRITE_0x06410000: VRAM_F_TYPE = 18;
#[doc = "!< maps vram f to main engine sprites second part of second half of slot 0."]
pub const VRAM_F_MAIN_SPRITE_0x06414000: VRAM_F_TYPE = 26;
#[doc = "!< maps vram f to 3d texture palette slot 0."]
pub const VRAM_F_TEX_PALETTE: VRAM_F_TYPE = 3;
#[doc = "!< maps vram f to 3d texture palette slot 0."]
pub const VRAM_F_TEX_PALETTE_SLOT0: VRAM_F_TYPE = 3;
#[doc = "!< maps vram f to 3d texture palette slot 1."]
pub const VRAM_F_TEX_PALETTE_SLOT1: VRAM_F_TYPE = 11;
#[doc = "!< maps vram f to 3d texture palette slot 4."]
pub const VRAM_F_TEX_PALETTE_SLOT4: VRAM_F_TYPE = 19;
#[doc = "!< maps vram f to 3d texture palette slot 5."]
pub const VRAM_F_TEX_PALETTE_SLOT5: VRAM_F_TYPE = 27;
#[doc = "!< maps vram f to main engine background extended palette slot 0 and 1."]
pub const VRAM_F_BG_EXT_PALETTE: VRAM_F_TYPE = 4;
#[doc = "!< maps vram f to main engine background extended palette slot 0 and 1."]
pub const VRAM_F_BG_EXT_PALETTE_SLOT01: VRAM_F_TYPE = 4;
#[doc = "!< maps vram f to main engine background extended palette slot 2 and 3."]
pub const VRAM_F_BG_EXT_PALETTE_SLOT23: VRAM_F_TYPE = 12;
#[doc = "!< maps vram f to main engine sprites extended palette."]
pub const VRAM_F_SPRITE_EXT_PALETTE: VRAM_F_TYPE = 5;
#[doc = "! Allowed VRAM bank F modes"]
pub type VRAM_F_TYPE = ::libc::c_uint;
#[doc = "!< maps vram g to lcd."]
pub const VRAM_G_LCD: VRAM_G_TYPE = 0;
#[doc = "!< maps vram g to main engine background first part of slot 0."]
pub const VRAM_G_MAIN_BG: VRAM_G_TYPE = 1;
#[doc = "!< maps vram g to main engine background first part of slot 0."]
pub const VRAM_G_MAIN_BG_0x06000000: VRAM_G_TYPE = 1;
#[doc = "!< maps vram g to main engine background second part of slot 0."]
pub const VRAM_G_MAIN_BG_0x06004000: VRAM_G_TYPE = 9;
#[doc = "!< maps vram g to main engine background second half of slot 0."]
pub const VRAM_G_MAIN_BG_0x06010000: VRAM_G_TYPE = 17;
#[doc = "!< maps vram g to main engine background second part of second half of slot 0."]
pub const VRAM_G_MAIN_BG_0x06014000: VRAM_G_TYPE = 25;
#[doc = "!< maps vram g to main engine sprites first part of slot 0."]
pub const VRAM_G_MAIN_SPRITE: VRAM_G_TYPE = 2;
#[doc = "!< maps vram g to main engine sprites first part of slot 0."]
pub const VRAM_G_MAIN_SPRITE_0x06400000: VRAM_G_TYPE = 2;
#[doc = "!< maps vram g to main engine sprites second part of slot 0."]
pub const VRAM_G_MAIN_SPRITE_0x06404000: VRAM_G_TYPE = 10;
#[doc = "!< maps vram g to main engine sprites second half of slot 0."]
pub const VRAM_G_MAIN_SPRITE_0x06410000: VRAM_G_TYPE = 18;
#[doc = "!< maps vram g to main engine sprites second part of second half of slot 0."]
pub const VRAM_G_MAIN_SPRITE_0x06414000: VRAM_G_TYPE = 26;
#[doc = "!< maps vram g to 3d texture palette slot 0."]
pub const VRAM_G_TEX_PALETTE: VRAM_G_TYPE = 3;
#[doc = "!< maps vram g to 3d texture palette slot 0."]
pub const VRAM_G_TEX_PALETTE_SLOT0: VRAM_G_TYPE = 3;
#[doc = "!< maps vram g to 3d texture palette slot 1."]
pub const VRAM_G_TEX_PALETTE_SLOT1: VRAM_G_TYPE = 11;
#[doc = "!< maps vram g to 3d texture palette slot 4."]
pub const VRAM_G_TEX_PALETTE_SLOT4: VRAM_G_TYPE = 19;
#[doc = "!< maps vram g to 3d texture palette slot 5."]
pub const VRAM_G_TEX_PALETTE_SLOT5: VRAM_G_TYPE = 27;
#[doc = "!< maps vram g to main engine background extended palette slot 0 and 1."]
pub const VRAM_G_BG_EXT_PALETTE: VRAM_G_TYPE = 4;
#[doc = "!< maps vram g to main engine background extended palette slot 0 and 1."]
pub const VRAM_G_BG_EXT_PALETTE_SLOT01: VRAM_G_TYPE = 4;
#[doc = "!< maps vram g to main engine background extended palette slot 2 and 3."]
pub const VRAM_G_BG_EXT_PALETTE_SLOT23: VRAM_G_TYPE = 12;
#[doc = "!< maps vram g to main engine sprites extended palette."]
pub const VRAM_G_SPRITE_EXT_PALETTE: VRAM_G_TYPE = 5;
#[doc = "! Allowed VRAM bank G modes"]
pub type VRAM_G_TYPE = ::libc::c_uint;
#[doc = "!< maps vram h to lcd."]
pub const VRAM_H_LCD: VRAM_H_TYPE = 0;
#[doc = "!< maps vram h to sub engine background first 2 parts of slot 0."]
pub const VRAM_H_SUB_BG: VRAM_H_TYPE = 1;
#[doc = "!< maps vram h to sub engine background extended palette."]
pub const VRAM_H_SUB_BG_EXT_PALETTE: VRAM_H_TYPE = 2;
#[doc = "! Allowed VRAM bank H modes"]
pub type VRAM_H_TYPE = ::libc::c_uint;
#[doc = "!< maps vram i to lcd."]
pub const VRAM_I_LCD: VRAM_I_TYPE = 0;
#[doc = "!< maps vram i to sub engine background thirth part of slot 0."]
pub const VRAM_I_SUB_BG_0x06208000: VRAM_I_TYPE = 1;
#[doc = "!< maps vram i to sub engine sprites."]
pub const VRAM_I_SUB_SPRITE: VRAM_I_TYPE = 2;
#[doc = "!< maps vram i to sub engine sprites extended palette."]
pub const VRAM_I_SUB_SPRITE_EXT_PALETTE: VRAM_I_TYPE = 3;
#[doc = "! Allowed VRAM bank I modes"]
pub type VRAM_I_TYPE = ::libc::c_uint;
#[doc = " \\brief  an array of 256 15-bit RGB values"]
pub type _palette = [u16_; 256usize];
#[doc = " \\brief  An array of 16 256-color palettes"]
pub type _ext_palette = [_palette; 16usize];
extern "C" {
    #[doc = " \\brief  Set the main 4 bank modes.\n    \\param a mapping mode of VRAM_A\n    \\param b mapping mode of VRAM_B\n    \\param c mapping mode of VRAM_C\n    \\param d mapping mode of VRAM_D\n    \\return the previous mode"]
    pub fn vramSetPrimaryBanks(
        a: VRAM_A_TYPE,
        b: VRAM_B_TYPE,
        c: VRAM_C_TYPE,
        d: VRAM_D_TYPE,
    ) -> u32_;
}
extern "C" {
    pub fn vramSetMainBanks(a: VRAM_A_TYPE, b: VRAM_B_TYPE, c: VRAM_C_TYPE, d: VRAM_D_TYPE)
        -> u32_;
}
extern "C" {
    #[doc = " \\brief  Set E,F,G bank modes.\n    \\param e mapping mode of VRAM_E\n    \\param f mapping mode of VRAM_F\n    \\param g mapping mode of VRAM_G\n    \\return the previous mode"]
    pub fn vramSetBanks_EFG(e: VRAM_E_TYPE, f: VRAM_F_TYPE, g: VRAM_G_TYPE) -> u32_;
}
extern "C" {
    #[doc = " \\brief  Set VRAM banks to basic default.\n\\return the previous settings"]
    pub fn vramDefault() -> u32_;
}
extern "C" {
    #[doc = " \\brief  Restore the main 4 bank modes.\n\\param vramTemp restores the main 4 banks to the value encoded in vramTemp (returned from vramSetMainBanks)"]
    pub fn vramRestorePrimaryBanks(vramTemp: u32_);
}
extern "C" {
    pub fn vramRestoreMainBanks(vramTemp: u32_);
}
extern "C" {
    #[doc = " \\brief  Restore the E,F,G bank modes.\n\\param vramTemp restores the E,F,G bank modes to the value encoded in vramTemp (returned from vramSetBanks_EFG)"]
    pub fn vramRestoreBanks_EFG(vramTemp: u32_);
}
extern "C" {
    #[doc = " \\brief  Set bank A to the indicated mapping.\n\\param a the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankA__extern"]
    pub fn vramSetBankA(a: VRAM_A_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank B to the indicated mapping.\n\\param b the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankB__extern"]
    pub fn vramSetBankB(b: VRAM_B_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank C to the indicated mapping.\n\\param c the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankC__extern"]
    pub fn vramSetBankC(c: VRAM_C_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank D to the indicated mapping.\n\\param d the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankD__extern"]
    pub fn vramSetBankD(d: VRAM_D_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank E to the indicated mapping.\n\\param e the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankE__extern"]
    pub fn vramSetBankE(e: VRAM_E_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank F to the indicated mapping.\n\\param f the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankF__extern"]
    pub fn vramSetBankF(f: VRAM_F_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank G to the indicated mapping.\n\\param g the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankG__extern"]
    pub fn vramSetBankG(g: VRAM_G_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank H to the indicated mapping.\n\\param h the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankH__extern"]
    pub fn vramSetBankH(h: VRAM_H_TYPE);
}
extern "C" {
    #[doc = " \\brief  Set bank I to the indicated mapping.\n\\param i the mapping of the bank"]
    #[link_name = "\u{1}vramSetBankI__extern"]
    pub fn vramSetBankI(i: VRAM_I_TYPE);
}
#[doc = "< \\brief  4 2D backgrounds"]
pub const MODE_0_2D: VideoMode = 65536;
#[doc = "< \\brief  4 2D backgrounds"]
pub const MODE_1_2D: VideoMode = 65537;
#[doc = "< \\brief  4 2D backgrounds"]
pub const MODE_2_2D: VideoMode = 65538;
#[doc = "< \\brief  4 2D backgrounds"]
pub const MODE_3_2D: VideoMode = 65539;
#[doc = "< \\brief  4 2D backgrounds"]
pub const MODE_4_2D: VideoMode = 65540;
#[doc = "< \\brief  4 2D backgrounds"]
pub const MODE_5_2D: VideoMode = 65541;
#[doc = "< \\brief  4 2D backgrounds"]
pub const MODE_6_2D: VideoMode = 65542;
#[doc = "< \\brief  3 2D backgrounds 1 3D background (Main engine only)"]
pub const MODE_0_3D: VideoMode = 65800;
#[doc = "< \\brief  3 2D backgrounds 1 3D background (Main engine only)"]
pub const MODE_1_3D: VideoMode = 65801;
#[doc = "< \\brief  3 2D backgrounds 1 3D background (Main engine only)"]
pub const MODE_2_3D: VideoMode = 65802;
#[doc = "< \\brief  3 2D backgrounds 1 3D background (Main engine only)"]
pub const MODE_3_3D: VideoMode = 65803;
#[doc = "< \\brief  3 2D backgrounds 1 3D background (Main engine only)"]
pub const MODE_4_3D: VideoMode = 65804;
#[doc = "< \\brief  3 2D backgrounds 1 3D background (Main engine only)"]
pub const MODE_5_3D: VideoMode = 65805;
#[doc = "< \\brief  3 2D backgrounds 1 3D background (Main engine only)"]
pub const MODE_6_3D: VideoMode = 65806;
#[doc = "< \\brief  video display from main memory"]
pub const MODE_FIFO: VideoMode = 196608;
#[doc = "< \\brief  video display directly from VRAM_A in LCD mode"]
pub const MODE_FB0: VideoMode = 131072;
#[doc = "< \\brief  video display directly from VRAM_B in LCD mode"]
pub const MODE_FB1: VideoMode = 393216;
#[doc = "< \\brief  video display directly from VRAM_C in LCD mode"]
pub const MODE_FB2: VideoMode = 655360;
#[doc = "< \\brief  video display directly from VRAM_D in LCD mode"]
pub const MODE_FB3: VideoMode = 917504;
#[doc = " \\enum  VideoMode\n \\brief The allowed video modes of the 2D processors <br>\n\n<div class=\"fixedFont\"><pre>\nMain 2D engine\n______________________________\n|Mode | BG0 | BG1 | BG2 |BG3 |           T = Text\n|  0  |  T  |  T  |  T  |  T |           R = Rotation\n|  1  |  T  |  T  |  T  |  R |           E = Extended Rotation\n|  2  |  T  |  T  |  R  |  R |           L = Large Bitmap background\n|  3  |  T  |  T  |  T  |  E |\n|  4  |  T  |  T  |  R  |  E |\n|  5  |  T  |  T  |  E  |  E |\n|  6  |     |  L  |     |    |\n-----------------------------\n\nSub 2D engine\n______________________________\n|Mode | BG0 | BG1 | BG2 |BG3 |\n|  0  |  T  |  T  |  T  |  T |\n|  1  |  T  |  T  |  T  |  R |\n|  2  |  T  |  T  |  R  |  R |\n|  3  |  T  |  T  |  T  |  E |\n|  4  |  T  |  T  |  R  |  E |\n|  5  |  T  |  T  |  E  |  E |\n-----------------------------\n\n</pre></div>"]
pub type VideoMode = ::libc::c_uint;
extern "C" {
    #[doc = " \\brief  the main 2D engine video mode\n    \\param mode the video mode to set"]
    #[link_name = "\u{1}videoSetMode__extern"]
    pub fn videoSetMode(mode: u32_);
}
extern "C" {
    #[doc = " \\brief  the sub 2D engine video mode\n    \\param mode the video mode to set"]
    #[link_name = "\u{1}videoSetModeSub__extern"]
    pub fn videoSetModeSub(mode: u32_);
}
extern "C" {
    #[doc = " \\brief  return the main 2D engine video mode\n    \\return the video mode"]
    #[link_name = "\u{1}videoGetMode__extern"]
    pub fn videoGetMode() -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief  return the main 2D engine video mode\n    \\return the video mode"]
    #[link_name = "\u{1}videoGetModeSub__extern"]
    pub fn videoGetModeSub() -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief  determine if 3D is enabled\n    \\return true if 3D is enabled"]
    #[link_name = "\u{1}video3DEnabled__extern"]
    pub fn video3DEnabled() -> bool;
}
extern "C" {
    #[doc = " \\brief  enables the specified background on the main engine\n    \\param number the background number (0-3)"]
    #[link_name = "\u{1}videoBgEnable__extern"]
    pub fn videoBgEnable(number: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief  enables the specified background on the sub engine\n    \\param number the background number (0-3)"]
    #[link_name = "\u{1}videoBgEnableSub__extern"]
    pub fn videoBgEnableSub(number: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief  disables the specified background on the main engine\n    \\param number the background number (0-3)"]
    #[link_name = "\u{1}videoBgDisable__extern"]
    pub fn videoBgDisable(number: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief  disables the specified background on the sub engine\n    \\param number the background number (0-3)"]
    #[link_name = "\u{1}videoBgDisableSub__extern"]
    pub fn videoBgDisableSub(number: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief sets the screens brightness.\n\\param screen 1 = main screen, 2 = subscreen, 3 = both\n\\param level -16 = black, 0 = full brightness, 16 = white"]
    pub fn setBrightness(screen: ::libc::c_int, level: ::libc::c_int);
}
extern "C" {
    #[doc = "\\brief sets the backdrop color of the main engine.\n\nthe backdrop color is displayed when all pixels at a given location are transparent\n(no sprite or background is visible there).\n\n\\param color the color that the backdrop of the main engine should display."]
    #[link_name = "\u{1}setBackdropColor__extern"]
    pub fn setBackdropColor(color: u16_);
}
extern "C" {
    #[doc = "\\brief sets the backdrop color of the sub engine.\n\nthe backdrop color is displayed when all pixels at a given location are transparent\n(no sprite or background is visible there).\n\n\\param color the color that the backdrop of the sub engine should display."]
    #[link_name = "\u{1}setBackdropColorSub__extern"]
    pub fn setBackdropColorSub(color: u16_);
}
#[doc = "\t\\brief register overlay for scroll registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bg_scroll {
    #[doc = "< x scroll"]
    pub x: u16_,
    #[doc = "< y scroll"]
    pub y: u16_,
}
#[doc = "\t\\brief register overlay for affine matrix registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bg_transform {
    #[doc = "!< The change in x per horizontal pixel."]
    pub hdx: s16,
    #[doc = "!< The change in x per vertical pixel."]
    pub vdx: s16,
    #[doc = "!< The change in y per horizontal pixel."]
    pub hdy: s16,
    #[doc = "!< The change in x per vertical pixel."]
    pub vdy: s16,
    #[doc = "!< map x value which corresponds to the screen origin"]
    pub dx: s32,
    #[doc = "!< map y value which corresponds to the screen origin"]
    pub dy: s32,
}
#[doc = "\t\\brief register overlay for background attribute registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bg_attribute {
    #[doc = "< Background control registers"]
    pub control: [u16_; 4usize],
    #[doc = "< Background scroll registers"]
    pub scroll: [bg_scroll; 4usize],
    #[doc = "< Background 2 affine matrix"]
    pub bg2_rotation: bg_transform,
    #[doc = "< Background 3 affine matrix"]
    pub bg3_rotation: bg_transform,
}
#[doc = " \\brief Overlay for 8-bit tile map entries"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TileMapEntry8 {
    pub index: u8_,
}
#[doc = " \\brief Overlay for 16-bit tile map entries"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TileMapEntry16 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl TileMapEntry16 {
    #[inline]
    pub fn index(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_index(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn hflip(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hflip(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vflip(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_vflip(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn palette(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_palette(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        index: u16_,
        hflip: u16_,
        vflip: u16_,
        palette: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let index: u16 = unsafe { ::core::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hflip: u16 = unsafe { ::core::mem::transmute(hflip) };
            hflip as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let vflip: u16 = unsafe { ::core::mem::transmute(vflip) };
            vflip as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let palette: u16 = unsafe { ::core::mem::transmute(palette) };
            palette as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< \\brief 32 x 32 tile text background"]
pub const BG_32x32: BackgroundControl = 0;
#[doc = "< \\brief 64 x 32 tile text background"]
pub const BG_64x32: BackgroundControl = 16384;
#[doc = "< \\brief 32 x 64 tile text background"]
pub const BG_32x64: BackgroundControl = 32768;
#[doc = "< \\brief 64 x 64 tile text background"]
pub const BG_64x64: BackgroundControl = 49152;
#[doc = "< \\brief 16 x 16 tile affine (rotation & scale) background"]
pub const BG_RS_16x16: BackgroundControl = 0;
#[doc = "< \\brief 32 x 32 tile affine (rotation & scale) background"]
pub const BG_RS_32x32: BackgroundControl = 16384;
#[doc = "< \\brief 64 x 64 tile affine (rotation & scale) background"]
pub const BG_RS_64x64: BackgroundControl = 32768;
#[doc = "< \\brief 128 x 128 tile affine (rotation & scale) background"]
pub const BG_RS_128x128: BackgroundControl = 49152;
#[doc = "< \\brief 128x128 pixel 8-bit bitmapped background"]
pub const BG_BMP8_128x128: BackgroundControl = 128;
#[doc = "< \\brief 256x256 pixel 8-bit bitmapped background"]
pub const BG_BMP8_256x256: BackgroundControl = 16512;
#[doc = "< \\brief 512x256 pixel 8-bit bitmapped background"]
pub const BG_BMP8_512x256: BackgroundControl = 32896;
#[doc = "< \\brief 512 pixel 8-bit bitmapped background"]
pub const BG_BMP8_512x512: BackgroundControl = 49280;
#[doc = "< \\brief 1024x512 pixel 8-bit Large bitmapped background (Mode 6 of main engine only)"]
pub const BG_BMP8_1024x512: BackgroundControl = 16384;
#[doc = "< \\brief 512x1024 pixel 8-bit Large bitmapped background (Mode 6 of main engine only)"]
pub const BG_BMP8_512x1024: BackgroundControl = 0;
#[doc = "< \\brief 128x128 pixel 16-bit bitmapped background"]
pub const BG_BMP16_128x128: BackgroundControl = 132;
#[doc = "< \\brief 256x256 pixel 16-bit bitmapped background"]
pub const BG_BMP16_256x256: BackgroundControl = 16516;
#[doc = "< \\brief 512x256 pixel 16-bit bitmapped background"]
pub const BG_BMP16_512x256: BackgroundControl = 32900;
#[doc = "< \\brief 512x512 pixel 16-bit bitmapped background"]
pub const BG_BMP16_512x512: BackgroundControl = 49284;
#[doc = "< \\brief mosaic enable"]
pub const BG_MOSAIC_ON: BackgroundControl = 64;
#[doc = "< \\brief mosaic disable"]
pub const BG_MOSAIC_OFF: BackgroundControl = 0;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_0: BackgroundControl = 0;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_1: BackgroundControl = 1;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_2: BackgroundControl = 2;
#[doc = "< \\brief Lower priority will be rendered on top"]
pub const BG_PRIORITY_3: BackgroundControl = 3;
#[doc = "< \\brief Disable wrapping (no effect on text backgrounds...always wrapped)"]
pub const BG_WRAP_OFF: BackgroundControl = 0;
#[doc = "< \\brief Enable wrapping (no effect on text backgrounds...always wrapped)"]
pub const BG_WRAP_ON: BackgroundControl = 8192;
#[doc = "< \\brief Use slot 0 of extended palettes"]
pub const BG_PALETTE_SLOT0: BackgroundControl = 0;
#[doc = "< \\brief Use slot 1 of extended palettes"]
pub const BG_PALETTE_SLOT1: BackgroundControl = 0;
#[doc = "< \\brief Use slot 2 of extended palettes"]
pub const BG_PALETTE_SLOT2: BackgroundControl = 8192;
#[doc = "< \\brief Use slot 3 of extended palettes"]
pub const BG_PALETTE_SLOT3: BackgroundControl = 8192;
#[doc = "< \\brief 256 color text background"]
pub const BG_COLOR_256: BackgroundControl = 128;
#[doc = "< \\brief 16x16 color text background"]
pub const BG_COLOR_16: BackgroundControl = 0;
#[doc = "\t\\brief Bit defines for the background control registers"]
pub type BackgroundControl = ::libc::c_uint;
#[doc = " \\defgroup background_api_group \"Background API Access\"\n@{"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BgState {
    pub angle: ::libc::c_int,
    pub centerX: s32,
    pub centerY: s32,
    pub scaleX: s32,
    pub scaleY: s32,
    pub scrollX: s32,
    pub scrollY: s32,
    pub size: ::libc::c_int,
    pub type_: ::libc::c_int,
    pub dirty: bool,
}
extern "C" {
    pub static mut bgControl: [*mut vuint16; 8usize];
}
extern "C" {
    pub static mut bgScrollTable: [*mut bg_scroll; 8usize];
}
extern "C" {
    pub static mut bgTransform: [*mut bg_transform; 8usize];
}
extern "C" {
    pub static mut bgState: [BgState; 8usize];
}
#[doc = "!< 8bpp Tiled background with 16 bit tile indexes and no allowed rotation or scaling"]
pub const BgType_Text8bpp: BgType = 0;
#[doc = "!< 4bpp Tiled background with 16 bit tile indexes and no allowed rotation or scaling"]
pub const BgType_Text4bpp: BgType = 1;
#[doc = "!< Tiled background with 8 bit tile indexes Can be scaled and rotated"]
pub const BgType_Rotation: BgType = 2;
#[doc = "!< Tiled background with 16 bit tile indexes Can be scaled and rotated"]
pub const BgType_ExRotation: BgType = 3;
#[doc = "!< Bitmap background with 8 bit color values which index into a 256 color palette"]
pub const BgType_Bmp8: BgType = 4;
#[doc = "!< Bitmap background with 16 bit color values of the form aBBBBBGGGGGRRRRR (if 'a' is set the pixel will be rendered...if not the pixel will be transparent)"]
pub const BgType_Bmp16: BgType = 5;
#[doc = "! Allowed background types, used in bgInit and bgInitSub."]
pub type BgType = ::libc::c_uint;
#[doc = "< 128 x 128 pixel rotation background"]
pub const BgSize_R_128x128: BgSize = 0;
#[doc = "< 256 x 256 pixel rotation background"]
pub const BgSize_R_256x256: BgSize = 16384;
#[doc = "< 512 x 512 pixel rotation background"]
pub const BgSize_R_512x512: BgSize = 32768;
#[doc = "< 1024 x 1024 pixel rotation background"]
pub const BgSize_R_1024x1024: BgSize = 49152;
#[doc = "< 256 x 256 pixel text background"]
pub const BgSize_T_256x256: BgSize = 65536;
#[doc = "< 512 x 256 pixel text background"]
pub const BgSize_T_512x256: BgSize = 81920;
#[doc = "< 256 x 512 pixel text background"]
pub const BgSize_T_256x512: BgSize = 98304;
#[doc = "< 512 x 512 pixel text background"]
pub const BgSize_T_512x512: BgSize = 114688;
#[doc = "< 128 x 128 pixel extended rotation background"]
pub const BgSize_ER_128x128: BgSize = 131072;
#[doc = "< 256 x 256 pixel extended rotation background"]
pub const BgSize_ER_256x256: BgSize = 147456;
#[doc = "< 512 x 512 pixel extended rotation background"]
pub const BgSize_ER_512x512: BgSize = 163840;
#[doc = "< 1024 x 1024 extended pixel rotation background"]
pub const BgSize_ER_1024x1024: BgSize = 180224;
#[doc = "< 128 x 128 pixel 8 bit bitmap background"]
pub const BgSize_B8_128x128: BgSize = 196736;
#[doc = "< 256 x 256 pixel 8 bit bitmap background"]
pub const BgSize_B8_256x256: BgSize = 213120;
#[doc = "< 512 x 256 pixel 8 bit bitmap background"]
pub const BgSize_B8_512x256: BgSize = 229504;
#[doc = "< 512 x 512 pixel 8 bit bitmap background"]
pub const BgSize_B8_512x512: BgSize = 245888;
#[doc = "< 1024 x 512 pixel 8 bit bitmap background"]
pub const BgSize_B8_1024x512: BgSize = 212992;
#[doc = "< 512 x 1024 pixel 8 bit bitmap background"]
pub const BgSize_B8_512x1024: BgSize = 196608;
#[doc = "< 128 x 128 pixel 16 bit bitmap background"]
pub const BgSize_B16_128x128: BgSize = 262276;
#[doc = "< 256 x 256 pixel 16 bit bitmap background"]
pub const BgSize_B16_256x256: BgSize = 278660;
#[doc = "< 512 x 512 pixel 16 bit bitmap background"]
pub const BgSize_B16_512x256: BgSize = 295044;
#[doc = "< 1024 x 1024 pixel 16 bit bitmap background"]
pub const BgSize_B16_512x512: BgSize = 311428;
#[doc = " \\brief Allowed background Sizes\n The lower 16 bits of these defines can be used directly to set the background control register bits\n \\ingroup api_group"]
pub type BgSize = ::libc::c_uint;
extern "C" {
    pub fn bgIsText(id: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn bgInit_call(
        layer: ::libc::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::libc::c_int,
        tileBase: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bgInitSub_call(
        layer: ::libc::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::libc::c_int,
        tileBase: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Must be called once per frame to update scroll/scale/and rotation of backgrounds."]
    pub fn bgUpdate();
}
extern "C" {
    #[doc = "\t\\brief Sets the rotation angle of the specified background and updates the transform matrix.\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param angle\nthe angle of counter clockwise rotation (0 to 511)"]
    #[link_name = "\u{1}bgSetRotate__extern"]
    pub fn bgSetRotate(id: ::libc::c_int, angle: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief Rotates the background counter clockwise by the specified angle. (this rotation is cumulative)\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param angle\nthe angle of counter clockwise rotation (-32768 to 32767)"]
    #[link_name = "\u{1}bgRotate__extern"]
    pub fn bgRotate(id: ::libc::c_int, angle: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Sets the rotation and scale of the background and update background control registers\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param angle\nthe angle of counter clockwise rotation (-32768 to 32767)\n\\param sx\nthe 24.8 bit fractional fixed point inverse horizontal scaling to apply\n\\param sy\nthe 24.8 bit fractional fixed point inverse vertical scaling to apply\n\\param scrollX\nthe 24.8 bit fractional fixed point horizontal scroll to apply\n\\param scrollY\nthe 24.8 bit fractional fixed point vertical scroll to apply\n\\param rotCenterX\nthe 24.8 bit fractional fixed point center of rotation x component\n\\param rotCenterY\nthe 24.8 bit fractional fixed point center of rotation y component"]
    #[link_name = "\u{1}bgSet__extern"]
    pub fn bgSet(
        id: ::libc::c_int,
        angle: ::libc::c_int,
        sx: s32,
        sy: s32,
        scrollX: s32,
        scrollY: s32,
        rotCenterX: s32,
        rotCenterY: s32,
    );
}
extern "C" {
    #[doc = "\t\\brief Sets the rotation and scale of the background and update background control registers\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param angle\nthe angle of counter clockwise rotation (-32768 to 32767)\n\\param sx\nthe 24.8 bit fractional fixed point horizontal scaling to apply\n\\param sy\nthe 24.8 bit fractional fixed point vertical scaling to apply"]
    #[link_name = "\u{1}bgSetRotateScale__extern"]
    pub fn bgSetRotateScale(id: ::libc::c_int, angle: ::libc::c_int, sx: s32, sy: s32);
}
extern "C" {
    #[doc = "\t\\brief Sets the scale of the specified background\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param sx\nthe 24.8 bit fractional fixed point horizontal scaling to apply\n\\param sy\nthe 24.8 bit fractional fixed point vertical scaling to apply"]
    #[link_name = "\u{1}bgSetScale__extern"]
    pub fn bgSetScale(id: ::libc::c_int, sx: s32, sy: s32);
}
extern "C" {
    #[doc = "\t\\brief Initializes a background on the main display\nSets up background control register with specified settings and defaults to 256 color mode\nfor tiled backgrounds.\nSets the rotation/scale attributes for rot/ex rot backgrounds to 1:1 scale and 0 angle of rotation.\n\\param layer\nbackground hardware layer to init.  Must be 0 - 3\n\\param type\nthe type of background to init\n\\param size\nthe size of the background\n\\param mapBase\nthe 2k offset into vram the tile map will be placed\n<br>--OR--<br>\nthe 16k offset into vram the bitmap data will be placed for bitmap backgrounds\n\\param tileBase\nthe 16k offset into vram the tile graphics data will be placed\n\\return\nthe background id to be used in the supporting functions\n\\note\ntileBase is unused for bitmap backgrounds"]
    #[link_name = "\u{1}bgInit__extern"]
    pub fn bgInit(
        layer: ::libc::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::libc::c_int,
        tileBase: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Initializes a background on the sub display\nSets up background control register with specified settings and defaults to 256 color mode\nfor tiled backgrounds.\nSets the rotation/scale attributes for rot/ex rot backgrounds to 1:1 scale and 0 angle of rotation.\n\\param layer\nbackground hardware layer to init.  Must be 0 - 3\n\\param type\nthe type of background to init\n\\param size\nthe size of the background\n\\param mapBase\nthe 2k offset into vram the tile map will be placed\n<br>--OR--<br>\nthe 16k offset into vram the bitmap data will be placed for bitmap backgrounds\n\\param tileBase\nthe 16k offset into vram the tile graphics data will be placed\n\\return\nthe background id to be used in the supporting functions\n\\note\ntileBase is unused for bitmap backgrounds"]
    #[link_name = "\u{1}bgInitSub__extern"]
    pub fn bgInitSub(
        layer: ::libc::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::libc::c_int,
        tileBase: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief allows direct access to background control for the chosen layer, returns a pointer\nto the current control bits\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param bits\nsets the specified bits to set in the backgrounds control register\n\\return\na pointer to the appropriate background control register"]
    #[link_name = "\u{1}bgSetControlBits__extern"]
    pub fn bgSetControlBits(id: ::libc::c_int, bits: u16_) -> *mut vuint16;
}
extern "C" {
    #[doc = "\t\\brief Clears the specified bits from the backgrounds control register\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param bits\nsets the specified bits to clear in the backgrounds control register"]
    #[link_name = "\u{1}bgClearControlBits__extern"]
    pub fn bgClearControlBits(id: ::libc::c_int, bits: u16_);
}
extern "C" {
    #[doc = "\t\\brief turns wrap on for a background.\nhas no effect on text backgrounds, which are always wrapped.\n\\param id background id returned from bgInit or bgInitSub"]
    #[link_name = "\u{1}bgWrapOn__extern"]
    pub fn bgWrapOn(id: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief turns wrap off for a background.\nhas no effect on text backgrounds, which are always wrapped.\n\\param id background id returned from bgInit or bgInitSub"]
    #[link_name = "\u{1}bgWrapOff__extern"]
    pub fn bgWrapOff(id: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Sets the background priority\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param priority\nbackground priority (0-3), higher level priority will result\nin background rendering on top of lower level"]
    #[link_name = "\u{1}bgSetPriority__extern"]
    pub fn bgSetPriority(id: ::libc::c_int, priority: ::libc::c_uint);
}
extern "C" {
    #[doc = "\t\\brief Sets the background map base\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param base\nthe 2k offset into vram for the backgrounds tile map or the\n16k offset for bitmap graphics"]
    #[link_name = "\u{1}bgSetMapBase__extern"]
    pub fn bgSetMapBase(id: ::libc::c_int, base: ::libc::c_uint);
}
extern "C" {
    #[doc = "\t\\brief Sets the background map base\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param base\nthe 16k offset into vram for the backgrounds tile map\nignored for bitmap graphics"]
    #[link_name = "\u{1}bgSetTileBase__extern"]
    pub fn bgSetTileBase(id: ::libc::c_int, base: ::libc::c_uint);
}
extern "C" {
    #[doc = "\t\\brief Sets the scroll hardware to the specified location (fixed point)\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param x\nthe 8 bits fractional fixed point horizontal scroll\n\\param y\nthe 8 bits fractional fixed point vertical scroll\n\\note\nwhile valid for text backgrounds the fractional part will be ignored"]
    #[link_name = "\u{1}bgSetScrollf__extern"]
    pub fn bgSetScrollf(id: ::libc::c_int, x: s32, y: s32);
}
extern "C" {
    #[doc = "\t\\brief Sets the scroll hardware to the specified location\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param x\nthe horizontal scroll\n\\param y\nthe vertical scroll"]
    #[link_name = "\u{1}bgSetScroll__extern"]
    pub fn bgSetScroll(id: ::libc::c_int, x: ::libc::c_int, y: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Enables mosaic on the specified background\n\\param id background id returned from bgInit or bgInitSub"]
    #[link_name = "\u{1}bgMosaicEnable__extern"]
    pub fn bgMosaicEnable(id: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Disables mosaic on the specified background\n\\param id background id returned from bgInit or bgInitSub"]
    #[link_name = "\u{1}bgMosaicDisable__extern"]
    pub fn bgMosaicDisable(id: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Sets the horizontal and vertical mosaic values for all backgrounds\n\\param dx horizontal mosaic value (between 0 and 15)\n\\param dy vertical mosaic value (between 0 and 15)"]
    #[link_name = "\u{1}bgSetMosaic__extern"]
    pub fn bgSetMosaic(dx: ::libc::c_uint, dy: ::libc::c_uint);
}
extern "C" {
    #[doc = "\t\\brief Sets the horizontal and vertical mosaic values for all backgrounds (Sub Display)\n\\param dx horizontal mosaic value (between 0 and 15)\n\\param dy vertical mosaic value (between 0 and 15)"]
    #[link_name = "\u{1}bgSetMosaicSub__extern"]
    pub fn bgSetMosaicSub(dx: ::libc::c_uint, dy: ::libc::c_uint);
}
extern "C" {
    #[doc = "\t\\brief Gets the background priority\n\\param id background id returned from bgInit or bgInitSub\n\\return background priority"]
    #[link_name = "\u{1}bgGetPriority__extern"]
    pub fn bgGetPriority(id: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Gets the current map base for the supplied background\n\\param id background id returned from bgInit or bgInitSub\n\\return background map base\n\\note this is the integer offset of the base not a pointer to the map"]
    #[link_name = "\u{1}bgGetMapBase__extern"]
    pub fn bgGetMapBase(id: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Gets the background tile base\n\\param id background id returned from bgInit or bgInitSub\n\\return background tile base"]
    #[link_name = "\u{1}bgGetTileBase__extern"]
    pub fn bgGetTileBase(id: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Gets a pointer to the background map\n\\param id background id returned from bgInit or bgInitSub\n\\return A pointer to the map"]
    #[link_name = "\u{1}bgGetMapPtr__extern"]
    pub fn bgGetMapPtr(id: ::libc::c_int) -> *mut u16_;
}
extern "C" {
    #[doc = "\t\\brief Gets a pointer to the background graphics\n\\param id background id returned from bgInit or bgInitSub\n\\return A pointer to the tile graphics or bitmap graphics"]
    #[link_name = "\u{1}bgGetGfxPtr__extern"]
    pub fn bgGetGfxPtr(id: ::libc::c_int) -> *mut u16_;
}
extern "C" {
    #[doc = "\t\\brief Scrolls the background by the specified relative values (fixed point)\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param dx\nthe 8 bits fractional fixed point horizontal scroll\n\\param dy\nthe 8 bits fractional fixed point vertical scroll\n\\note\nwhile valid for text backgrounds the fractional part will be ignored"]
    #[link_name = "\u{1}bgScrollf__extern"]
    pub fn bgScrollf(id: ::libc::c_int, dx: s32, dy: s32);
}
extern "C" {
    #[doc = "\t\\brief Scrolls the background by the specified relative values\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param dx\nhorizontal scroll\n\\param dy\nvertical scroll\n\\note\nwhile valid for text backgrounds the fractional part will be ignored"]
    #[link_name = "\u{1}bgScroll__extern"]
    pub fn bgScroll(id: ::libc::c_int, dx: ::libc::c_int, dy: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Shows the current background via the display control register\n\\param id\nbackground id returned from bgInit or bgInitSub"]
    #[link_name = "\u{1}bgShow__extern"]
    pub fn bgShow(id: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Hides the current background via the display control register\n\\param id\nbackground id returned from bgInit or bgInitSub"]
    #[link_name = "\u{1}bgHide__extern"]
    pub fn bgHide(id: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Sets the center of rotation for the supplied background (fixed point)\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param x\nthe 8 bits fractional center x\n\\param y\nthe 8 bits fractional center y\n\\note\nwhile valid for text backgrounds the fractional part will be ignored"]
    #[link_name = "\u{1}bgSetCenterf__extern"]
    pub fn bgSetCenterf(id: ::libc::c_int, x: s32, y: s32);
}
extern "C" {
    #[doc = "\t\\brief Sets the center of rotation for the supplied background\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param x\ncenter x\n\\param y\ncenter y"]
    #[link_name = "\u{1}bgSetCenter__extern"]
    pub fn bgSetCenter(id: ::libc::c_int, x: ::libc::c_int, y: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief directly sets the affine matrix and scroll registers of a background.\n\nWith this, you have more freedom to set the matrix, but it might be more difficult to use if\nyou're not used to affine transformation matrix.\nThis will ignore (but not erase) any values set using the bg rotating, scaling or center functions.\n\n\\param id\t\tThe id returned by bgInit or bgInitSub.\n\\param hdx\t\tThe change in x per horizontal pixel.\n\\param vdx\t\tThe change in x per vertical pixel.\n\\param hdy\t\tThe change in y per horizontal pixel.\n\\param vdy\t\tThe change in y per vertical pixel.\n\\param scrollx\tThe horizontal scroll/offset value of the background.\n\\param scrolly\tThe vertical scroll/offset value of the background."]
    #[link_name = "\u{1}bgSetAffineMatrixScroll__extern"]
    pub fn bgSetAffineMatrixScroll(
        id: ::libc::c_int,
        hdx: ::libc::c_int,
        vdx: ::libc::c_int,
        hdy: ::libc::c_int,
        vdy: ::libc::c_int,
        scrollx: ::libc::c_int,
        scrolly: ::libc::c_int,
    );
}
extern "C" {
    #[doc = " \\brief  Enable extended palettes\n\nWhen extended palettes are enabled all tiled backgrounds which utilize\n16 bit map entries will use extended palettes.  Everything else will continue\nto use standard palette memory.\n\nEach tile on the screen may chose one of 16 256-color palettes.  Each background\nhas its own set of 16 palettes meaning you can have 4*16*256 colors on screen\n\nEach background uses 8K of palette memory starting at the base of the vram bank\nyou allocate (which bank is up to you within limits, see the vram usage table\nto determine which banks can be mapped for textures).  These 8K blocks are often\nrefered to as \"slots\" with each background getting its own slot.\n\nBy default, Background 0 uses slot 0 ... Background 3 uses slot 3.  It is possible\nto assign Background 0 to slot 2 and Background 1 to slot 3 (only these two are configurable)\n\nFor more information: <a href=\"http://problemkaputt.de/gbatek.htm#dsvideoextendedpalettes\">gbatek</a>"]
    #[link_name = "\u{1}bgExtPaletteEnable__extern"]
    pub fn bgExtPaletteEnable();
}
extern "C" {
    #[doc = " \\brief  Enable extended palettes\n\nWhen extended palettes are enabled all tiled backgrounds which utilize\n16 bit map entries will use extended palettes.  Everything else will continue\nto use standard palette memory.\n\nEach tile on the screen may chose one of 16 256-color palettes.  Each background\nhas its own set of 16 palettes meaning you can have 4*16*256 colors on screen\n\nEach background uses 8K of palette memory starting at the base of the vram bank\nyou allocate (which bank is up to you within limits, see the vram usage table\nto determine which banks can be mapped for textures).  These 8K blocks are often\nrefered to as \"slots\" with each background getting its own slot.\n\nBy default, Background 0 uses slot 0 ... Background 3 uses slot 3.  It is possible\nto assign Background 0 to slot 2 and Background 1 to slot 3 (only these two are configurable)\n\nFor more information: <a href=\"http://problemkaputt.de/gbatek.htm#dsvideoextendedpalettes\">gbatek</a>"]
    #[link_name = "\u{1}bgExtPaletteEnableSub__extern"]
    pub fn bgExtPaletteEnableSub();
}
extern "C" {
    #[doc = " \\brief  Disable extended palettes\n\nWhen extended palettes are enabled all tiled backgrounds which utilize\n16 bit map entries will use extended palettes.  Everything else will continue\nto use standard palette memory.\n\nEach tile on the screen may chose one of 16 256-color palettes.  Each background\nhas its own set of 16 palettes meaning you can have 4*16*256 colors on screen\n\nEach background uses 8K of palette memory starting at the base of the vram bank\nyou allocate (which bank is up to you within limits, see the vram usage table\nto determine which banks can be mapped for textures).  These 8K blocks are often\nrefered to as \"slots\" with each background getting its own slot.\n\nBy default, Background 0 uses slot 0 ... Background 3 uses slot 3.  It is possible\nto assign Background 0 to slot 2 and Background 1 to slot 3 (only these two are configurable)\n\nFor more information: <a href=\"http://problemkaputt.de/gbatek.htm#dsvideoextendedpalettes\">gbatek</a>"]
    #[link_name = "\u{1}bgExtPaletteDisable__extern"]
    pub fn bgExtPaletteDisable();
}
extern "C" {
    #[doc = " \\brief  Disable extended palettes\n\nWhen extended palettes are enabled all tiled backgrounds which utilize\n16 bit map entries will use extended palettes.  Everything else will continue\nto use standard palette memory.\n\nEach tile on the screen may chose one of 16 256-color palettes.  Each background\nhas its own set of 16 palettes meaning you can have 4*16*256 colors on screen\n\nEach background uses 8K of palette memory starting at the base of the vram bank\nyou allocate (which bank is up to you within limits, see the vram usage table\nto determine which banks can be mapped for textures).  These 8K blocks are often\nrefered to as \"slots\" with each background getting its own slot.\n\nBy default, Background 0 uses slot 0 ... Background 3 uses slot 3.  It is possible\nto assign Background 0 to slot 2 and Background 1 to slot 3 (only these two are configurable)\n\nFor more information: <a href=\"http://problemkaputt.de/gbatek.htm#dsvideoextendedpalettes\">gbatek</a>"]
    #[link_name = "\u{1}bgExtPaletteDisableSub__extern"]
    pub fn bgExtPaletteDisableSub();
}
extern "C" {
    #[doc = " \\fn IC_InvalidateAll()\n\\brief invalidate entire instruction cache."]
    pub fn IC_InvalidateAll();
}
extern "C" {
    #[doc = " \\fn IC_InvalidateRange(const void *base, u32 size)\n\\brief invalidate the instruction cache for a range of addresses.\n\\param base base address of the region to invalidate\n\\param size size of the region to invalidate."]
    pub fn IC_InvalidateRange(base: *const ::libc::c_void, size: u32_);
}
extern "C" {
    #[doc = " \\fn DC_FlushAll()\n\\brief flush the entire data cache to memory."]
    pub fn DC_FlushAll();
}
extern "C" {
    #[doc = " \\fn DC_FlushRange(const void *base, u32 size)\n\\brief flush the data cache for a range of addresses to memory.\n\\param base base address of the region to flush.\n\\param size size of the region to flush."]
    pub fn DC_FlushRange(base: *const ::libc::c_void, size: u32_);
}
extern "C" {
    #[doc = " \\fn DC_InvalidateAll()\n\\brief invalidate the entire data cache."]
    pub fn DC_InvalidateAll();
}
extern "C" {
    #[doc = " \\fn DC_InvalidateRange(const void *base, u32 size)\n\\brief invalidate the data cache for a range of addresses.\n\\param base base address of the region to invalidate\n\\param size size of the region to invalidate."]
    pub fn DC_InvalidateRange(base: *const ::libc::c_void, size: u32_);
}
extern "C" {
    #[doc = " \\brief fixed point sine\n\\param angle (-32768 to 32767)\n\\return 4.12 fixed point number with the range [-1, 1]"]
    pub fn sinLerp(angle: s16) -> s16;
}
extern "C" {
    #[doc = " \\brief fixed point cosine\n\\param angle (-32768 to 32767)\n\\return 4.12 fixed point number with the range [-1, 1]"]
    pub fn cosLerp(angle: s16) -> s16;
}
extern "C" {
    #[doc = " \\brief fixed point tangent\n\\param angle (-32768 to 32767)\n\\return 20.12 fixed point number with the range [-81.483, 524287.999]"]
    pub fn tanLerp(angle: s16) -> s32;
}
extern "C" {
    #[doc = " \\brief fixed point arcsin\n\\param par 4.12 fixed point number with the range [-1, 1]\n\\return s16 angle (-32768 to 32767)"]
    pub fn asinLerp(par: s16) -> s16;
}
extern "C" {
    #[doc = " \\brief fixed point arccos\n\\param par 4.12 fixed point number with the range [-1, 1]\n\\return s16 angle (-32768 to 32767)"]
    pub fn acosLerp(par: s16) -> s16;
}
extern "C" {
    #[doc = "    \\brief Fixed point divide\n    \\param num Takes 20.12 numerator.\n    \\param den Takes 20.12 denominator.\n    \\return returns 20.12 result."]
    #[link_name = "\u{1}divf32__extern"]
    pub fn divf32(num: int32, den: int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief Fixed point multiply\n   \\param a Takes 20.12\n   \\param b Takes 20.12\n   \\return returns 20.12 result"]
    #[link_name = "\u{1}mulf32__extern"]
    pub fn mulf32(a: int32, b: int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief Fixed point sqrt\n   \\param a Takes 20.12\n   \\return returns 20.12 result"]
    #[link_name = "\u{1}sqrtf32__extern"]
    pub fn sqrtf32(a: int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief integer divide\n   \\param num  numerator\n   \\param den  denominator\n   \\return returns 32 bit integer result"]
    #[link_name = "\u{1}div32__extern"]
    pub fn div32(num: int32, den: int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief integer modulous\n   \\param num  numerator\n   \\param den  denominator\n   \\return returns 32 bit integer remainder"]
    #[link_name = "\u{1}mod32__extern"]
    pub fn mod32(num: int32, den: int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief integer 64 bit divide\n   \\param num  64 bit numerator\n   \\param den  32 bit denominator\n   \\return returns 32 bit integer result"]
    #[link_name = "\u{1}div64__extern"]
    pub fn div64(num: int64, den: int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief integer 64 bit modulous\n   \\param num  64 bit numerator\n   \\param den  32 bit denominator\n   \\return returns 32 bit integer remainder"]
    #[link_name = "\u{1}mod64__extern"]
    pub fn mod64(num: int64, den: int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief integer sqrt\n   \\param a 32 bit integer argument\n   \\return returns 32 bit integer result"]
    #[link_name = "\u{1}sqrt32__extern"]
    pub fn sqrt32(a: ::libc::c_int) -> u32_;
}
extern "C" {
    #[doc = "   \\brief integer sqrt\n   \\param a 64 bit integer argument\n   \\return returns 32 bit integer result"]
    #[link_name = "\u{1}sqrt64__extern"]
    pub fn sqrt64(a: ::libc::c_longlong) -> u32_;
}
extern "C" {
    #[doc = "   \\brief 20.12 fixed point cross product function result = AxB\n   \\param a pointer to fixed 3x3 matrix\n   \\param b pointer to fixed 3x3 matrix\n   \\param result pointer to fixed 3x3 matrix\n Cross product\\n\n x = Ay * Bz - By * Az\\n\n y = Az * Bx - Bz * Ax\\n\n z = Ax * By - Bx * Ay\\n"]
    #[link_name = "\u{1}crossf32__extern"]
    pub fn crossf32(a: *mut int32, b: *mut int32, result: *mut int32);
}
extern "C" {
    #[doc = "   \\brief 20.12 fixed point dot product function result = A dot B\n   \\param a pointer to fixed 3x3 matrix\n   \\param b pointer to fixed 3x3 matrix\n   \\return 32 bit integer result\n Dot Product\n result = Ax * Bx + Ay * By + Az * Bz"]
    #[link_name = "\u{1}dotf32__extern"]
    pub fn dotf32(a: *mut int32, b: *mut int32) -> int32;
}
extern "C" {
    #[doc = "   \\brief 20.12 fixed point normalize function A = A  / |A|\n   \\param a pointer to fixed 3x3 matrix\n Normalize\\n\n Ax = Ax / mag\\n\n Ay = Ay / mag\\n\n Az = Az / mag\\n"]
    #[link_name = "\u{1}normalizef32__extern"]
    pub fn normalizef32(a: *mut int32);
}
pub type fixed12d3 = uint16;
pub type t16 = ::libc::c_short;
pub type v16 = ::libc::c_short;
pub type v10 = ::libc::c_short;
pub type rgb = ::libc::c_ushort;
#[doc = " \\brief Holds a Matrix of 3x3"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct m3x3 {
    #[doc = "< array that holds matrix"]
    pub m: [::libc::c_int; 9usize],
}
#[doc = " \\brief Holds a Matrix of 4x4"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct m4x4 {
    #[doc = "< array that holds matrix"]
    pub m: [::libc::c_int; 16usize],
}
#[doc = " \\brief Holds a Matrix of 4x3"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct m4x3 {
    #[doc = "< array that holds matrix"]
    pub m: [::libc::c_int; 12usize],
}
#[doc = " \\brief Holds a Vector<BR>related functions: glScalev(), glTranslatev()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GLvector {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
}
#[doc = "< draw triangles with each 3 vertices defining a triangle"]
pub const GL_TRIANGLES: GL_GLBEGIN_ENUM = 0;
#[doc = "< draw quads with each 4 vertices defining a quad"]
pub const GL_QUADS: GL_GLBEGIN_ENUM = 1;
#[doc = "< draw triangles with the first triangle defined by 3 vertices, then each additional triangle being defined by one additional vertex"]
pub const GL_TRIANGLE_STRIP: GL_GLBEGIN_ENUM = 2;
#[doc = "< draw quads with the first quad being defined by 4 vertices, then each additional triangle being defined by 2 vertices."]
pub const GL_QUAD_STRIP: GL_GLBEGIN_ENUM = 3;
#[doc = "< same as GL_TRIANGLES, old non-OpenGL version"]
pub const GL_TRIANGLE: GL_GLBEGIN_ENUM = 0;
#[doc = "< same as GL_QUADS, old non-OpenGL version"]
pub const GL_QUAD: GL_GLBEGIN_ENUM = 1;
#[doc = " \\brief Enums selecting polygon draw mode<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dpolygondefinitionsbyvertices\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dpolygondefinitionsbyvertices</A><BR>\nrelated functions: glBegin()"]
pub type GL_GLBEGIN_ENUM = ::libc::c_uint;
#[doc = "< used to set the Projection Matrix"]
pub const GL_PROJECTION: GL_MATRIX_MODE_ENUM = 0;
#[doc = "< used to set the Position Matrix"]
pub const GL_POSITION: GL_MATRIX_MODE_ENUM = 1;
#[doc = "< used to set the Modelview Matrix"]
pub const GL_MODELVIEW: GL_MATRIX_MODE_ENUM = 2;
#[doc = "< used to set the Texture Matrix"]
pub const GL_TEXTURE: GL_MATRIX_MODE_ENUM = 3;
#[doc = " \\brief Enums selecting matrix mode<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A><BR>\nrelated functions: glMatrixMode()"]
pub type GL_MATRIX_MODE_ENUM = ::libc::c_uint;
#[doc = "< sets the ambient color for the material. The color when the normal is not facing light"]
pub const GL_AMBIENT: GL_MATERIALS_ENUM = 1;
#[doc = "< sets the diffuse color for the material. The color when the normal is facing light"]
pub const GL_DIFFUSE: GL_MATERIALS_ENUM = 2;
#[doc = "< sets the set ambient and diffuse colors for the material; just a two-in-one of the above."]
pub const GL_AMBIENT_AND_DIFFUSE: GL_MATERIALS_ENUM = 3;
#[doc = "< sets the specular color for the material. The glossy(highlight) color of the polygon"]
pub const GL_SPECULAR: GL_MATERIALS_ENUM = 4;
#[doc = "< sets the shininess color for the material. The color that shines back to the user. I have shiny pants!"]
pub const GL_SHININESS: GL_MATERIALS_ENUM = 8;
#[doc = "< sets the emission color for the material. bright color that is indepentant of normals and lights"]
pub const GL_EMISSION: GL_MATERIALS_ENUM = 16;
#[doc = " \\brief Enums for setting up materials<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters</A><BR>\nrelated functions: glMaterialf()"]
pub type GL_MATERIALS_ENUM = ::libc::c_uint;
#[doc = "< enable light number 0"]
pub const POLY_FORMAT_LIGHT0: GL_POLY_FORMAT_ENUM = 1;
#[doc = "< enable light number 1"]
pub const POLY_FORMAT_LIGHT1: GL_POLY_FORMAT_ENUM = 2;
#[doc = "< enable light number 2"]
pub const POLY_FORMAT_LIGHT2: GL_POLY_FORMAT_ENUM = 4;
#[doc = "< enable light number 3"]
pub const POLY_FORMAT_LIGHT3: GL_POLY_FORMAT_ENUM = 8;
#[doc = "< enable modulation shading mode; this is the default"]
pub const POLY_MODULATION: GL_POLY_FORMAT_ENUM = 0;
#[doc = "< enable decal shading"]
pub const POLY_DECAL: GL_POLY_FORMAT_ENUM = 16;
#[doc = "< enable toon/highlight shading mode"]
pub const POLY_TOON_HIGHLIGHT: GL_POLY_FORMAT_ENUM = 32;
#[doc = "< enable shadow shading"]
pub const POLY_SHADOW: GL_POLY_FORMAT_ENUM = 48;
#[doc = "< cull front polygons"]
pub const POLY_CULL_FRONT: GL_POLY_FORMAT_ENUM = 64;
#[doc = "< cull rear polygons"]
pub const POLY_CULL_BACK: GL_POLY_FORMAT_ENUM = 128;
#[doc = "< don't cull any polygons"]
pub const POLY_CULL_NONE: GL_POLY_FORMAT_ENUM = 192;
#[doc = "< enable/disable fog for this polygon"]
pub const POLY_FOG: GL_POLY_FORMAT_ENUM = 32768;
#[doc = " \\brief Enums for setting how polygons will be displayed<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dpolygonattributes\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dpolygonattributes</A><BR>\nrelated functions: glPolyFmt(), glInit(), POLY_ALPHA(), POLY_ID()"]
pub type GL_POLY_FORMAT_ENUM = ::libc::c_uint;
#[doc = "< 8 texels"]
pub const TEXTURE_SIZE_8: GL_TEXTURE_SIZE_ENUM = 0;
#[doc = "< 16 texels"]
pub const TEXTURE_SIZE_16: GL_TEXTURE_SIZE_ENUM = 1;
#[doc = "< 32 texels"]
pub const TEXTURE_SIZE_32: GL_TEXTURE_SIZE_ENUM = 2;
#[doc = "< 64 texels"]
pub const TEXTURE_SIZE_64: GL_TEXTURE_SIZE_ENUM = 3;
#[doc = "< 128 texels"]
pub const TEXTURE_SIZE_128: GL_TEXTURE_SIZE_ENUM = 4;
#[doc = "< 256 texels"]
pub const TEXTURE_SIZE_256: GL_TEXTURE_SIZE_ENUM = 5;
#[doc = "< 512 texels"]
pub const TEXTURE_SIZE_512: GL_TEXTURE_SIZE_ENUM = 6;
#[doc = "< 1024 texels"]
pub const TEXTURE_SIZE_1024: GL_TEXTURE_SIZE_ENUM = 7;
#[doc = " \\brief Enums for size of a texture, specify one for horizontal and one for vertical\nrelated functions: glTexImage2d(), glTexParameter()"]
pub type GL_TEXTURE_SIZE_ENUM = ::libc::c_uint;
#[doc = "< wrap(repeat) texture on S axis"]
pub const GL_TEXTURE_WRAP_S: GL_TEXTURE_PARAM_ENUM = 65536;
#[doc = "< wrap(repeat) texture on T axis"]
pub const GL_TEXTURE_WRAP_T: GL_TEXTURE_PARAM_ENUM = 131072;
#[doc = "< flip texture on S axis when wrapping"]
pub const GL_TEXTURE_FLIP_S: GL_TEXTURE_PARAM_ENUM = 262144;
#[doc = "< flip texture on T axis when wrapping"]
pub const GL_TEXTURE_FLIP_T: GL_TEXTURE_PARAM_ENUM = 524288;
#[doc = "< interpret color 0 as clear, same as old GL_TEXTURE_ALPHA_MASK"]
pub const GL_TEXTURE_COLOR0_TRANSPARENT: GL_TEXTURE_PARAM_ENUM = 536870912;
#[doc = "< use unmodified texcoord"]
pub const TEXGEN_OFF: GL_TEXTURE_PARAM_ENUM = 0;
#[doc = "< multiply texcoords by the texture-matrix"]
pub const TEXGEN_TEXCOORD: GL_TEXTURE_PARAM_ENUM = 1073741824;
#[doc = "< set texcoords equal to normal * texture-matrix, used for spherical reflection mapping"]
pub const TEXGEN_NORMAL: GL_TEXTURE_PARAM_ENUM = -2147483648;
#[doc = "< set texcoords equal to vertex * texture-matrix"]
pub const TEXGEN_POSITION: GL_TEXTURE_PARAM_ENUM = -1073741824;
#[doc = " \\brief Enums for texture parameters, such as texture wrapping and texture coord stuff<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dtextureattributes\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dtextureattributes</A><BR>\nrelated functions: glTexImage2d(), glTexParameter()"]
pub type GL_TEXTURE_PARAM_ENUM = ::libc::c_int;
#[doc = "< no texture is used - useful for making palettes"]
pub const GL_NOTEXTURE: GL_TEXTURE_TYPE_ENUM = 0;
#[doc = "< 32 color palette, 3 bits of alpha"]
pub const GL_RGB32_A3: GL_TEXTURE_TYPE_ENUM = 1;
#[doc = "< 4 color palette"]
pub const GL_RGB4: GL_TEXTURE_TYPE_ENUM = 2;
#[doc = "< 16 color palette"]
pub const GL_RGB16: GL_TEXTURE_TYPE_ENUM = 3;
#[doc = "< 256 color palette"]
pub const GL_RGB256: GL_TEXTURE_TYPE_ENUM = 4;
#[doc = "< compressed texture"]
pub const GL_COMPRESSED: GL_TEXTURE_TYPE_ENUM = 5;
#[doc = "< 8 color palette, 5 bits of alpha"]
pub const GL_RGB8_A5: GL_TEXTURE_TYPE_ENUM = 6;
#[doc = "< 15 bit direct color, 1 bit of alpha"]
pub const GL_RGBA: GL_TEXTURE_TYPE_ENUM = 7;
#[doc = "< 15 bit direct color, manually sets alpha bit to 1"]
pub const GL_RGB: GL_TEXTURE_TYPE_ENUM = 8;
#[doc = " \\brief Enums for texture formats<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dtextureformats\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dtextureformats</A><BR>\nrelated functions: glTexImage2d(), glTexParameter()"]
pub type GL_TEXTURE_TYPE_ENUM = ::libc::c_uint;
#[doc = "< Retrieve the palette address in memory"]
pub const GL_COLOR_TABLE_FORMAT_EXT: GL_TEXTURE_PALETTE_PARAM_ENUM = 0;
#[doc = "< Retrieve the size of the palette"]
pub const GL_COLOR_TABLE_WIDTH_EXT: GL_TEXTURE_PALETTE_PARAM_ENUM = 1;
#[doc = " \\brief Enums for texture palette data retrieval\nrelated functions: glGetColorTableParameterEXT()"]
pub type GL_TEXTURE_PALETTE_PARAM_ENUM = ::libc::c_uint;
#[doc = "< enable/disable textures on the geometry engine"]
pub const GL_TEXTURE_2D: DISP3DCNT_ENUM = 1;
#[doc = "< enable = Highlight shading; disable = Toon shading"]
pub const GL_TOON_HIGHLIGHT: DISP3DCNT_ENUM = 2;
#[doc = "< whether to use the alpha threshold set in glAlphaFunc()"]
pub const GL_ALPHA_TEST: DISP3DCNT_ENUM = 4;
#[doc = "< enable/disable alpha blending"]
pub const GL_BLEND: DISP3DCNT_ENUM = 8;
#[doc = "< nable/disable edge antialiasing; polygons must have different polygon IDs for the effect to work and the rear plane must be clear"]
pub const GL_ANTIALIAS: DISP3DCNT_ENUM = 16;
#[doc = "< enable/disable edge coloring; the high 3bits of the polygon ID determine the color; glSetOutlineColor() sets the available colors"]
pub const GL_OUTLINE: DISP3DCNT_ENUM = 32;
#[doc = "< enable = fade into background?; disable = don't fade?"]
pub const GL_FOG_ONLY_ALPHA: DISP3DCNT_ENUM = 64;
#[doc = "< enables/disables fog"]
pub const GL_FOG: DISP3DCNT_ENUM = 128;
#[doc = "< enable = color buffer underflow, setting resets overflow flag; disable = no color buffer overflow"]
pub const GL_COLOR_UNDERFLOW: DISP3DCNT_ENUM = 4096;
#[doc = "< enable = polygon/vertex buffer overflow, setting resets overflow flag; disable = no polygon/vertex buffer overflow"]
pub const GL_POLY_OVERFLOW: DISP3DCNT_ENUM = 8192;
#[doc = "< rear/clear plane is in BMP mode; disable = rear/color plane is in clear mode"]
pub const GL_CLEAR_BMP: DISP3DCNT_ENUM = 16384;
#[doc = " \\brief 3D Display Control Register Enums<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol\">GBATEK http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol</A><BR>\nrelated functions: glEnable(), glDisable(), glInit()"]
pub type DISP3DCNT_ENUM = ::libc::c_uint;
#[doc = "< returns a count of vertexes currently stored in hardware vertex ram. Use glGetInt() to retrieve"]
pub const GL_GET_VERTEX_RAM_COUNT: GL_GET_ENUM = 0;
#[doc = "< returns a count of polygons currently stored in hardware polygon ram. Use glGetInt() to retrieve"]
pub const GL_GET_POLYGON_RAM_COUNT: GL_GET_ENUM = 1;
#[doc = "< returns the current 3x3 directional vector matrix. Use glGetFixed() to retrieve"]
pub const GL_GET_MATRIX_VECTOR: GL_GET_ENUM = 2;
#[doc = "< returns the current 4x4 position matrix. Use glGetFixed() to retrieve"]
pub const GL_GET_MATRIX_POSITION: GL_GET_ENUM = 3;
#[doc = "< returns the current 4x4 projection matrix. Use glGetFixed() to retrieve"]
pub const GL_GET_MATRIX_PROJECTION: GL_GET_ENUM = 4;
#[doc = "< returns the current 4x4 clip matrix. Use glGetFixed() to retrieve"]
pub const GL_GET_MATRIX_CLIP: GL_GET_ENUM = 5;
#[doc = "< returns the width of the currently bound texture. Use glGetInt() to retrieve"]
pub const GL_GET_TEXTURE_WIDTH: GL_GET_ENUM = 6;
#[doc = "< returns the height of the currently bound texture. Use glGetInt() to retrieve"]
pub const GL_GET_TEXTURE_HEIGHT: GL_GET_ENUM = 7;
#[doc = " \\brief Enums for reading stuff from the geometry engine<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3diomap\">http://problemkaputt.de/gbatek.htm#ds3diomap</A><BR>\nrelated functions: glGetInt(), glGetFixed()"]
pub type GL_GET_ENUM = ::libc::c_uint;
#[doc = "< enable manual sorting of translucent polygons, otherwise uses Y-sorting"]
pub const GL_TRANS_MANUALSORT: GLFLUSH_ENUM = 1;
#[doc = "< enable W depth buffering of vertices, otherwise uses Z depth buffering"]
pub const GL_WBUFFERING: GLFLUSH_ENUM = 2;
#[doc = " \\brief Enums for glFlush()<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol\">GBATEK http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol</A><BR>\nrelated functions: glEnable(), glDisable(), glInit()"]
pub type GLFLUSH_ENUM = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s_SingleBlock {
    pub indexOut: uint32,
    pub AddrSet: *mut uint8,
    pub node: [*mut s_SingleBlock; 4usize],
    pub blockSize: uint32,
}
impl Default for s_SingleBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s_vramBlock {
    pub startAddr: *mut uint8,
    pub endAddr: *mut uint8,
    pub firstBlock: *mut s_SingleBlock,
    pub firstEmpty: *mut s_SingleBlock,
    pub firstAlloc: *mut s_SingleBlock,
    pub lastExamined: *mut s_SingleBlock,
    pub lastExaminedAddr: *mut uint8,
    pub lastExaminedSize: uint32,
    pub blockPtrs: DynamicArray,
    pub deallocBlocks: DynamicArray,
    pub blockCount: uint32,
    pub deallocCount: uint32,
}
impl Default for s_vramBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gl_texture_data {
    pub vramAddr: *mut ::libc::c_void,
    pub texIndex: uint32,
    pub texIndexExt: uint32,
    pub palIndex: ::libc::c_int,
    pub texFormat: uint32,
    pub texSize: uint32,
}
impl Default for gl_texture_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gl_palette_data {
    pub vramAddr: *mut ::libc::c_void,
    pub palIndex: uint32,
    pub addr: uint16,
    pub palSize: uint16,
    pub connectCount: uint32,
}
impl Default for gl_palette_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gl_hidden_globals {
    pub matrixMode: GL_MATRIX_MODE_ENUM,
    pub vramBlocks: [*mut s_vramBlock; 2usize],
    pub vramLock: [::libc::c_int; 2usize],
    pub texturePtrs: DynamicArray,
    pub palettePtrs: DynamicArray,
    pub deallocTex: DynamicArray,
    pub deallocPal: DynamicArray,
    pub deallocTexSize: uint32,
    pub deallocPalSize: uint32,
    pub activeTexture: ::libc::c_int,
    pub activePalette: ::libc::c_int,
    pub texCount: ::libc::c_int,
    pub palCount: ::libc::c_int,
    pub clearColor: u32_,
    pub isActive: uint8,
}
impl Default for gl_hidden_globals {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut glGlobalData: gl_hidden_globals;
}
extern "C" {
    pub static mut glGlob: *mut gl_hidden_globals;
}
extern "C" {
    #[doc = " \\brief Rotates the model view matrix by angle about the specified unit vector\n\\param angle The angle to rotate by\n\\param x X component of the unit vector axis.\n\\param y Y component of the unit vector axis.\n\\param z Z component of the unit vector axis."]
    pub fn glRotatef32i(angle: ::libc::c_int, x: int32, y: int32, z: int32);
}
extern "C" {
    #[doc = " \\brief Loads a 2D texture into texture memory and sets the currently bound texture ID to the attributes specified\n\\param target not used, just here for OpenGL compatibility\n\\param empty1 not used, just here for OpenGL compatibility\n\\param type The format of the texture\n\\param sizeX the horizontal size of the texture; valid sizes are enumerated in GL_TEXTURE_TYPE_ENUM\n\\param sizeY the vertical size of the texture; valid sizes are enumerated in GL_TEXTURE_TYPE_ENUM\n\\param empty2 not used, just here for OpenGL compatibility\n\\param param parameters for the texture\n\\param texture pointer to the texture data to load\n\\return 1 on success, 0 on failure"]
    pub fn glTexImage2D(
        target: ::libc::c_int,
        empty1: ::libc::c_int,
        type_: GL_TEXTURE_TYPE_ENUM,
        sizeX: ::libc::c_int,
        sizeY: ::libc::c_int,
        empty2: ::libc::c_int,
        param: ::libc::c_int,
        texture: *const ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief glColorTableEXT loads a 15-bit color format palette into palette memory, and sets it to the currently bound texture (can be used to remove also)\n\\param target ignored, only here for OpenGL compatability\n\\param empty1 ignored, only here for OpenGL compatability\n\\param width the length of the palette (if 0, then palette is removed from currently bound texture)\n\\param empty2 ignored, only here for OpenGL compatability\n\\param empty3 ignored, only here for OpenGL compatability\n\\param table pointer to the palette data to load (if NULL, then palette is removed from currently bound texture)"]
    pub fn glColorTableEXT(
        target: ::libc::c_int,
        empty1: ::libc::c_int,
        width: uint16,
        empty2: ::libc::c_int,
        empty3: ::libc::c_int,
        table: *const uint16,
    );
}
extern "C" {
    #[doc = " \\brief glColorSubTableEXT loads a 15-bit color format palette into a specific spot in a currently bound texture's existing palette\n\\param target ignored, only here for OpenGL compatability\n\\param start the starting index that new palette data will be written to\n\\param count the number of entries to write\n\\param empty1 ignored, only here for OpenGL compatability\n\\param empty2 ignored, only here for OpenGL compatability\n\\param data pointer to the palette data to load"]
    pub fn glColorSubTableEXT(
        target: ::libc::c_int,
        start: ::libc::c_int,
        count: ::libc::c_int,
        empty1: ::libc::c_int,
        empty2: ::libc::c_int,
        data: *const uint16,
    );
}
extern "C" {
    #[doc = " \\brief glGetColorTableEXT retrieves a 15-bit color format palette from the palette memory of the currently bound texture\n\\param target ignored, only here for OpenGL compatability\n\\param empty1 ignored, only here for OpenGL compatability\n\\param empty2 ignored, only here for OpenGL compatability\n\\param table pointer to where palette data will be written to"]
    pub fn glGetColorTableEXT(
        target: ::libc::c_int,
        empty1: ::libc::c_int,
        empty2: ::libc::c_int,
        table: *mut uint16,
    );
}
extern "C" {
    #[doc = " \\brief glAssignColorTable sets the active texture with a palette set with another texture\n\\param target ignored, only here for OpenGL compatability (not really, since this isn't in OpenGL)\n\\param name the name(int value) of the texture to load a palette from"]
    pub fn glAssignColorTable(target: ::libc::c_int, name: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief Set parameters for the current texture. Although named the same as its gl counterpart, it is not compatible. Effort may be made in the future to make it so.\n\\param target not used, just here for OpenGL compatibility\n\\param param paramaters for the texture"]
    pub fn glTexParameter(target: ::libc::c_int, param: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief Returns the active texture parameter (constructed from internal call to glTexParameter)"]
    pub fn glGetTexParameter() -> u32_;
}
extern "C" {
    pub fn glGetColorTableParameterEXT(
        target: ::libc::c_int,
        pname: ::libc::c_int,
        params: *mut ::libc::c_int,
    );
}
extern "C" {
    #[doc = " \\brief returns the address alocated to the texure named by name\n\\param name the name of the texture to get a pointer to"]
    pub fn glGetTexturePointer(name: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\brief glBindTexure sets the current named texture to the active texture. Target is ignored as all DS textures are 2D\n\\param target ignored, only here for OpenGL compatability\n\\param name the name(int value) to set to the current texture"]
    pub fn glBindTexture(target: ::libc::c_int, name: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief Creates room for the specified number of textures\n\\param n the number of textures to generate\n\\param names pointer to the names array to fill\n\\return 1 on success, 0 on failure"]
    pub fn glGenTextures(n: ::libc::c_int, names: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Deletes the specified number of textures (and associated palettes)\n\\param n the number of textures to delete\n\\param names pointer to the names array to empty\n\\return 1 on success, 0 on failure"]
    pub fn glDeleteTextures(n: ::libc::c_int, names: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Resets the gl texture state freeing all texture and texture palette memory"]
    pub fn glResetTextures();
}
extern "C" {
    pub fn glLockVRAMBank(addr: *mut uint16) -> ::libc::c_int;
}
extern "C" {
    pub fn glUnlockVRAMBank(addr: *mut uint16) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Sets texture coordinates for following vertices<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dtextureattributes\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dtextureattributes</A>\n\\param u U(a.k.a. S) texture coordinate (0.0 - 1.0)\n\\param v V(a.k.a. T) texture coordinate (0.0 - 1.0)"]
    pub fn glTexCoord2f32(u: int32, v: int32);
}
extern "C" {
    #[doc = " \\brief specify the material properties to be used in rendering lit polygons\n\\param mode which material property to change\n\\param color the color to set for that material property"]
    pub fn glMaterialf(mode: GL_MATERIALS_ENUM, color: rgb);
}
extern "C" {
    pub fn glInit_C();
}
extern "C" {
    pub fn glGetGlobals() -> *mut gl_hidden_globals;
}
extern "C" {
    #[doc = " \\fn  u32 POLY_ALPHA(u32 n)\n\\brief used in glPolyFmt() to set the alpha level for the following polygons, set to 0 for wireframe mode\n\\param n the level of alpha (0-31)\n\\return value for hw register"]
    #[link_name = "\u{1}POLY_ALPHA__extern"]
    pub fn POLY_ALPHA(n: u32_) -> u32_;
}
extern "C" {
    #[doc = " \\fn  u32 POLY_ID(u32 n)\n\\brief used in glPolyFmt() to set the Polygon ID for the following polygons\n\\param n the ID to set for following polygons (0-63)\n\\return value for hw register"]
    #[link_name = "\u{1}POLY_ID__extern"]
    pub fn POLY_ID(n: u32_) -> u32_;
}
extern "C" {
    #[doc = " \\fn  void glBegin(GL_GLBEGIN_ENUM mode)\n\\brief Starts a polygon group\n\\param mode the draw mode for the polygon"]
    #[link_name = "\u{1}glBegin__extern"]
    pub fn glBegin(mode: GL_GLBEGIN_ENUM);
}
extern "C" {
    #[doc = " \\fn  void glEnd(void)\n\\brief Ends a polygon group, this seems to be a dummy function that does absolutely nothing, feel free to never use it."]
    #[link_name = "\u{1}glEnd__extern"]
    pub fn glEnd();
}
extern "C" {
    #[doc = " \\fn  void glClearDepth(fixed12d3 depth)\n\\brief reset the depth buffer to this value; generally set this to GL_MAX_DEPTH.<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3drearplane\">GBATEK http://problemkaputt.de/gbatek.htm#ds3drearplane</A>\n\\param depth Something to do with the depth buffer, generally set to GL_MAX_DEPTH"]
    #[link_name = "\u{1}glClearDepth__extern"]
    pub fn glClearDepth(depth: fixed12d3);
}
extern "C" {
    #[doc = " \\fn  void glColor3b(uint8 red, uint8 green, uint8 blue)\n\\brief Set the color for following vertices\n\\param red the red component (0-255) Bottom 3 bits ignored\n\\param green the green component (0-255) Bottom 3 bits ignored\n\\param blue the blue component (0-255) Bottom 3 bits ignored"]
    #[link_name = "\u{1}glColor3b__extern"]
    pub fn glColor3b(red: uint8, green: uint8, blue: uint8);
}
extern "C" {
    #[doc = " \\fn  void glColor(rgb color)\n\\brief Set the color for following vertices\n\\param color the 15bit color value"]
    #[link_name = "\u{1}glColor__extern"]
    pub fn glColor(color: rgb);
}
extern "C" {
    #[doc = " \\fn  void glVertex3v16(v16 x, v16 y, v16 z)\n\\brief specifies a vertex\n\\param x the x component for the vertex\n\\param y the y component for the vertex\n\\param z the z component for the vertex"]
    #[link_name = "\u{1}glVertex3v16__extern"]
    pub fn glVertex3v16(x: v16, y: v16, z: v16);
}
extern "C" {
    #[doc = " \\fn  void glTexCoord2t16(t16 u, t16 v)\n\\brief Sets texture coordinates for following vertices<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dtextureattributes\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dtextureattributes</A>\n\\param u U(a.k.a. S) texture coordinate in texels\n\\param v V(a.k.a. T) texture coordinate in texels"]
    #[link_name = "\u{1}glTexCoord2t16__extern"]
    pub fn glTexCoord2t16(u: t16, v: t16);
}
extern "C" {
    #[doc = " \\fn   void glPushMatrix(void)\n\\brief Pushes the current matrix onto the stack<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixstack\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixstack</A>"]
    #[link_name = "\u{1}glPushMatrix__extern"]
    pub fn glPushMatrix();
}
extern "C" {
    #[doc = " \\fn  void glPopMatrix(int num)\n\\brief Pops num matrices off the stack<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixstack\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixstack</A>\n\\param num the number to pop down the stack"]
    #[link_name = "\u{1}glPopMatrix__extern"]
    pub fn glPopMatrix(num: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn  void glRestoreMatrix(int index)\n\\brief Restores the current matrix from a location in the stack<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixstack\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixstack</A>\n\\param index the place in the stack to restore to"]
    #[link_name = "\u{1}glRestoreMatrix__extern"]
    pub fn glRestoreMatrix(index: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn   void glStoreMatrix(int index)\n\\brief Place the current matrix into the stack at a location<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixstack\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixstack</A>\n\\param index the place in the stack to put the current matrix"]
    #[link_name = "\u{1}glStoreMatrix__extern"]
    pub fn glStoreMatrix(index: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn  void glScalev(const GLvector* v)\n\\brief multiply the current matrix by a translation matrix<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A>\n\\param v the vector to translate by"]
    #[link_name = "\u{1}glScalev__extern"]
    pub fn glScalev(v: *const GLvector);
}
extern "C" {
    #[doc = " \\fn  void glTranslatev(const GLvector* v)\n\\brief multiply the current matrix by a translation matrix<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A>\n\\param v the vector to translate by"]
    #[link_name = "\u{1}glTranslatev__extern"]
    pub fn glTranslatev(v: *const GLvector);
}
extern "C" {
    #[doc = " \\fn  void glTranslatef32(int x, int y, int z)\n\\brief multiply the current matrix by a translation matrix<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A>\n\\param x translation on the x axis\n\\param y translation on the y axis\n\\param z translation on the z axis"]
    #[link_name = "\u{1}glTranslatef32__extern"]
    pub fn glTranslatef32(x: ::libc::c_int, y: ::libc::c_int, z: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn  void glScalef32(int x, int y, int z)\n\\brief multiply the current matrix by a scale matrix<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A>\n\\param x scaling on the x axis\n\\param y scaling on the y axis\n\\param z scaling on the z axis"]
    #[link_name = "\u{1}glScalef32__extern"]
    pub fn glScalef32(x: ::libc::c_int, y: ::libc::c_int, z: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn  void glLight(int id, rgb color, v10 x, v10 y, v10 z)\n\\brief set a light up. Only parallel light sources are supported on the DS<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters</A>\n\\param id the number of the light to setup\n\\param color the color of the light\n\\param x the x component of the lights directional vector. Direction must be normalized\n\\param y the y component of the lights directional vector. Direction must be normalized\n\\param z the z component of the lights directional vector. Direction must be normalized"]
    #[link_name = "\u{1}glLight__extern"]
    pub fn glLight(id: ::libc::c_int, color: rgb, x: v10, y: v10, z: v10);
}
extern "C" {
    #[doc = " \\fn  void glNormal(u32 normal)\n\\brief the normal to use for following vertices<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters</A>\n\\warning The nature of the format means that you can't represent the following normals exactly (0,0,1), (0,1,0), or (1,0,0)\n\\param normal the packed normal(3 * 10bit x, y, z)"]
    #[link_name = "\u{1}glNormal__extern"]
    pub fn glNormal(normal: u32_);
}
extern "C" {
    #[doc = " \\fn  void glLoadIdentity(void)\n\\brief loads an identity matrix to the current matrix, same as glIdentity(void)"]
    #[link_name = "\u{1}glLoadIdentity__extern"]
    pub fn glLoadIdentity();
}
extern "C" {
    #[doc = " \\fn  void glMatrixMode(GL_MATRIX_MODE_ENUM mode)\n\\brief change the current matrix mode<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A><BR>\n\\param mode the mode for the matrix"]
    #[link_name = "\u{1}glMatrixMode__extern"]
    pub fn glMatrixMode(mode: GL_MATRIX_MODE_ENUM);
}
extern "C" {
    #[doc = " \\fn   void glViewport(uint8 x1, uint8 y1, uint8 x2, uint8 y2)\n\\brief specify the viewport for following drawing, can be set several times per frame.<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol\">GBATEK http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol</A>\n\\param x1 the left of the viewport\n\\param y1 the bottom of the viewport\n\\param x2 the right of the viewport\n\\param y2 the top of the viewport"]
    #[link_name = "\u{1}glViewport__extern"]
    pub fn glViewport(x1: uint8, y1: uint8, x2: uint8, y2: uint8);
}
extern "C" {
    #[doc = " \\fn  void glFlush(u32 mode)\n\\brief Waits for a Vblank and swaps the buffers(like swiWaitForVBlank), but lets you specify some 3D options<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol\">GBATEK http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol</A>\n\\param mode flags from GLFLUSH_ENUM for enabling Y-sorting of translucent polygons and W-Buffering of all vertices"]
    #[link_name = "\u{1}glFlush__extern"]
    pub fn glFlush(mode: u32_);
}
extern "C" {
    #[doc = " \\fn  void glMaterialShinyness(void)\n\\brief The DS uses a table for shininess..this generates a half-ass one"]
    #[link_name = "\u{1}glMaterialShinyness__extern"]
    pub fn glMaterialShinyness();
}
extern "C" {
    #[doc = " \\fn  void glCallList(const u32* list)\n\\brief throws a packed list of commands into the graphics FIFO via asyncronous DMA<BR>\nThe first 32bits is the length of the packed command list, followed by a the packed list.<BR>\nIf you want to do this really fast then write your own code that that does this synchronously and only flushes the cache when the list is changed<BR>\nThere is sometimes a problem when you pack the GFX_END command into a list, so don't. GFX_END is a dummy command and never needs called<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dgeometrycommands\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dgeometrycommands</A>"]
    #[link_name = "\u{1}glCallList__extern"]
    pub fn glCallList(list: *const u32_);
}
extern "C" {
    #[doc = " \\fn  void glPolyFmt(u32 params)\n\\brief Set the parameters for polygons rendered on the current frame<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dpolygonattributes\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dpolygonattributes</A>\n\\param params the paramters to set for the polygons for the current frame. valid paramters are enumerated in GL_POLY_FORMAT_ENUM and in the functions POLY_ALPHA() and POLY_ID()"]
    #[link_name = "\u{1}glPolyFmt__extern"]
    pub fn glPolyFmt(params: u32_);
}
extern "C" {
    #[doc = " \\fn  void glEnable(int bits)\n\\brief Enables various gl states (blend, alpha test, etc..)\n\\param bits bit mask of desired attributes, attributes are enumerated in DISP3DCNT_ENUM"]
    #[link_name = "\u{1}glEnable__extern"]
    pub fn glEnable(bits: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn   void glDisable(int bits)\n\\brief Disables various gl states (blend, alpha test, etc..)\n\\param bits bit mask of desired attributes, attributes are enumerated in DISP3DCNT_ENUM"]
    #[link_name = "\u{1}glDisable__extern"]
    pub fn glDisable(bits: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn   void glFogShift(int shift)\n\\brief Sets the FOG_SHIFT value\n\\param shift FOG_SHIFT value; each entry of the fog table covers 0x400 >> FOG_SHIFT depth values"]
    #[link_name = "\u{1}glFogShift__extern"]
    pub fn glFogShift(shift: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn   void glFogOffset(int shift)\n\\brief Sets the FOG_OFFSET value\n\\param shift FOG_OFFSET value; fogging begins at this depth with a density of FOG_TABLE[0]"]
    #[link_name = "\u{1}glFogOffset__extern"]
    pub fn glFogOffset(offset: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn void glFogColor(uint8 red, uint8 green, uint8 blue, uint8 alpha)\n\\brief sets the fog color\n\\param red component (0-31)\n\\param green component (0-31)\n\\param blue component (0-31)\n\\param alpha from 0(clear) to 31(opaque)"]
    #[link_name = "\u{1}glFogColor__extern"]
    pub fn glFogColor(red: uint8, green: uint8, blue: uint8, alpha: uint8);
}
extern "C" {
    #[doc = " \\fn void glFogDensity(int index, int density)\n\\brief sets the fog density at a given index\n\\param index fog table index to operate on (0 to 31)\n\\param density fog density from 0 (none) to 127 (opaque)"]
    #[link_name = "\u{1}glFogDensity__extern"]
    pub fn glFogDensity(index: ::libc::c_int, density: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn  void glLoadMatrix4x4(const m4x4 *m)\n\\brief Loads a 4x4 matrix into the current matrix\n\\param m pointer to a 4x4 matrix"]
    #[link_name = "\u{1}glLoadMatrix4x4__extern"]
    pub fn glLoadMatrix4x4(m: *const m4x4);
}
extern "C" {
    #[doc = "  \\fn void glLoadMatrix4x3(const m4x3 * m)\n\\brief Loads a 4x3 matrix into the current matrix\n\\param m pointer to a 4x4 matrix"]
    #[link_name = "\u{1}glLoadMatrix4x3__extern"]
    pub fn glLoadMatrix4x3(m: *const m4x3);
}
extern "C" {
    #[doc = "  \\fn void glMultMatrix4x4(const m4x4 * m)\n\\brief Multiplies the current matrix by m\n\\param m pointer to a 4x4 matrix"]
    #[link_name = "\u{1}glMultMatrix4x4__extern"]
    pub fn glMultMatrix4x4(m: *const m4x4);
}
extern "C" {
    #[doc = "  \\fn void glMultMatrix4x3(const m4x3 * m)\n\\brief multiplies the current matrix by\n\\param m pointer to a 4x3 matrix"]
    #[link_name = "\u{1}glMultMatrix4x3__extern"]
    pub fn glMultMatrix4x3(m: *const m4x3);
}
extern "C" {
    #[doc = "  \\fn void glMultMatrix3x3(const m3x3 * m)\n\\brief multiplies the current matrix by m\n\\param m pointer to a 3x3 matrix"]
    #[link_name = "\u{1}glMultMatrix3x3__extern"]
    pub fn glMultMatrix3x3(m: *const m3x3);
}
extern "C" {
    #[doc = "  \\fn void glRotateXi(int angle)\n\\brief Rotates the current modelview matrix by angle about the x axis\n\\param angle The angle to rotate by (angle is -32768 to 32767)"]
    #[link_name = "\u{1}glRotateXi__extern"]
    pub fn glRotateXi(angle: ::libc::c_int);
}
extern "C" {
    #[doc = "  \\fn void glRotateYi(int angle)\n\\brief Rotates the current modelview matrix by angle about the y axis\n\\param angle The angle to rotate by (angle is -32768 to 32767)"]
    #[link_name = "\u{1}glRotateYi__extern"]
    pub fn glRotateYi(angle: ::libc::c_int);
}
extern "C" {
    #[doc = "  \\fn void glRotateZi(int angle)\n\\brief Rotates the current modelview matrix by angle about the z axis\n\\param angle The angle to rotate by (angle is -32768 to 32767)"]
    #[link_name = "\u{1}glRotateZi__extern"]
    pub fn glRotateZi(angle: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn void glOrthof32(int left, int right, int bottom, int top, int zNear, int zFar)\n\\brief Multiplies the current matrix into ortho graphic mode\n\\param left left vertical clipping plane\n\\param right right vertical clipping plane\n\\param bottom bottom vertical clipping plane\n\\param top top vertical clipping plane\n\\param zNear near clipping plane\n\\param zFar far clipping plane"]
    #[link_name = "\u{1}glOrthof32__extern"]
    pub fn glOrthof32(
        left: ::libc::c_int,
        right: ::libc::c_int,
        bottom: ::libc::c_int,
        top: ::libc::c_int,
        zNear: ::libc::c_int,
        zFar: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\fn void gluLookAtf32(int eyex, int eyey, int eyez, int lookAtx, int lookAty, int lookAtz, int upx, int upy, int upz)\n\\brief Places the camera at the specified location and orientation (fixed point version)\n\\param eyex (eyex, eyey, eyez) Location of the camera.\n\\param eyey (eyex, eyey, eyez) Location of the camera.\n\\param eyez (eyex, eyey, eyez) Location of the camera.\n\\param lookAtx (lookAtx, lookAty, lookAtz) Where the camera is looking.\n\\param lookAty (lookAtx, lookAty, lookAtz) Where the camera is looking.\n\\param lookAtz (lookAtx, lookAty, lookAtz) Where the camera is looking.\n\\param upx <upx, upy, upz> Unit vector describing which direction is up for the camera.\n\\param upy <upx, upy, upz> Unit vector describing which direction is up for the camera.\n\\param upz <upx, upy, upz> Unit vector describing which direction is up for the camera."]
    #[link_name = "\u{1}gluLookAtf32__extern"]
    pub fn gluLookAtf32(
        eyex: ::libc::c_int,
        eyey: ::libc::c_int,
        eyez: ::libc::c_int,
        lookAtx: ::libc::c_int,
        lookAty: ::libc::c_int,
        lookAtz: ::libc::c_int,
        upx: ::libc::c_int,
        upy: ::libc::c_int,
        upz: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\fn void glFrustumf32(int left, int right, int bottom, int top, int near, int far)\n\\brief Specifies the viewing frustum for the projection matrix (fixed point version)\n\\param left left right top and bottom describe a rectangle located at the near clipping plane\n\\param right left right top and bottom describe a rectangle located at the near clipping plane\n\\param top left right top and bottom describe a rectangle located at the near clipping plane\n\\param bottom left right top and bottom describe a rectangle located at the near clipping plane\n\\param near Location of a the near clipping plane (parallel to viewing window)\n\\param far Location of a the far clipping plane (parallel to viewing window)"]
    #[link_name = "\u{1}glFrustumf32__extern"]
    pub fn glFrustumf32(
        left: ::libc::c_int,
        right: ::libc::c_int,
        bottom: ::libc::c_int,
        top: ::libc::c_int,
        near: ::libc::c_int,
        far: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\fn void gluPerspectivef32(int fovy, int aspect, int zNear, int zFar)\n\\brief Utility function which sets up the projection matrix (fixed point version)\n\\param fovy Specifies the field of view in degrees (-32768 to 32767)\n\\param aspect Specifies the aspect ratio of the screen (normally screen width/screen height)\n\\param zNear Specifies the near clipping plane\n\\param zFar Specifies the far clipping plane"]
    #[link_name = "\u{1}gluPerspectivef32__extern"]
    pub fn gluPerspectivef32(
        fovy: ::libc::c_int,
        aspect: ::libc::c_int,
        zNear: ::libc::c_int,
        zFar: ::libc::c_int,
    );
}
extern "C" {
    #[doc = " \\fn void gluPickMatrix(int x, int y, int width, int height, const int viewport[4])\n\\brief Utility function which generates a picking matrix for selection\n\\param x 2D x of center  (touch x normally)\n\\param y 2D y of center  (touch y normally)\n\\param width width in pixels of the window (3 or 4 is a good number)\n\\param height height in pixels of the window (3 or 4 is a good number)\n\\param viewport the current viewport (normally {0, 0, 255, 191})"]
    #[link_name = "\u{1}gluPickMatrix__extern"]
    pub fn gluPickMatrix(
        x: ::libc::c_int,
        y: ::libc::c_int,
        width: ::libc::c_int,
        height: ::libc::c_int,
        viewport: *const ::libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\fn void glResetMatrixStack(void)\n\\brief Resets matrix stack to top level"]
    #[link_name = "\u{1}glResetMatrixStack__extern"]
    pub fn glResetMatrixStack();
}
extern "C" {
    #[doc = " \\fn void glSetOutlineColor(int id, rgb color)\n\\brief Specifies an edge color for polygons\n\\param id which outline color to set (0-7)\n\\param color the 15bit color to set"]
    #[link_name = "\u{1}glSetOutlineColor__extern"]
    pub fn glSetOutlineColor(id: ::libc::c_int, color: rgb);
}
extern "C" {
    #[doc = " \\fn void glSetToonTable(const uint16 *table)\n\\brief Loads a toon table\n\\param table pointer to the 32 color palette to load into the toon table"]
    #[link_name = "\u{1}glSetToonTable__extern"]
    pub fn glSetToonTable(table: *const uint16);
}
extern "C" {
    #[doc = "  \\fn void glSetToonTableRange(int start, int end, rgb color)\n\\brief Sets a range of colors on the toon table\n\\param start the start of the range\n\\param end the end of the range\n\\param color the color to set for that range"]
    #[link_name = "\u{1}glSetToonTableRange__extern"]
    pub fn glSetToonTableRange(start: ::libc::c_int, end: ::libc::c_int, color: rgb);
}
extern "C" {
    #[doc = "  \\fn void glGetFixed(const GL_GET_ENUM param, int* f)\n\\brief Grabs fixed format of state variables<BR>\nOpenGL's modelview matrix is handled on the DS with two matrices. The combination of the DS's position matrix and directional vector matrix hold the data that is in OpenGL's one modelview matrix. (a.k.a. modelview = postion and vector)<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3diomap\">http://problemkaputt.de/gbatek.htm#ds3diomap</A>\n\\param param The state variable to retrieve\n\\param f pointer with room to hold the requested data"]
    #[link_name = "\u{1}glGetFixed__extern"]
    pub fn glGetFixed(param: GL_GET_ENUM, f: *mut ::libc::c_int);
}
extern "C" {
    #[doc = "  \\fn void glAlphaFunc(int alphaThreshold)\n\\brief set the minimum alpha value that will be used<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol\">GBATEK http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol</A>\n\\param alphaThreshold minimum alpha value that will be used (0-15)"]
    #[link_name = "\u{1}glAlphaFunc__extern"]
    pub fn glAlphaFunc(alphaThreshold: ::libc::c_int);
}
extern "C" {
    #[doc = "  \\fn  void glCutoffDepth(fixed12d3 wVal)\n\\brief Stop the drawing of polygons that are a certain distance from the camera.<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol\">GBATEK http://problemkaputt.de/gbatek.htm#ds3ddisplaycontrol</A>\n\\param wVal polygons that are beyond this W-value(distance from camera) will not be drawn; 15bit value."]
    #[link_name = "\u{1}glCutoffDepth__extern"]
    pub fn glCutoffDepth(wVal: fixed12d3);
}
extern "C" {
    #[doc = " \\fn void glInit()\n\\brief Initializes the gl state machine (must be called once before using gl calls)"]
    #[link_name = "\u{1}glInit__extern"]
    pub fn glInit();
}
extern "C" {
    #[doc = " \\fn void glClearColor(uint8 red, uint8 green, uint8 blue, uint8 alpha)\n\\brief sets the color of the rear-plane(a.k.a Clear Color/Plane)\n\\param red component (0-31)\n\\param green component (0-31)\n\\param blue component (0-31)\n\\param alpha from 0(clear) to 31(opaque)"]
    #[link_name = "\u{1}glClearColor__extern"]
    pub fn glClearColor(red: uint8, green: uint8, blue: uint8, alpha: uint8);
}
extern "C" {
    #[doc = " \\fn void glClearPolyID(uint8 ID)\n\\brief sets the polygon ID of the rear-plane(a.k.a. Clear/Color Plane), useful for antialiasing and edge coloring\n\\param ID the polygon ID to give the rear-plane"]
    #[link_name = "\u{1}glClearPolyID__extern"]
    pub fn glClearPolyID(ID: uint8);
}
extern "C" {
    #[doc = " \\fn void glGetInt(GL_GET_ENUM param, int* i)\n\\brief Grabs integer state variables from openGL\n\\param param The state variable to retrieve\n\\param i pointer with room to hold the requested data"]
    #[link_name = "\u{1}glGetInt__extern"]
    pub fn glGetInt(param: GL_GET_ENUM, i: *mut ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn void glVertex3f(float x, float y, float z)\n\\brief specifies a vertex location\n\\warning FLOAT VERSION!!!! please use glVertex3v16()\n\\param x the x component of the vertex\n\\param y the y component of the vertex\n\\param z the z component of the vertex"]
    #[link_name = "\u{1}glVertex3f__extern"]
    pub fn glVertex3f(x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " \\fn void glRotatef32(float angle, int x, int y, int z)\n\\brief Rotate on an arbitrary axis\n\\warning FLOAT VERSION!!!! please use glRotatef32i()\n\\param angle the angle to rotate by\n\\param x the x component of the axis to rotate on\n\\param y the y component of the axis to rotate on\n\\param z the z component of the axis to rotate on"]
    #[link_name = "\u{1}glRotatef32__extern"]
    pub fn glRotatef32(angle: f32, x: ::libc::c_int, y: ::libc::c_int, z: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn void glRotatef(float angle, float x, float y, float z)\n\\brief Rotate about an arbitrary axis\n\\warning FLOAT VERSION!!!! please use glRotatef32i()\n\\param angle the angle to rotate by\n\\param x the x component of the axis to rotate on\n\\param y the y component of the axis to rotate on\n\\param z the z component of the axis to rotate on"]
    #[link_name = "\u{1}glRotatef__extern"]
    pub fn glRotatef(angle: f32, x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " \\fn void glColor3f(float r, float g, float b)\n\\brief specify a color for following vertices\n\\warning FLOAT VERSION!!!! please use glColor3b()\n\\param r the red component of the color\n\\param g the green component of the color\n\\param b the blue component of the color"]
    #[link_name = "\u{1}glColor3f__extern"]
    pub fn glColor3f(r: f32, g: f32, b: f32);
}
extern "C" {
    #[doc = " \\fn void glScalef(float x, float y, float z)\n\\brief multiply the current matrix by a scale matrix<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A>\n\\warning FLOAT VERSION!!!! please use glScalev() or glScalef32()\n\\param x scaling on the x axis\n\\param y scaling on the y axis\n\\param z scaling on the z axis"]
    #[link_name = "\u{1}glScalef__extern"]
    pub fn glScalef(x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " \\fn void glTranslatef(float x, float y, float z)\n\\brief multiply the current matrix by a translation matrix<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dmatrixloadmultiply</A>\n\\warning FLOAT VERSION!!!! please use glTranslatef32()\n\\param x translation on the x axis\n\\param y translation on the y axis\n\\param z translation on the z axis"]
    #[link_name = "\u{1}glTranslatef__extern"]
    pub fn glTranslatef(x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " \\fn void glNormal3f(float x, float y, float z)\n\\brief the normal to use for following vertices<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dpolygonlightparameters</A>\n\\warning FLOAT VERSION!!!! please use glNormal()\n\\param x x component of the normal, vector must be normalized\n\\param y y component of the normal, vector must be normalized\n\\param z z component of the normal, vector must be normalized"]
    #[link_name = "\u{1}glNormal3f__extern"]
    pub fn glNormal3f(x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " \\fn void glRotateX(float angle)\n\\brief Rotates the current modelview matrix by angle degrees about the x axis\n\\warning FLOAT VERSION!!!! please use glRotateXi()\n\\param angle The angle to rotate by"]
    #[link_name = "\u{1}glRotateX__extern"]
    pub fn glRotateX(angle: f32);
}
extern "C" {
    #[doc = " \\fn void glRotateY(float angle)\n\\brief Rotates the current modelview matrix by angle degrees about the y axis\n\\warning FLOAT VERSION!!!! please use glRotateYi()\n\\param angle The angle to rotate by"]
    #[link_name = "\u{1}glRotateY__extern"]
    pub fn glRotateY(angle: f32);
}
extern "C" {
    #[doc = " \\fn void glRotateZ(float angle)\n\\brief Rotates the current modelview matrix by angle degrees about the z axis\n\\warning FLOAT VERSION!!!! please use glRotateZi()\n\\param angle The angle to rotate by"]
    #[link_name = "\u{1}glRotateZ__extern"]
    pub fn glRotateZ(angle: f32);
}
extern "C" {
    #[doc = " \\fn void glOrtho(float left, float right, float bottom, float top, float zNear, float zFar)\n\\brief Multiplies the current matrix into ortho graphic mode\n\\warning FLOAT VERSION!!!! please use glOrthof32()\n\\param left left vertical clipping plane\n\\param right right vertical clipping plane\n\\param bottom bottom vertical clipping plane\n\\param top top vertical clipping plane\n\\param zNear near clipping plane\n\\param zFar far clipping plane"]
    #[link_name = "\u{1}glOrtho__extern"]
    pub fn glOrtho(left: f32, right: f32, bottom: f32, top: f32, zNear: f32, zFar: f32);
}
extern "C" {
    #[doc = " \\fn void gluLookAt(\tfloat eyex, float eyey, float eyez,\nfloat lookAtx, float lookAty, float lookAtz,\nfloat upx, float upy, float upz)\n\\brief Places the camera at the specified location and orientation (floating point version)\n\\warning FLOAT VERSION!!!! please use gluLookAtf32()\n\\param eyex (eyex, eyey, eyez) Location of the camera.\n\\param eyey (eyex, eyey, eyez) Location of the camera.\n\\param eyez (eyex, eyey, eyez) Location of the camera.\n\\param lookAtx (lookAtx, lookAty, lookAtz) Where the camera is looking.\n\\param lookAty (lookAtx, lookAty, lookAtz) Where the camera is looking.\n\\param lookAtz (lookAtx, lookAty, lookAtz) Where the camera is looking.\n\\param upx <upx, upy, upz> Unit vector describing which direction is up for the camera.\n\\param upy <upx, upy, upz> Unit vector describing which direction is up for the camera.\n\\param upz <upx, upy, upz> Unit vector describing which direction is up for the camera."]
    #[link_name = "\u{1}gluLookAt__extern"]
    pub fn gluLookAt(
        eyex: f32,
        eyey: f32,
        eyez: f32,
        lookAtx: f32,
        lookAty: f32,
        lookAtz: f32,
        upx: f32,
        upy: f32,
        upz: f32,
    );
}
extern "C" {
    #[doc = " \\fn void glFrustum(float left, float right, float bottom, float top, float near, float far)\n\\brief Specifies the viewing frustum for the projection matrix (floating point version)\n\\warning FLOAT VERSION!!!! please use glFrustumf32()\n\\param left left right top and bottom describe a rectangle located at the near clipping plane\n\\param right left right top and bottom describe a rectangle located at the near clipping plane\n\\param top left right top and bottom describe a rectangle located at the near clipping plane\n\\param bottom left right top and bottom describe a rectangle located at the near clipping plane\n\\param near Location of a the near clipping plane (parallel to viewing window)\n\\param far Location of a the far clipping plane (parallel to viewing window)"]
    #[link_name = "\u{1}glFrustum__extern"]
    pub fn glFrustum(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32);
}
extern "C" {
    #[doc = " \\fn void gluPerspective(float fovy, float aspect, float zNear, float zFar)\n\\brief Utility function which sets up the projection matrix (floating point version)\n\\warning FLOAT VERSION!!!! please use gluPerspectivef32()\n\\param fovy Specifies the field of view in degrees\n\\param aspect Specifies the aspect ratio of the screen (normally screen width/screen height)\n\\param zNear Specifies the near clipping plane\n\\param zFar Specifies the far clipping plane"]
    #[link_name = "\u{1}gluPerspective__extern"]
    pub fn gluPerspective(fovy: f32, aspect: f32, zNear: f32, zFar: f32);
}
extern "C" {
    #[doc = " \\fn void glTexCoord2f(float s, float t)\n\\brief Sets texture coordinates for following vertices<BR>\n<A HREF=\"http://problemkaputt.de/gbatek.htm#ds3dtextureattributes\">GBATEK http://problemkaputt.de/gbatek.htm#ds3dtextureattributes</A>\n\\warning FLOAT VERSION!!!! please use glTexCoord2t16()\n\\param s S(a.k.a. U) texture coordinate (0.0 - 1.0)\n\\param t T(a.k.a. V) texture coordinate (0.0 - 1.0)"]
    #[link_name = "\u{1}glTexCoord2f__extern"]
    pub fn glTexCoord2f(s: f32, t: f32);
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustrum.\n\\param x (x, y, z) point of a vertex on the box\n\\param y (x, y, z) point of a vertex on the box\n\\param z (x, y, z) point of a vertex on the box\n\\param height (height, width, depth) describe the size of the box referenced from (x, y, z)\n\\param width (height, width, depth) describe the size of the box referenced from (x, y, z)\n\\param depth (height, width, depth) describe the size of the box referenced from (x, y, z)\n\n\\return non zero if any or all of the box is in the view frustum."]
    pub fn BoxTest(x: v16, y: v16, z: v16, width: v16, height: v16, depth: v16) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustum.\n\\param x (x, y, z) point of a vertex on the box\n\\param y (x, y, z) point of a vertex on the box\n\\param z (x, y, z) point of a vertex on the box\n\\param width (width, height, depth) describe the size of the box referenced from (x, y, z)\n\\param height (width, height, depth) describe the size of the box referenced from (x, y, z)\n\\param depth (width, height, depth) describe the size of the box referenced from (x, y, z)\n\n\\return non zero if any or all of the box is in the view frustum."]
    pub fn BoxTestf(x: f32, y: f32, z: f32, width: f32, height: f32, depth: f32) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustum.\nPerforms a test to determine if the provided box is in the view frustum.\nBoxTestResult must be called to get the result of this operation.\n\n\\param x (x, y, z) point of a vertex on the box\n\\param y (x, y, z) point of a vertex on the box\n\\param z (x, y, z) point of a vertex on the box\n\\param width (width, height, depth) describe the size of the box referenced from (x, y, z)\n\\param height (width, height, depth) describe the size of the box referenced from (x, y, z)\n\\param depth (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    pub fn BoxTest_Asynch(x: v16, y: v16, z: v16, height: v16, width: v16, depth: v16);
}
extern "C" {
    #[doc = "\t\\brief Performs a test to determine if the provided box is in the view frustum.\nPerforms a test to determine if the provided box is in the view frustum.\nBoxTestResult must be called to get the result of this operation.\n\n\\param x (x, y, z) point of a vertex on the box\n\\param y (x, y, z) point of a vertex on the box\n\\param z (x, y, z) point of a vertex on the box\n\\param width (width, height, depth) describe the size of the box referenced from (x, y, z)\n\\param height (width, height, depth) describe the size of the box referenced from (x, y, z)\n\\param depth (width, height, depth) describe the size of the box referenced from (x, y, z)"]
    pub fn BoxTestf_Asynch(x: f32, y: f32, z: f32, width: f32, height: f32, depth: f32);
}
extern "C" {
    #[doc = "\t\\brief Gets the result of the last box test. Needed for asynch box test calls.\n\\return non zero if any or all of the box is in the view frustum."]
    pub fn BoxTestResult() -> ::libc::c_int;
}
pub type ConsolePrint = ::core::option::Option<
    unsafe extern "C" fn(con: *mut ::libc::c_void, c: ::libc::c_char) -> bool,
>;
#[doc = "! a font struct for the console."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConsoleFont {
    #[doc = "!< A pointer to the font graphics (will be loaded by consoleInit() if loadGraphics is true"]
    pub gfx: *mut u16_,
    #[doc = "!< A pointer to the font palette (will be loaded by consoleInit() if loadGraphics is true"]
    pub pal: *mut u16_,
    #[doc = "!< Number of colors in the font palette"]
    pub numColors: u16_,
    #[doc = "!< Bits per pixel in the font graphics"]
    pub bpp: u8_,
    #[doc = "!<  Offset to the first valid character in the font table"]
    pub asciiOffset: u16_,
    #[doc = "!< Number of characters in the font graphics"]
    pub numChars: u16_,
    #[doc = "< If true font is treated as a single color font where all non zero pixels are set to\na value of 15 or 255 (4bpp / 8bpp respectivly).\nThis ensures only one palette entry is utilized for font rendering."]
    pub convertSingleColor: bool,
}
impl Default for ConsoleFont {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief console structure used to store the state of a console render context.\n\nDefault values from consoleGetDefault();\n<div class=\"fixedFont\"><pre>\nPrintConsole defaultConsole =\n{\n//Font:\n{\n(u16*)default_font_bin, //font gfx\n0, //font palette\n0, //font color count\n4, //bpp\n0, //first ascii character in the set\n128, //number of characters in the font set\ntrue, //convert to single color\n},\n0, //font background map\n0, //font background gfx\n31, //map base\n0, //char base\n0, //bg layer in use\n-1, //bg id\n0,0, //cursorX cursorY\n0,0, //prevcursorX prevcursorY\n32, //console width\n24, //console height\n0,  //window x\n0,  //window y\n32, //window width\n24, //window height\n3, //tab size\n0, //font character offset\n0, //selected palette\n0,  //print callback\nfalse, //console initialized\ntrue, //load graphics\n};\n</pre></div>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintConsole {
    #[doc = "!< font of the console."]
    pub font: ConsoleFont,
    #[doc = "< Pointer to the bg layer map if used.  Is set by bgInit if bgId is valid"]
    pub fontBgMap: *mut u16_,
    #[doc = "< Pointer to the bg layer graphics if used.  Is set by bgInit if bgId is valid"]
    pub fontBgGfx: *mut u16_,
    #[doc = "< Map base set by console init based on background setup"]
    pub mapBase: u8_,
    #[doc = "< Tile graphics base set by console init based on background setup"]
    pub gfxBase: u8_,
    #[doc = "< Bg layer used by the background"]
    pub bgLayer: u8_,
    #[doc = "< bgId, should be set with a call to bgInit() or bgInitSub()"]
    pub bgId: ::libc::c_int,
    #[doc = "< Current X location of the cursor (as a tile offset by default)"]
    pub cursorX: ::libc::c_int,
    #[doc = "< Current Y location of the cursor (as a tile offset by default)"]
    pub cursorY: ::libc::c_int,
    #[doc = "< Internal state"]
    pub prevCursorX: ::libc::c_int,
    #[doc = "< Internal state"]
    pub prevCursorY: ::libc::c_int,
    #[doc = "< Width of the console hardware layer in tiles"]
    pub consoleWidth: ::libc::c_int,
    #[doc = "< Height of the console hardware layer in tiles"]
    pub consoleHeight: ::libc::c_int,
    #[doc = "< Window X location in tiles (not implemented)"]
    pub windowX: ::libc::c_int,
    #[doc = "< Window Y location in tiles (not implemented)"]
    pub windowY: ::libc::c_int,
    #[doc = "< Window width in tiles (not implemented)"]
    pub windowWidth: ::libc::c_int,
    #[doc = "< Window height in tiles (not implemented)"]
    pub windowHeight: ::libc::c_int,
    #[doc = "< Size of a tab"]
    pub tabSize: ::libc::c_int,
    #[doc = "< Offset to the first graphics tile in background memory (in case your font is not loaded at a graphics base boundary)"]
    pub fontCharOffset: u16_,
    #[doc = "< The current palette used by the engine (only applies to 4bpp text backgrounds)"]
    pub fontCurPal: u16_,
    #[doc = "< callback for printing a character. Should return true if it has handled rendering the graphics\n(else the print engine will attempt to render via tiles)"]
    pub PrintChar: ConsolePrint,
    #[doc = "< True if the console is initialized"]
    pub consoleInitialised: bool,
    #[doc = "< True if consoleInit should attempt to load font graphics into background memory"]
    pub loadGraphics: bool,
}
impl Default for PrintConsole {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "!< swallows prints to stderr"]
pub const DebugDevice_NULL: DebugDevice = 0;
#[doc = "!< Directs stderr debug statements to no$gba debug window"]
pub const DebugDevice_NOCASH: DebugDevice = 1;
#[doc = "!< Directs stderr debug statements to DS console window"]
pub const DebugDevice_CONSOLE: DebugDevice = 2;
#[doc = "! Console debug devices supported by libnds."]
pub type DebugDevice = ::libc::c_uint;
extern "C" {
    #[doc = "\t\\brief Loads the font into the console\n\\param console pointer to the console to update, if NULL it will update the current console\n\\param font the font to load"]
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    #[doc = "\t\\brief Sets the print window\n\\param console console to set, if NULL it will set the current console window\n\\param x x location of the window\n\\param y y location of the window\n\\param width width of the window\n\\param height height of the window"]
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ::libc::c_int,
        y: ::libc::c_int,
        width: ::libc::c_int,
        height: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief Gets a pointer to the console with the default values\nthis should only be used when using a single console or without changing the console that is returned, other wise use consoleInit()\n\\return A pointer to the console with the default values"]
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    #[doc = "\t\\brief Make the specified console the render target\n\\param console A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)\n\\return a pointer to the previous console"]
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "\t\\brief Initialise the console.\n\\param console A pointer to the console data to initialze (if it's NULL, the default console will be used)\n\\param layer background layer to use\n\\param type the type of the background\n\\param size the size of the background\n\\param mapBase the map base\n\\param tileBase the tile graphics base\n\\param mainDisplay if true main engine is used, otherwise false\n\\param loadGraphics if true the default font graphics will be loaded into the layer\n\\return A pointer to the current console."]
    pub fn consoleInit(
        console: *mut PrintConsole,
        layer: ::libc::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::libc::c_int,
        tileBase: ::libc::c_int,
        mainDisplay: bool,
        loadGraphics: bool,
    ) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "\t\\brief Initialize the console to a default state for prototyping.\nThis function sets the console to use sub display, VRAM_C, and BG0 and enables MODE_0_2D on the\nsub display.  It is intended for use in prototyping applications which need print ability and not actual\ngame use.  Print functionality can be utilized with just this call.\n\\return A pointer to the current PrintConsole."]
    pub fn consoleDemoInit() -> *mut PrintConsole;
}
extern "C" {
    #[doc = "! Clears the screan by using iprintf(\"\\x1b[2J\");"]
    pub fn consoleClear();
}
extern "C" {
    #[doc = "\t\\brief Initializes debug console output on stderr to the specified device\n\\param device The debug device (or devices) to output debug print statements to"]
    pub fn consoleDebugInit(device: DebugDevice);
}
#[doc = "!< LZ77 decompression."]
pub const LZ77: DecompressType = 0;
#[doc = "!< vram safe LZ77 decompression."]
pub const LZ77Vram: DecompressType = 1;
#[doc = "!< vram safe huff decompression."]
pub const HUFF: DecompressType = 2;
#[doc = "!< run length encoded decompression."]
pub const RLE: DecompressType = 3;
#[doc = "!< vram safe run length encoded decompression."]
pub const RLEVram: DecompressType = 4;
#[doc = "! the types of decompression available."]
pub type DecompressType = ::libc::c_uint;
extern "C" {
    #[doc = "\\brief decompresses data using the suported type\n\\param dst the destination to decompress to\n\\param data the data to decompress\n\\param type the type of data to decompress"]
    pub fn decompress(data: *const ::libc::c_void, dst: *mut ::libc::c_void, type_: DecompressType);
}
extern "C" {
    #[doc = "\\brief decompresses data using the suported type (only LZ77Vram, HUFF, and RLEVram support streaming)\n\\param dst the destination to decompress to.\n\\param data the data to decompress.\n\\param type the type of data to decompress.\n\\param readCB a callback to read the next byte of data.\n\\param getHeaderCB a callback to read the 32 byte header."]
    pub fn decompressStream(
        data: *const ::libc::c_void,
        dst: *mut ::libc::c_void,
        type_: DecompressType,
        readCB: getByteCallback,
        getHeaderCB: getHeaderCallback,
    );
}
extern "C" {
    pub static mut exceptionC: [VoidFn; 0usize];
}
extern "C" {
    pub static mut exceptionStack: u32_;
}
extern "C" {
    #[doc = "! an array with a copy of all the registers of when the exception occured."]
    pub static mut exceptionRegisters: [s32; 0usize];
}
extern "C" {
    pub fn enterException();
}
extern "C" {
    #[doc = "! sets a custom hardware exception handler."]
    pub fn setExceptionHandler(handler: VoidFn);
}
extern "C" {
    #[doc = "! sets the default hardware exception handler."]
    pub fn defaultExceptionHandler();
}
extern "C" {
    #[doc = "! returns the cpu status register."]
    pub fn getCPSR() -> u32_;
}
extern "C" {
    #[doc = " \\fn bool guitarGripIsInserted()\n\\brief Check for the guitar grip\n\\return true if that's what is in the slot-2"]
    pub fn guitarGripIsInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void guitarGripScanKeys()\n\\brief Obtain the current guitar grip state.\nCall this function once per main loop to use the guitarGrip functions."]
    pub fn guitarGripScanKeys();
}
extern "C" {
    #[doc = "! Obtains the current guitar grip keys held state"]
    pub fn guitarGripKeysHeld() -> u8_;
}
extern "C" {
    #[doc = "! Obtains the current guitar grip keys pressed state"]
    pub fn guitarGripKeysDown() -> u16_;
}
extern "C" {
    #[doc = "! Obtains the current guitar grip keys released state"]
    pub fn guitarGripKeysUp() -> u16_;
}
#[doc = "!\t\\brief holds a red green blue triplet"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RGB_24 {
    #[doc = "!< 8 bits for the red value."]
    pub r: ::libc::c_uchar,
    #[doc = "!< 8 bits for the green value."]
    pub g: ::libc::c_uchar,
    #[doc = "!< 8 bits for the blue value."]
    pub b: ::libc::c_uchar,
}
#[doc = "!\tA generic image structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sImage {
    #[doc = "< \\brief The height of the image in pixels"]
    pub height: ::libc::c_short,
    #[doc = "< \\brief The width of the image in pixels"]
    pub width: ::libc::c_short,
    #[doc = "< \\brief Bits per pixel (should be 4 8 16 or 24)"]
    pub bpp: ::libc::c_int,
    #[doc = "< \\brief A pointer to the palette data"]
    pub palette: *mut ::libc::c_ushort,
    pub image: sImage__bindgen_ty_1,
}
#[doc = "! A union of data pointers to the pixel data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union sImage__bindgen_ty_1 {
    #[doc = "!< pointer to 8 bit data."]
    pub data8: *mut u8_,
    #[doc = "!< pointer to 16 bit data."]
    pub data16: *mut u16_,
    #[doc = "!< pointer to 32 bit data."]
    pub data32: *mut u32_,
}
impl Default for sImage__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sImage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "!\tA generic image structure."]
pub type psImage = *mut sImage;
extern "C" {
    #[doc = " \\brief Destructively converts a 24-bit image to 16-bit\n\\param img a pointer to image to manipulate"]
    pub fn image24to16(img: *mut sImage);
}
extern "C" {
    #[doc = " \\brief Destructively converts an 8-bit image to 16 bit setting the alpha bit\n\\param img a pointer to image to manipulate"]
    pub fn image8to16(img: *mut sImage);
}
extern "C" {
    #[doc = " \\brief Destructively converts an 8-bit image to 16-bit with alpha bit cleared for the supplied palette index\n\\param img a pointer to image to manipulate\n\\param transparentColor Color indexes equal to this value will have the alpha bit clear"]
    pub fn image8to16trans(img: *mut sImage, transparentColor: u8_);
}
extern "C" {
    #[doc = " \\brief frees the image data. Only call if the image data was returned from an image loader\n\\param img a pointer to image to manipulate (the image data will be free() )"]
    pub fn imageDestroy(img: *mut sImage);
}
extern "C" {
    #[doc = " \\brief Tiles 8-bit image data into a sequence of 8x8 tiles\n\\param img a pointer to image to manipulate"]
    pub fn imageTileData(img: *mut sImage);
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PCXHeader {
    pub manufacturer: ::libc::c_char,
    pub version: ::libc::c_char,
    pub encoding: ::libc::c_char,
    pub bitsPerPixel: ::libc::c_char,
    pub xmin: ::libc::c_short,
    pub ymin: ::libc::c_short,
    pub xmax: ::libc::c_short,
    pub ymax: ::libc::c_short,
    pub hres: ::libc::c_short,
    pub vres: ::libc::c_short,
    pub palette16: [::libc::c_char; 48usize],
    pub reserved: ::libc::c_char,
    pub colorPlanes: ::libc::c_char,
    pub bytesPerLine: ::libc::c_short,
    pub paletteYype: ::libc::c_short,
    pub filler: [::libc::c_char; 58usize],
}
impl Default for PCXHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pPCXHeader = *mut PCXHeader;
extern "C" {
    #[doc = " \\brief Loads an image structure with data from PCX formatted data\n\\param pcx a pointer to the pcx file loaded into memory\n\\param image the image structure to fill in (the loader will allocate room for the palette and pixel data)\n\\return 1 on success, 0 on failure"]
    pub fn loadPCX(pcx: *const ::libc::c_uchar, image: *mut sImage) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Obtains the current keypad state.\nCall this function once per main loop in order to use the keypad functions."]
    pub fn scanKeys();
}
extern "C" {
    #[doc = "\t\\brief Obtains the current keypad state.\nCall this function to get keypad state without affecting state of other key functions (keysUp keysHeld etc...)"]
    pub fn keysCurrent() -> uint32;
}
extern "C" {
    #[doc = "!\tObtains the current keypad held state."]
    pub fn keysHeld() -> uint32;
}
extern "C" {
    #[doc = "!\tObtains the current keypad pressed state."]
    pub fn keysDown() -> uint32;
}
extern "C" {
    #[doc = "!\tObtains the current keypad pressed or repeating state."]
    pub fn keysDownRepeat() -> uint32;
}
extern "C" {
    #[doc = "\t\\brief Sets the key repeat parameters.\n\\param setDelay Number of %scanKeys calls before keys start to repeat.\n\\param setRepeat Number of %scanKeys calls before keys repeat."]
    pub fn keysSetRepeat(setDelay: u8_, setRepeat: u8_);
}
extern "C" {
    #[doc = "! Obtains the current keypad released state."]
    pub fn keysUp() -> uint32;
}
extern "C" {
    pub fn touchReadXY() -> touchPosition;
}
extern "C" {
    #[doc = "\\brief Obtains the current touchpad state.\n\\param data a touchPosition ptr which will be filled by the function."]
    pub fn touchRead(data: *mut touchPosition);
}
#[doc = "!callback function pointer for a key changed."]
pub type KeyChangeCallback = ::core::option::Option<unsafe extern "C" fn(key: ::libc::c_int)>;
#[doc = "< Normal keyboard display (lowercase letters)"]
pub const Lower: KeyboardState = 0;
#[doc = "< Caps lock Held"]
pub const Upper: KeyboardState = 1;
#[doc = "< Numeric only keypad (not provided by the default keyboard)"]
pub const Numeric: KeyboardState = 2;
#[doc = "< Reduced footprint keyboard (not provided by the default keyboard)"]
pub const Reduced: KeyboardState = 3;
#[doc = "! States the keyboard can be in, currently only Lower and Upper supported."]
pub type KeyboardState = ::libc::c_uint;
#[doc = "! defines a key mapping."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KeyMap {
    #[doc = "< the map for keys pressed"]
    pub mapDataPressed: *const u16_,
    #[doc = "< the map for keys released"]
    pub mapDataReleased: *const u16_,
    #[doc = "< the lookup table for x y grid location to corresponding key"]
    pub keymap: *const ::libc::c_int,
    #[doc = "< width of the keyboard in grid spaces"]
    pub width: ::libc::c_int,
    #[doc = "< height of the keyboard in grid spaces"]
    pub height: ::libc::c_int,
}
impl Default for KeyMap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! describes a keyboard."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Keyboard {
    #[doc = "< Background number to use, after init() this contains the background ID"]
    pub background: ::libc::c_int,
    #[doc = "< boolean to determine if keyboard is on sub screen or main"]
    pub keyboardOnSub: ::libc::c_int,
    #[doc = "< x offset of the map, can be used to center a custom keyboard"]
    pub offset_x: ::libc::c_int,
    #[doc = "< y offset of the map, can be used to center a custom keyboard"]
    pub offset_y: ::libc::c_int,
    #[doc = "< the grid width, this size will be used to translate x coordinate of touch to x coordinate in keymap"]
    pub grid_width: ::libc::c_int,
    #[doc = "< the grid height, this size will be used to translate y coordinate of touch to y coordinate in keymap"]
    pub grid_height: ::libc::c_int,
    #[doc = "< the state of the keyboard"]
    pub state: KeyboardState,
    #[doc = "< true if shifted"]
    pub shifted: ::libc::c_int,
    #[doc = "< true if visible"]
    pub visible: ::libc::c_int,
    #[doc = "!< array of 4 keymap pointers, one for every keyboard state."]
    pub mappings: [*mut KeyMap; 4usize],
    #[doc = "< pointer to graphics tiles, cannot exceed 44KB with default base"]
    pub tiles: *const u16_,
    #[doc = "< length in bytes of graphics data"]
    pub tileLen: u32_,
    #[doc = "< pointer to the palette"]
    pub palette: *const u16_,
    #[doc = "< length in bytes of the palette data"]
    pub paletteLen: u32_,
    #[doc = "< map base to be used by the keyboard"]
    pub mapBase: ::libc::c_int,
    #[doc = "< tile base to be used by keyboard graphics"]
    pub tileBase: ::libc::c_int,
    #[doc = "< tile offset (in bytes) to load graphics (map must be preadjusted)"]
    pub tileOffset: ::libc::c_int,
    #[doc = "<keyboard scroll speed on hide and show in pixels per frame (must be positive and 0 == instant on)"]
    pub scrollSpeed: u32_,
    #[doc = "< will be called on key press"]
    pub OnKeyPressed: KeyChangeCallback,
    #[doc = "< will be called on key release"]
    pub OnKeyReleased: KeyChangeCallback,
}
impl Default for Keyboard {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "!< will be returned if no key was pressed."]
pub const NOKEY: Keys = -1;
#[doc = "!< will be returned if the fold key was pressed (topleft on the default keyboard)."]
pub const DVK_FOLD: Keys = -23;
#[doc = "!< will be returned if the tab key was pressed."]
pub const DVK_TAB: Keys = 9;
#[doc = "!< will be returned if the backspace key was pressed."]
pub const DVK_BACKSPACE: Keys = 8;
#[doc = "!< will be returned if the caps key was pressed."]
pub const DVK_CAPS: Keys = -15;
#[doc = "!< will be returned if the shift key was pressed."]
pub const DVK_SHIFT: Keys = -14;
#[doc = "!< will be returned if the space key was pressed."]
pub const DVK_SPACE: Keys = 32;
#[doc = "!< will be returned if the menu key was pressed."]
pub const DVK_MENU: Keys = -5;
#[doc = "!< will be returned if the enter key was pressed."]
pub const DVK_ENTER: Keys = 10;
#[doc = "!< will be returned if the ctrl key was pressed."]
pub const DVK_CTRL: Keys = -16;
#[doc = "!< will be returned if the up key was pressed."]
pub const DVK_UP: Keys = -17;
#[doc = "!< will be returned if the right key was pressed."]
pub const DVK_RIGHT: Keys = -18;
#[doc = "!< will be returned if the down key was pressed."]
pub const DVK_DOWN: Keys = -19;
#[doc = "!< will be returned if the left key was pressed."]
pub const DVK_LEFT: Keys = -20;
#[doc = "!< will be returned if the alt key was pressed."]
pub const DVK_ALT: Keys = -26;
#[doc = "\t\\brief enum values for the keyboard control keys.\nnegative values are keys with no sensible ascii representation.\nnumbers are chosen to mimic ascii control sequences."]
pub type Keys = ::libc::c_int;
extern "C" {
    #[doc = "! Gets the default keyboard."]
    pub fn keyboardGetDefault() -> *mut Keyboard;
}
extern "C" {
    #[doc = "\t\\brief initializes the keyboard system with the supplied keyboard\n\\param keyboard the keyboard struct to initialize (can be NULL)\n\\param layer the background layer to use\n\\param type the background type to initialize\n\\param size the background size to initialize\n\\param mapBase the map base to use for the background\n\\param tileBase the graphics tile base to use for the background\n\\param mainDisplay if true the keyboard will render on the main display\n\\param loadGraphics if true the keyboard graphics will be loaded\n\\return returns the initialized keyboard struct"]
    pub fn keyboardInit(
        keyboard: *mut Keyboard,
        layer: ::libc::c_int,
        type_: BgType,
        size: BgSize,
        mapBase: ::libc::c_int,
        tileBase: ::libc::c_int,
        mainDisplay: bool,
        loadGraphics: bool,
    ) -> *mut Keyboard;
}
extern "C" {
    #[doc = "\t\\brief initializes the keyboard with default options.\nSame as calling keyboardInit(NULL, 3, BgType_Text4bpp, BgSize_T_256x512, 20, 0, false, true)\n\\return a pointer to the current keyboard."]
    pub fn keyboardDemoInit() -> *mut Keyboard;
}
extern "C" {
    #[doc = "\t\\brief Displays the keyboard."]
    pub fn keyboardShow();
}
extern "C" {
    #[doc = "\t\\brief Hides the keyboard"]
    pub fn keyboardHide();
}
extern "C" {
    #[doc = "\t\\brief returns the ascii code for the key located at the supplied x and y.\nWill not effect keyboard shift state.\n\\param x the pixel x location\n\\param y the pixel y location\n\\return the key pressed or NOKEY if user pressed outside the keypad"]
    pub fn keyboardGetKey(x: ::libc::c_int, y: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief reads the input until a the return key is pressed or the maxLen is exceeded.\n\\param buffer a buffer to hold the input string\n\\param maxLen the maximum length to read"]
    pub fn keyboardGetString(buffer: *mut ::libc::c_char, maxLen: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Waits for user to press a key and returns the key pressed.\nUse keyboardUpdate instead for async operation."]
    pub fn keyboardGetChar() -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Processes the keyboard.\nShould be called once per frame when using the keyboard in an async manner.\n\\return the ascii code of the key pressed or -1 if no key was pressed."]
    pub fn keyboardUpdate() -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\fn bool paddleIsInserted()\n\\brief Check for the paddle\n\\return true if that's what is in the slot-2"]
    pub fn paddleIsInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void paddleRead()\n\\brief Obtain the current paddle state\n\\return a u16 containing a 12bit number (fixed point fraction), incrementing for clockwise rotations and decrementing for counterclockwise"]
    pub fn paddleRead() -> u16_;
}
extern "C" {
    #[doc = "! Resets the paddle device. May change the current value to 0xFFF, 0x000, or 0x001. May perform other unknown internal reset operations. Normally not needed."]
    pub fn paddleReset();
}
extern "C" {
    #[doc = " \\fn bool pianoIsInserted()\n\\brief Check for piano option pack.\n\\return true if the cart in the GBA slot is the piano option pack."]
    pub fn pianoIsInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void pianoScanKeys()\n\\brief Obtain the current piano state.\nCall this function once per main loop to use the piano functions."]
    pub fn pianoScanKeys();
}
extern "C" {
    #[doc = "! Obtains the current piano keys held state"]
    pub fn pianoKeysHeld() -> u16_;
}
extern "C" {
    #[doc = "! Obtains the current piano keys pressed state"]
    pub fn pianoKeysDown() -> u16_;
}
extern "C" {
    #[doc = "! Obtains the current piano keys released state"]
    pub fn pianoKeysUp() -> u16_;
}
pub const RUMBLE: RUMBLE_TYPE = 0;
pub const WARIOWARE: RUMBLE_TYPE = 1;
pub type RUMBLE_TYPE = ::libc::c_uint;
extern "C" {
    #[doc = " \\fn bool isRumbleInserted(void);\n\\brief Check for rumble option pak.\n\\return true if the cart in the GBA slot is a Rumble option pak."]
    pub fn isRumbleInserted() -> bool;
}
extern "C" {
    #[doc = " \\fn void setRumble(bool position);\n\\param position Alternates position of the actuator in the pak\n\\brief Fires the rumble actuator."]
    pub fn setRumble(position: bool);
}
pub type MicCallback = ::core::option::Option<
    unsafe extern "C" fn(completedBuffer: *mut ::libc::c_void, length: ::libc::c_int),
>;
#[doc = "<  16-bit PCM"]
pub const SoundFormat_16Bit: SoundFormat = 1;
#[doc = "<  8-bit PCM"]
pub const SoundFormat_8Bit: SoundFormat = 0;
#[doc = "<  PSG (programmable sound generator?)"]
pub const SoundFormat_PSG: SoundFormat = 3;
#[doc = "<  IMA ADPCM compressed audio"]
pub const SoundFormat_ADPCM: SoundFormat = 2;
#[doc = " \\brief Sound formats used by the DS"]
pub type SoundFormat = ::libc::c_uint;
#[doc = "<  8-bit PCM"]
pub const MicFormat_8Bit: MicFormat = 1;
#[doc = "<  12-bit PCM"]
pub const MicFormat_12Bit: MicFormat = 0;
#[doc = " \\brief Microphone recording formats DS"]
pub type MicFormat = ::libc::c_uint;
#[doc = "<  0.0% duty cycle"]
pub const DutyCycle_0: DutyCycle = 7;
#[doc = "<  12.5% duty cycle"]
pub const DutyCycle_12: DutyCycle = 0;
#[doc = "<  25.0% duty cycle"]
pub const DutyCycle_25: DutyCycle = 1;
#[doc = "<  37.5% duty cycle"]
pub const DutyCycle_37: DutyCycle = 2;
#[doc = "<  50.0% duty cycle"]
pub const DutyCycle_50: DutyCycle = 3;
#[doc = "<  62.5% duty cycle"]
pub const DutyCycle_62: DutyCycle = 4;
#[doc = "<  75.0% duty cycle"]
pub const DutyCycle_75: DutyCycle = 5;
#[doc = "<  87.5% duty cycle"]
pub const DutyCycle_87: DutyCycle = 6;
#[doc = " \\brief PSG Duty cycles used by the PSG hardware"]
pub type DutyCycle = ::libc::c_uint;
extern "C" {
    #[doc = " \\fn void soundEnable(void)\n\\brief Enables Sound on the DS.  Should be called prior to\nattempting sound playback"]
    pub fn soundEnable();
}
extern "C" {
    #[doc = " \\fn void soundDisable(void)\n\\brief Disables Sound on the DS."]
    pub fn soundDisable();
}
extern "C" {
    #[doc = " \\fn int soundPlaySample(const void* data, SoundFormat format, u32 dataSize, u16 freq, u8 volume, u8 pan, bool loop, u16 loopPoint);\n\\brief Plays a sound in the specified format at the specified frequency.\n\n\\param data A pointer to the sound data\n\\param format The format of the data (only 16-bit and 8-bit pcm and ADPCM formats are supported by this function)\n\\param dataSize The size in bytes of the sound data\n\\param freq The frequency in Hz of the sample\n\\param volume The channel volume.  0 to 127 (min to max)\n\\param pan The channel pan 0 to 127 (left to right with 64 being centered)\n\\param loop If true, the sample will loop playing once then repeating starting at the offset stored in loopPoint\n\\param loopPoint The offset for the sample loop to restart when repeating\n\\return An integer id coresponding to the channel of playback.  This value can be used to pause, resume, or kill the sound\nas well as adjust volume, pan, and frequency"]
    pub fn soundPlaySample(
        data: *const ::libc::c_void,
        format: SoundFormat,
        dataSize: u32_,
        freq: u16_,
        volume: u8_,
        pan: u8_,
        loop_: bool,
        loopPoint: u16_,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\fn int soundPlayPSG(DutyCycle cycle, u16 freq, u8 volume, u8 pan);\n\\brief Pause a tone with the specified properties\n\\param cycle The DutyCycle of the sound wave\n\\param freq The frequency in Hz of the sample\n\\param volume The channel volume.  0 to 127 (min to max)\n\\param pan The channel pan 0 to 127 (left to right with 64 being centered)\n\\return An integer id coresponding to the channel of playback.  This value can be used to pause, resume, or kill the sound\nas well as adjust volume, pan, and frequency"]
    pub fn soundPlayPSG(cycle: DutyCycle, freq: u16_, volume: u8_, pan: u8_) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\fn int soundPlayNoise(u16 freq, u8 volume, u8 pan);\n\\brief Plays white noise with the specified parameters\n\\param freq The frequency in Hz of the sample\n\\param volume The channel volume.  0 to 127 (min to max)\n\\param pan The channel pan 0 to 127 (left to right with 64 being centered)\n\\return An integer id coresponding to the channel of playback.  This value can be used to pause, resume, or kill the sound\nas well as adjust volume, pan, and frequency"]
    pub fn soundPlayNoise(freq: u16_, volume: u8_, pan: u8_) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\fn void soundPause(int soundId)\n\\brief Pause the sound specified by soundId\n\\param soundId The sound ID returned by play sound"]
    pub fn soundPause(soundId: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn void soundSetWaveDuty(int soundId, DutyCycle cycle)\n\\brief Sets the Wave Duty of a PSG sound\n\\param soundId The sound ID returned by play sound\n\\param cycle The DutyCycle of the sound wave"]
    pub fn soundSetWaveDuty(soundId: ::libc::c_int, cycle: DutyCycle);
}
extern "C" {
    #[doc = " \\fn void soundKill(int soundId)\n\\brief Stops the sound specified by soundId and frees any resources allocated\n\\param soundId The sound ID returned by play sound"]
    pub fn soundKill(soundId: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn void soundResume(int soundId)\n\\brief Resumes a paused sound\n\\param soundId The sound ID returned by play sound"]
    pub fn soundResume(soundId: ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn void soundSetVolume(int soundId, u8 volume)\n\\brief Sets the sound volume\n\\param soundId The sound ID returned by play sound\n\\param volume The new volume (0 to 127 min to max)"]
    pub fn soundSetVolume(soundId: ::libc::c_int, volume: u8_);
}
extern "C" {
    #[doc = " \\fn void soundSetPan(int soundId, u8 pan)\n\\brief Sets the sound pan\n\\param soundId The sound ID returned by play sound\n\\param pan The new pan value (0 to 127 left to right (64 = center))"]
    pub fn soundSetPan(soundId: ::libc::c_int, pan: u8_);
}
extern "C" {
    #[doc = " \\fn void soundSetFreq(int soundId, u16 freq)\n\\brief Sets the sound frequency\n\\param soundId The sound ID returned by play sound\n\\param freq The frequency in Hz"]
    pub fn soundSetFreq(soundId: ::libc::c_int, freq: u16_);
}
extern "C" {
    #[doc = " \\fn int soundMicRecord(void *buffer, u32 bufferLength, MicFormat format, int freq, MicCallback callback);\n\n\\brief Starts a microphone recording to a double buffer specified by buffer\n\\param buffer A pointer to the start of the double buffer\n\\param bufferLength The length of the buffer in bytes (both halfs of the double buffer)\n\\param format Microphone can record in 8 or 12 bit format.  12 bit is shifted up to 16 bit pcm\n\\param freq The sample frequency\n\\param callback This will be called every time the buffer is full or half full\n\n\\return Returns non zero for success."]
    pub fn soundMicRecord(
        buffer: *mut ::libc::c_void,
        bufferLength: u32_,
        format: MicFormat,
        freq: ::libc::c_int,
        callback: MicCallback,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\fn void soundMicOff(void)\n\\brief Stops the microphone from recording"]
    pub fn soundMicOff();
}
#[doc = "< No special mode is on - Normal sprite state."]
pub const OBJMODE_NORMAL: ObjBlendMode = 0;
#[doc = "< Color blending is on - Sprite can use HW blending features."]
pub const OBJMODE_BLENDED: ObjBlendMode = 1;
#[doc = "< Sprite can be seen only inside the sprite window."]
pub const OBJMODE_WINDOWED: ObjBlendMode = 2;
#[doc = "< Sprite is not using tiles - per pixel image data."]
pub const OBJMODE_BITMAP: ObjBlendMode = 3;
#[doc = " \\brief The blending mode of the sprite"]
pub type ObjBlendMode = ::libc::c_uint;
#[doc = "< Sprite shape is NxN (Height == Width)."]
pub const OBJSHAPE_SQUARE: ObjShape = 0;
#[doc = "< Sprite shape is NxM with N > M (Height < Width)."]
pub const OBJSHAPE_WIDE: ObjShape = 1;
#[doc = "< Sprite shape is NxM with N < M (Height > Width)."]
pub const OBJSHAPE_TALL: ObjShape = 2;
#[doc = "< Sprite shape is undefined."]
pub const OBJSHAPE_FORBIDDEN: ObjShape = 3;
#[doc = " \\brief The shape of the sprite"]
pub type ObjShape = ::libc::c_uint;
#[doc = "< Major sprite size is 8px."]
pub const OBJSIZE_8: ObjSize = 0;
#[doc = "< Major sprite size is 16px."]
pub const OBJSIZE_16: ObjSize = 1;
#[doc = "< Major sprite size is 32px."]
pub const OBJSIZE_32: ObjSize = 2;
#[doc = "< Major sprite size is 64px."]
pub const OBJSIZE_64: ObjSize = 3;
#[doc = " \\brief The size of the sprite"]
pub type ObjSize = ::libc::c_uint;
#[doc = "< sprite has 16 colors."]
pub const OBJCOLOR_16: ObjColMode = 0;
#[doc = "< sprite has 256 colors."]
pub const OBJCOLOR_256: ObjColMode = 1;
#[doc = " \\brief The color mode of the sprite"]
pub type ObjColMode = ::libc::c_uint;
#[doc = "< sprite priority level 0 - highest."]
pub const OBJPRIORITY_0: ObjPriority = 0;
#[doc = "< sprite priority level 1."]
pub const OBJPRIORITY_1: ObjPriority = 1;
#[doc = "< sprite priority level 2."]
pub const OBJPRIORITY_2: ObjPriority = 2;
#[doc = "< sprite priority level 3 - lowest."]
pub const OBJPRIORITY_3: ObjPriority = 3;
#[doc = " \\brief The priority of the sprite"]
pub type ObjPriority = ::libc::c_uint;
#[doc = "! A bitfield of sprite attribute goodness...ugly to look at but not so bad to use."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SpriteEntry {
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1,
    pub __bindgen_anon_2: SpriteEntry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1 {
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SpriteEntry__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: SpriteEntry__bindgen_ty_1__bindgen_ty_3,
    pub attribute3: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn isHidden(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isHidden(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isHidden: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isHidden: u8 = unsafe { ::core::mem::transmute(isHidden) };
            isHidden as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn isRotateScale(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isRotateScale(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isSizeDouble(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isSizeDouble(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blendMode(&self) -> ObjBlendMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_blendMode(&mut self, val: ObjBlendMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn isMosaic(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isMosaic(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colorMode(&self) -> ObjColMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colorMode(&mut self, val: ObjColMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shape(&self) -> ObjShape {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shape(&mut self, val: ObjShape) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isRotateScale: bool,
        isSizeDouble: bool,
        blendMode: ObjBlendMode,
        isMosaic: bool,
        colorMode: ObjColMode,
        shape: ObjShape,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isRotateScale: u8 = unsafe { ::core::mem::transmute(isRotateScale) };
            isRotateScale as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isSizeDouble: u8 = unsafe { ::core::mem::transmute(isSizeDouble) };
            isSizeDouble as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let blendMode: u32 = unsafe { ::core::mem::transmute(blendMode) };
            blendMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isMosaic: u8 = unsafe { ::core::mem::transmute(isMosaic) };
            isMosaic as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let colorMode: u32 = unsafe { ::core::mem::transmute(colorMode) };
            colorMode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let shape: u32 = unsafe { ::core::mem::transmute(shape) };
            shape as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn y(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_y(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(y: u16_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let y: u16 = unsafe { ::core::mem::transmute(y) };
            y as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SpriteEntry__bindgen_ty_1__bindgen_ty_2 {
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn x(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_x(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(x: u16_) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let x: u16 = unsafe { ::core::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1: SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1:
        SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2:
        SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn hFlip(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hFlip(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vFlip(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vFlip(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(hFlip: bool, vFlip: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hFlip: u8 = unsafe { ::core::mem::transmute(hFlip) };
            hFlip as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let vFlip: u8 = unsafe { ::core::mem::transmute(vFlip) };
            vFlip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn rotationIndex(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rotationIndex(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> ObjSize {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: ObjSize) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rotationIndex: u8_,
        size: ObjSize,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let rotationIndex: u8 = unsafe { ::core::mem::transmute(rotationIndex) };
            rotationIndex as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl Default for SpriteEntry__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl SpriteEntry__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn gfxIndex(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_gfxIndex(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn priority(&self) -> ObjPriority {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ObjPriority) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn palette(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_palette(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gfxIndex: u16_,
        priority: ObjPriority,
        palette: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let gfxIndex: u16 = unsafe { ::core::mem::transmute(gfxIndex) };
            gfxIndex as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let priority: u32 = unsafe { ::core::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let palette: u8 = unsafe { ::core::mem::transmute(palette) };
            palette as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for SpriteEntry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SpriteEntry__bindgen_ty_2 {
    pub attribute: [uint16; 3usize],
    pub filler: uint16,
}
impl Default for SpriteEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! A bitfield of sprite attribute goodness...ugly to look at but not so bad to use."]
pub type pSpriteEntry = *mut SpriteEntry;
#[doc = "! A sprite rotation entry."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SpriteRotation {
    pub filler1: [uint16; 3usize],
    #[doc = "< The change in x per horizontal pixel"]
    pub hdx: int16,
    pub filler2: [uint16; 3usize],
    #[doc = "< The change in y per horizontal pixel"]
    pub vdx: int16,
    pub filler3: [uint16; 3usize],
    #[doc = "< The change in x per vertical pixel"]
    pub hdy: int16,
    pub filler4: [uint16; 3usize],
    #[doc = "< The change in y per vertical pixel"]
    pub vdy: int16,
}
#[doc = "! A sprite rotation entry."]
pub type pSpriteRotation = *mut SpriteRotation;
#[repr(C)]
#[derive(Copy, Clone)]
pub union OAMTable {
    pub oamBuffer: [SpriteEntry; 128usize],
    pub matrixBuffer: [SpriteRotation; 32usize],
}
impl Default for OAMTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "!< 8x8"]
pub const SpriteSize_8x8: SpriteSize = 2;
#[doc = "!< 16x16"]
pub const SpriteSize_16x16: SpriteSize = 16392;
#[doc = "!< 32x32"]
pub const SpriteSize_32x32: SpriteSize = 32800;
#[doc = "!< 64x64"]
pub const SpriteSize_64x64: SpriteSize = 49280;
#[doc = "!< 16x8"]
pub const SpriteSize_16x8: SpriteSize = 4100;
#[doc = "!< 32x8"]
pub const SpriteSize_32x8: SpriteSize = 20488;
#[doc = "!< 32x16"]
pub const SpriteSize_32x16: SpriteSize = 36880;
#[doc = "!< 64x32"]
pub const SpriteSize_64x32: SpriteSize = 53312;
#[doc = "!< 8x16"]
pub const SpriteSize_8x16: SpriteSize = 8196;
#[doc = "!< 8x32"]
pub const SpriteSize_8x32: SpriteSize = 24584;
#[doc = "!< 16x32"]
pub const SpriteSize_16x32: SpriteSize = 40976;
#[doc = "!< 32x64"]
pub const SpriteSize_32x64: SpriteSize = 57408;
#[doc = "! Enumerates all sizes supported by the 2D engine."]
pub type SpriteSize = ::libc::c_uint;
#[doc = "< 1D tile mapping 32 byte boundary between offset"]
pub const SpriteMapping_1D_32: SpriteMapping = 16;
#[doc = "< 1D tile mapping 64 byte boundary between offset"]
pub const SpriteMapping_1D_64: SpriteMapping = 269484049;
#[doc = "< 1D tile mapping 128 byte boundary between offset"]
pub const SpriteMapping_1D_128: SpriteMapping = 538968082;
#[doc = "< 1D tile mapping 256 byte boundary between offset"]
pub const SpriteMapping_1D_256: SpriteMapping = 808452115;
#[doc = "< 2D tile mapping 32 byte boundary between offset"]
pub const SpriteMapping_2D: SpriteMapping = 1073741824;
#[doc = "< 1D bitmap mapping 128 byte boundary between offset"]
pub const SpriteMapping_Bmp_1D_128: SpriteMapping = 1344274514;
#[doc = "< 1D bitmap mapping 256 byte boundary between offset"]
pub const SpriteMapping_Bmp_1D_256: SpriteMapping = 1617952851;
#[doc = "< 2D bitmap mapping 128 pixels wide bitmap"]
pub const SpriteMapping_Bmp_2D_128: SpriteMapping = 1879048194;
#[doc = "< 2D bitmap mapping 256 pixels wide bitmap"]
pub const SpriteMapping_Bmp_2D_256: SpriteMapping = -2147483613;
#[doc = "! Graphics memory layout options."]
pub type SpriteMapping = ::libc::c_int;
#[doc = "< 16 colors per sprite"]
pub const SpriteColorFormat_16Color: SpriteColorFormat = 0;
#[doc = "< 256 colors per sprite"]
pub const SpriteColorFormat_256Color: SpriteColorFormat = 1;
#[doc = "< 16-bit sprites"]
pub const SpriteColorFormat_Bmp: SpriteColorFormat = 3;
#[doc = "! Color formats for sprite graphics."]
pub type SpriteColorFormat = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AllocHeader {
    pub nextFree: u16_,
    pub size: u16_,
}
#[doc = "\t\\brief Holds the state for a 2D sprite engine.\nThere are two of these objects, oamMain and oamSub and these must be passed in to all oam functions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OamState {
    #[doc = "< The distance between tiles as 2^gfxOffsetStep"]
    pub gfxOffsetStep: ::libc::c_int,
    #[doc = "< pointer to the first free block of tiles"]
    pub firstFree: s16,
    #[doc = "< array, allocation buffer for graphics allocation"]
    pub allocBuffer: *mut AllocHeader,
    #[doc = "< current size of the allocation buffer"]
    pub allocBufferSize: s16,
    pub __bindgen_anon_1: OamState__bindgen_ty_1,
    #[doc = "!< the mapping of the oam."]
    pub spriteMapping: SpriteMapping,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OamState__bindgen_ty_1 {
    #[doc = "< pointer to shadow oam memory"]
    pub oamMemory: *mut SpriteEntry,
    #[doc = "< pointer to shadow oam memory for rotation"]
    pub oamRotationMemory: *mut SpriteRotation,
}
impl Default for OamState__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for OamState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "!oamMain an object representing the main 2D engine"]
    pub static mut oamMain: OamState;
}
extern "C" {
    #[doc = "!oamSub an object representing the sub 2D engine"]
    pub static mut oamSub: OamState;
}
extern "C" {
    #[doc = "    \\brief convert a VRAM address to an oam offset\n    \\param oam must be: &oamMain or &oamSub\n    \\param offset the video memory address of the sprite graphics (not an offset)"]
    pub fn oamGfxPtrToOffset(oam: *mut OamState, offset: *const ::libc::c_void) -> ::libc::c_uint;
}
extern "C" {
    #[doc = "    \\brief Initializes the 2D sprite engine  In order to mix tiled and bitmap sprites\nuse SpriteMapping_Bmp_1D_128 or SpriteMapping_Bmp_1D_256.  This will set mapping for both\nto 1D and give same sized boundaries so the sprite gfx allocation will function.  VBlank IRQ must\nbe enabled for this function to work.\n    \\param oam must be: &oamMain or &oamSub\n    \\param mapping the mapping mode\n    \\param extPalette if true the engine sets up extended palettes for 8bpp sprites"]
    pub fn oamInit(oam: *mut OamState, mapping: SpriteMapping, extPalette: bool);
}
extern "C" {
    #[doc = "    \\brief Disables sprite rendering\n    \\param oam must be: &oamMain or &oamSub"]
    pub fn oamDisable(oam: *mut OamState);
}
extern "C" {
    #[doc = "    \\brief Enables sprite rendering\n    \\param oam must be: &oamMain or &oamSub"]
    pub fn oamEnable(oam: *mut OamState);
}
extern "C" {
    #[doc = "    \\brief translates an oam offset into a video ram address\n    \\param oam must be: &oamMain or &oamSub\n    \\param gfxOffsetIndex the index to compute\n    \\return the address in vram corresponding to the supplied offset"]
    pub fn oamGetGfxPtr(oam: *mut OamState, gfxOffsetIndex: ::libc::c_int) -> *mut u16_;
}
extern "C" {
    #[doc = "    \\brief Allocates graphics memory for the supplied sprite attributes\n    \\param oam must be: &oamMain or &oamSub\n    \\param size the size of the sprite to allocate\n    \\param colorFormat the color format of the sprite\n    \\return the address in vram of the allocated sprite"]
    pub fn oamAllocateGfx(
        oam: *mut OamState,
        size: SpriteSize,
        colorFormat: SpriteColorFormat,
    ) -> *mut u16_;
}
extern "C" {
    #[doc = "    \\brief free vram memory obtained with oamAllocateGfx.\n    \\param oam must be: &oamMain or &oamSub\n    \\param gfxOffset a vram offset obtained from oamAllocateGfx"]
    pub fn oamFreeGfx(oam: *mut OamState, gfxOffset: *const ::libc::c_void);
}
extern "C" {
    #[doc = "    \\brief sets engine A global sprite mosaic\n    \\param dx (0-15) horizontal mosaic value\n    \\param dy (0-15) horizontal mosaic value"]
    #[link_name = "\u{1}oamSetMosaic__extern"]
    pub fn oamSetMosaic(dx: ::libc::c_uint, dy: ::libc::c_uint);
}
extern "C" {
    #[doc = "    \\brief sets engine B global sprite mosaic\n    \\param dx (0-15) horizontal mosaic value\n    \\param dy (0-15) horizontal mosaic value"]
    #[link_name = "\u{1}oamSetMosaicSub__extern"]
    pub fn oamSetMosaicSub(dx: ::libc::c_uint, dy: ::libc::c_uint);
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied values\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0 - 127]\n    \\param x the x location of the sprite in pixels\n    \\param y the y location of the sprite in pixels\n\t \\param priority The sprite priority (0 to 3)\n    \\param palette_alpha the palette number for 4bpp and 8bpp (extended palette mode), or the alpha value for bitmap sprites (bitmap sprites must specify a value > 0 to display) [0-15]\n    \\param size the size of the sprite\n    \\param format the color format of the sprite\n    \\param gfxOffset the video memory address of the sprite graphics (not an offset)\n    \\param affineIndex affine index to use (if < 0 or > 31 the sprite will be unrotated)\n    \\param sizeDouble if affineIndex >= 0 this will be used to double the sprite size for rotation\n    \\param hide if non zero (true) the sprite will be hidden\n    \\param vflip flip the sprite vertically\n    \\param hflip flip the sprite horizontally\n\t \\param mosaic if true mosaic will be applied to the sprite"]
    pub fn oamSet(
        oam: *mut OamState,
        id: ::libc::c_int,
        x: ::libc::c_int,
        y: ::libc::c_int,
        priority: ::libc::c_int,
        palette_alpha: ::libc::c_int,
        size: SpriteSize,
        format: SpriteColorFormat,
        gfxOffset: *const ::libc::c_void,
        affineIndex: ::libc::c_int,
        sizeDouble: bool,
        hide: bool,
        hflip: bool,
        vflip: bool,
        mosaic: bool,
    );
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied x,y position\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param x the x location of the sprite in pixels\n    \\param y the y location of the sprite in pixels"]
    #[link_name = "\u{1}oamSetXY__extern"]
    pub fn oamSetXY(oam: *mut OamState, id: ::libc::c_int, x: ::libc::c_int, y: ::libc::c_int);
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied priority\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param priority The sprite priority [0-3]"]
    #[link_name = "\u{1}oamSetPriority__extern"]
    pub fn oamSetPriority(oam: *mut OamState, id: ::libc::c_int, priority: ::libc::c_int);
}
extern "C" {
    #[doc = "    \\brief sets a paletted oam entry to the supplied palette\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param palette the palette number for 4bpp and 8bpp (extended palette mode) sprites [0-15]"]
    #[link_name = "\u{1}oamSetPalette__extern"]
    pub fn oamSetPalette(oam: *mut OamState, id: ::libc::c_int, palette: ::libc::c_int);
}
extern "C" {
    #[doc = "    \\brief sets a bitmapped oam entry to the supplied transparency\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param alpha the alpha value for bitmap sprites (bitmap sprites must specify a value > 0 to display) [0-15]"]
    #[link_name = "\u{1}oamSetAlpha__extern"]
    pub fn oamSetAlpha(oam: *mut OamState, id: ::libc::c_int, alpha: ::libc::c_int);
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied shape/size/pointer\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param size the size of the sprite\n    \\param format the color format of the sprite\n    \\param gfxOffset the video memory address of the sprite graphics (not an offset)"]
    #[link_name = "\u{1}oamSetGfx__extern"]
    pub fn oamSetGfx(
        oam: *mut OamState,
        id: ::libc::c_int,
        size: SpriteSize,
        format: SpriteColorFormat,
        gfxOffset: *const ::libc::c_void,
    );
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied affine index\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param affineIndex affine index to use (if < 0 or > 31 the sprite will be unrotated)\n    \\param sizeDouble if affineIndex >= 0 and < 32 this will be used to double the sprite size for rotation"]
    #[link_name = "\u{1}oamSetAffineIndex__extern"]
    pub fn oamSetAffineIndex(
        oam: *mut OamState,
        id: ::libc::c_int,
        affineIndex: ::libc::c_int,
        sizeDouble: bool,
    );
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied hidden state\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param hide if non zero (true) the sprite will be hidden"]
    #[link_name = "\u{1}oamSetHidden__extern"]
    pub fn oamSetHidden(oam: *mut OamState, id: ::libc::c_int, hide: bool);
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to the supplied flipping\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param hflip flip the sprite horizontally\n    \\param vflip flip the sprite vertically"]
    #[link_name = "\u{1}oamSetFlip__extern"]
    pub fn oamSetFlip(oam: *mut OamState, id: ::libc::c_int, hflip: bool, vflip: bool);
}
extern "C" {
    #[doc = "    \\brief sets an oam entry to enable or disable mosaic\n    \\param oam must be: &oamMain or &oamSub\n    \\param id the oam number to be set [0-127]\n    \\param mosaic if true mosaic will be applied to the sprite"]
    #[link_name = "\u{1}oamSetMosaicEnabled__extern"]
    pub fn oamSetMosaicEnabled(oam: *mut OamState, id: ::libc::c_int, mosaic: bool);
}
extern "C" {
    #[doc = "    \\brief Hides the sprites in the supplied range: if count is zero all 128 sprites will be hidden\n    \\param oam must be: &oamMain or &oamSub\n    \\param start The first index to clear\n    \\param count The number of sprites to clear"]
    pub fn oamClear(oam: *mut OamState, start: ::libc::c_int, count: ::libc::c_int);
}
extern "C" {
    #[doc = "\\brief Hides a single sprite.\n\n\\param oam      the oam engine, must be &oamMain or &oamSub.\n\\param index    the index of the sprite, must be 0-127."]
    #[link_name = "\u{1}oamClearSprite__extern"]
    pub fn oamClearSprite(oam: *mut OamState, index: ::libc::c_int);
}
extern "C" {
    #[doc = "    \\brief causes oam memory to be updated...must be called during vblank if using oam api\n    \\param oam must be: &oamMain or &oamSub"]
    pub fn oamUpdate(oam: *mut OamState);
}
extern "C" {
    #[doc = "    \\brief sets the specified rotation scale entry\n    \\param oam must be: &oamMain or &oamSub\n    \\param rotId the rotation entry to set\n    \\param angle the ccw angle to rotate [-32768 - 32767]\n    \\param sx the inverse scale factor in the x direction\n    \\param sy the inverse scale factor in the y direction"]
    pub fn oamRotateScale(
        oam: *mut OamState,
        rotId: ::libc::c_int,
        angle: ::libc::c_int,
        sx: ::libc::c_int,
        sy: ::libc::c_int,
    );
}
extern "C" {
    #[doc = " \\brief allows you to directly sets the affine transformation matrix.\n\n with this, you have more freedom to set the matrix, but it might be more difficult to use if\n you're not used to affine transformation matrix. this will erase the previous matrix stored at rotId.\n\n \\param oam\tThe oam engine, must be &oamMain or &oamSub.\n \\param rotId\tThe id of the rotscale item you want to change, must be 0-31.\n \\param hdx\tThe change in x per horizontal pixel.\n \\param hdy\tThe change in y per horizontal pixel.\n \\param vdx\tThe change in x per vertical pixel.\n \\param vdy\tThe change in y per vertical pixel."]
    #[link_name = "\u{1}oamAffineTransformation__extern"]
    pub fn oamAffineTransformation(
        oam: *mut OamState,
        rotId: ::libc::c_int,
        hdx: ::libc::c_int,
        hdy: ::libc::c_int,
        vdx: ::libc::c_int,
        vdy: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\\brief determines the number of fragments in the allocation engine\n\\param oam must be: &oamMain or &oamSub\n\\return the number of fragments."]
    pub fn oamCountFragments(oam: *mut OamState) -> ::libc::c_int;
}
extern "C" {
    pub fn oamAllocReset(oam: *mut OamState);
}
#[doc = "!< Window 0."]
pub const WINDOW_0: WINDOW = 8192;
#[doc = "!< Window 1"]
pub const WINDOW_1: WINDOW = 16384;
#[doc = "!< Object window"]
pub const WINDOW_OBJ: WINDOW = 32768;
#[doc = "!< Area outside all windows"]
pub const WINDOW_OUT: WINDOW = 65536;
#[doc = "\t\\brief the supported windows"]
pub type WINDOW = ::libc::c_uint;
extern "C" {
    #[doc = "    \\brief Enable the specified window(s)\n    \\param window The window to set bounds on (may be ORed together)"]
    #[link_name = "\u{1}windowEnable__extern"]
    pub fn windowEnable(w: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Enable the specified window(s)\n    \\param window The window to set bounds on (may be ORed together)"]
    #[link_name = "\u{1}windowDisable__extern"]
    pub fn windowDisable(w: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Enable the specified window(s)\n    \\param window The window to set bounds on (may be ORed together)"]
    #[link_name = "\u{1}windowEnableSub__extern"]
    pub fn windowEnableSub(w: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Enable the specified window(s)\n    \\param window The window to set bounds on (may be ORed together)"]
    #[link_name = "\u{1}windowDisableSub__extern"]
    pub fn windowDisableSub(w: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Set the windows bounds\n    \\param window The window to set bounds on\n    \\param left The X coordinate of the left hand side of the rectangle\n    \\param top The Y coordinate of the top of the rectangle\n    \\param right The X coordinate of the right hand side of the rectangle\n    \\param bottom The Y coordinate of the bottom of the rectangle"]
    pub fn windowSetBounds(window: WINDOW, left: u8_, top: u8_, right: u8_, bottom: u8_);
}
extern "C" {
    #[doc = "    \\brief Set the windows bounds (Sub engine)\n    \\param window The window to set bounds on\n    \\param left The X coordinate of the left hand side of the rectangle\n    \\param top The Y coordinate of the top of the rectangle\n    \\param right The X coordinate of the right hand side of the rectangle\n    \\param bottom The Y coordinate of the bottom of the rectangle"]
    pub fn windowSetBoundsSub(window: WINDOW, left: u8_, top: u8_, right: u8_, bottom: u8_);
}
extern "C" {
    #[doc = "\t\\brief Enables the window on the supplied background.\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param window\nthe the window to enable"]
    pub fn bgWindowEnable(id: ::libc::c_int, window: WINDOW);
}
extern "C" {
    #[doc = "\t\\brief Disables the window on the supplied background.\n\\param id\nbackground id returned from bgInit or bgInitSub\n\\param window\nthe the window to disable"]
    pub fn bgWindowDisable(id: ::libc::c_int, window: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Enables the specified window.\n    \\param oam must be: &oamMain or &oamSub\n    \\param the window to enable"]
    pub fn oamWindowEnable(oam: *mut OamState, w: WINDOW);
}
extern "C" {
    #[doc = "    \\brief Disables the specified window.\n    \\param oam must be: &oamMain or &oamSub\n    \\param the window to disable"]
    pub fn oamWindowDisable(oam: *mut OamState, w: WINDOW);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = ::libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = ::libc::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::libc::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 1usize],
}
extern "C" {
    pub fn select(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::libc::c_ulong;
pub type daddr_t = ::libc::c_long;
pub type caddr_t = *mut ::libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::libc::c_int,
    pub stackaddr: *mut ::libc::c_void,
    pub stacksize: ::libc::c_int,
    pub contentionscope: ::libc::c_int,
    pub inheritsched: ::libc::c_int,
    pub schedpolicy: ::libc::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::libc::c_int,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::libc::c_int,
    pub recursive: ::libc::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::libc::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::libc::c_int,
    pub init_executed: ::libc::c_int,
}
extern "C" {
    pub static mut environ: *mut *mut ::libc::c_char;
}
extern "C" {
    pub fn _exit(__status: ::libc::c_int) -> !;
}
extern "C" {
    pub fn access(__path: *const ::libc::c_char, __amode: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn alarm(__secs: ::libc::c_uint) -> ::libc::c_uint;
}
extern "C" {
    pub fn chdir(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn chmod(__path: *const ::libc::c_char, __mode: mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn chown(__path: *const ::libc::c_char, __owner: uid_t, __group: gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn close(__fildes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn confstr(__name: ::libc::c_int, __buf: *mut ::libc::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn daemon(nochdir: ::libc::c_int, noclose: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn dup(__fildes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn dup2(__fildes: ::libc::c_int, __fildes2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execl(__path: *const ::libc::c_char, arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn execle(__path: *const ::libc::c_char, arg1: *const ::libc::c_char, ...)
        -> ::libc::c_int;
}
extern "C" {
    pub fn execlp(__file: *const ::libc::c_char, arg1: *const ::libc::c_char, ...)
        -> ::libc::c_int;
}
extern "C" {
    pub fn execlpe(
        __file: *const ::libc::c_char,
        arg1: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::libc::c_char,
        __argv: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execve(
        __path: *const ::libc::c_char,
        __argv: *const *mut ::libc::c_char,
        __envp: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::libc::c_char,
        __argv: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn faccessat(
        __dirfd: ::libc::c_int,
        __path: *const ::libc::c_char,
        __mode: ::libc::c_int,
        __flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fchdir(__fildes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn fchmod(__fildes: ::libc::c_int, __mode: mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fchown(__fildes: ::libc::c_int, __owner: uid_t, __group: gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fchownat(
        __dirfd: ::libc::c_int,
        __path: *const ::libc::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::libc::c_int,
        __argv: *const *mut ::libc::c_char,
        __envp: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(__fd: ::libc::c_int, __name: ::libc::c_int) -> ::libc::c_long;
}
extern "C" {
    pub fn fsync(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn fdatasync(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::libc::c_char, __size: usize) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn getentropy(arg1: *mut ::libc::c_void, arg2: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(__gidsetsize: ::libc::c_int, __grouplist: *mut gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gethostid() -> ::libc::c_long;
}
extern "C" {
    pub fn getlogin() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getpass(__prompt: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getpagesize() -> ::libc::c_int;
}
extern "C" {
    pub fn getpeereid(arg1: ::libc::c_int, arg2: *mut uid_t, arg3: *mut gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn getusershell() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn iruserok(
        raddr: ::libc::c_ulong,
        superuser: ::libc::c_int,
        ruser: *const ::libc::c_char,
        luser: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn isatty(__fildes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn issetugid() -> ::libc::c_int;
}
extern "C" {
    pub fn lchown(__path: *const ::libc::c_char, __owner: uid_t, __group: gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn link(__path1: *const ::libc::c_char, __path2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn linkat(
        __dirfd1: ::libc::c_int,
        __path1: *const ::libc::c_char,
        __dirfd2: ::libc::c_int,
        __path2: *const ::libc::c_char,
        __flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nice(__nice_value: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lseek(__fildes: ::libc::c_int, __offset: off_t, __whence: ::libc::c_int) -> off_t;
}
extern "C" {
    pub fn lockf(__fd: ::libc::c_int, __cmd: ::libc::c_int, __len: off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pathconf(__path: *const ::libc::c_char, __name: ::libc::c_int) -> ::libc::c_long;
}
extern "C" {
    pub fn pause() -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pipe(__fildes: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::libc::c_int,
        __buf: *mut ::libc::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::libc::c_int,
        __buf: *const ::libc::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn read(__fd: ::libc::c_int, __buf: *mut ::libc::c_void, __nbyte: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn revoke(__path: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn ruserok(
        rhost: *const ::libc::c_char,
        superuser: ::libc::c_int,
        ruser: *const ::libc::c_char,
        luser: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sbrk(__incr: isize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn setegid(__gid: gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn seteuid(__uid: uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setgid(__gid: gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setgroups(ngroups: ::libc::c_int, grouplist: *const gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sethostname(arg1: *const ::libc::c_char, arg2: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::libc::c_int;
}
extern "C" {
    pub fn setregid(__rgid: gid_t, __egid: gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: uid_t, __euid: uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(__uid: uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn sleep(__seconds: ::libc::c_uint) -> ::libc::c_uint;
}
extern "C" {
    pub fn sysconf(__name: ::libc::c_int) -> ::libc::c_long;
}
extern "C" {
    pub fn tcgetpgrp(__fildes: ::libc::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fildes: ::libc::c_int, __pgrp_id: pid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn ttyname(__fildes: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ttyname_r(arg1: ::libc::c_int, arg2: *mut ::libc::c_char, arg3: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn unlink(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn usleep(__useconds: useconds_t) -> ::libc::c_int;
}
extern "C" {
    pub fn vhangup() -> ::libc::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::libc::c_int,
        __buf: *const ::libc::c_void,
        __nbyte: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::libc::c_char;
}
extern "C" {
    pub static mut optind: ::libc::c_int;
}
extern "C" {
    pub static mut opterr: ::libc::c_int;
}
extern "C" {
    pub static mut optopt: ::libc::c_int;
}
extern "C" {
    pub fn getopt(
        arg1: ::libc::c_int,
        arg2: *const *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static mut optreset: ::libc::c_int;
}
extern "C" {
    pub fn vfork() -> ::libc::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::libc::c_int, __length: off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn truncate(arg1: *const ::libc::c_char, __length: off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::libc::c_int;
}
extern "C" {
    pub fn ualarm(__useconds: useconds_t, __interval: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn gethostname(__name: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn setdtablesize(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn readlink(
        __path: *const ::libc::c_char,
        __buf: *mut ::libc::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlink(__name1: *const ::libc::c_char, __name2: *const ::libc::c_char)
        -> ::libc::c_int;
}
extern "C" {
    pub fn readlinkat(
        __dirfd1: ::libc::c_int,
        __path: *const ::libc::c_char,
        __buf: *mut ::libc::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::libc::c_int,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nand_ReadSectors(sector: sec_t, numSectors: sec_t, buffer: *mut ::libc::c_void) -> bool;
}
extern "C" {
    pub fn nand_WriteSectors(
        sector: sec_t,
        numSectors: sec_t,
        buffer: *const ::libc::c_void,
    ) -> bool;
}
extern "C" {
    pub fn nand_GetSize() -> isize;
}
pub const WIFI_RETURN_OK: WIFI_RETURN = 0;
pub const WIFI_RETURN_LOCKFAILED: WIFI_RETURN = 1;
pub const WIFI_RETURN_ERROR: WIFI_RETURN = 2;
pub const WIFI_RETURN_PARAMERROR: WIFI_RETURN = 3;
pub type WIFI_RETURN = ::libc::c_uint;
pub const WSTAT_RXQUEUEDPACKETS: WIFI_STATS = 0;
pub const WSTAT_TXQUEUEDPACKETS: WIFI_STATS = 1;
pub const WSTAT_RXQUEUEDBYTES: WIFI_STATS = 2;
pub const WSTAT_TXQUEUEDBYTES: WIFI_STATS = 3;
pub const WSTAT_RXQUEUEDLOST: WIFI_STATS = 4;
pub const WSTAT_TXQUEUEDREJECTED: WIFI_STATS = 5;
pub const WSTAT_RXPACKETS: WIFI_STATS = 6;
pub const WSTAT_RXBYTES: WIFI_STATS = 7;
pub const WSTAT_RXDATABYTES: WIFI_STATS = 8;
pub const WSTAT_TXPACKETS: WIFI_STATS = 9;
pub const WSTAT_TXBYTES: WIFI_STATS = 10;
pub const WSTAT_TXDATABYTES: WIFI_STATS = 11;
pub const WSTAT_ARM7_UPDATES: WIFI_STATS = 12;
pub const WSTAT_DEBUG: WIFI_STATS = 13;
pub const WSTAT_HW_1B0: WIFI_STATS = 14;
pub const WSTAT_HW_1B1: WIFI_STATS = 15;
pub const WSTAT_HW_1B2: WIFI_STATS = 16;
pub const WSTAT_HW_1B3: WIFI_STATS = 17;
pub const WSTAT_HW_1B4: WIFI_STATS = 18;
pub const WSTAT_HW_1B5: WIFI_STATS = 19;
pub const WSTAT_HW_1B6: WIFI_STATS = 20;
pub const WSTAT_HW_1B7: WIFI_STATS = 21;
pub const WSTAT_HW_1B8: WIFI_STATS = 22;
pub const WSTAT_HW_1B9: WIFI_STATS = 23;
pub const WSTAT_HW_1BA: WIFI_STATS = 24;
pub const WSTAT_HW_1BB: WIFI_STATS = 25;
pub const WSTAT_HW_1BC: WIFI_STATS = 26;
pub const WSTAT_HW_1BD: WIFI_STATS = 27;
pub const WSTAT_HW_1BE: WIFI_STATS = 28;
pub const WSTAT_HW_1BF: WIFI_STATS = 29;
pub const WSTAT_HW_1C0: WIFI_STATS = 30;
pub const WSTAT_HW_1C1: WIFI_STATS = 31;
pub const WSTAT_HW_1C4: WIFI_STATS = 32;
pub const WSTAT_HW_1C5: WIFI_STATS = 33;
pub const WSTAT_HW_1D0: WIFI_STATS = 34;
pub const WSTAT_HW_1D1: WIFI_STATS = 35;
pub const WSTAT_HW_1D2: WIFI_STATS = 36;
pub const WSTAT_HW_1D3: WIFI_STATS = 37;
pub const WSTAT_HW_1D4: WIFI_STATS = 38;
pub const WSTAT_HW_1D5: WIFI_STATS = 39;
pub const WSTAT_HW_1D6: WIFI_STATS = 40;
pub const WSTAT_HW_1D7: WIFI_STATS = 41;
pub const WSTAT_HW_1D8: WIFI_STATS = 42;
pub const WSTAT_HW_1D9: WIFI_STATS = 43;
pub const WSTAT_HW_1DA: WIFI_STATS = 44;
pub const WSTAT_HW_1DB: WIFI_STATS = 45;
pub const WSTAT_HW_1DC: WIFI_STATS = 46;
pub const WSTAT_HW_1DD: WIFI_STATS = 47;
pub const WSTAT_HW_1DE: WIFI_STATS = 48;
pub const WSTAT_HW_1DF: WIFI_STATS = 49;
pub const NUM_WIFI_STATS: WIFI_STATS = 50;
pub type WIFI_STATS = ::libc::c_uint;
pub const WIFIMODE_DISABLED: WIFI_MODE = 0;
pub const WIFIMODE_NORMAL: WIFI_MODE = 1;
pub const WIFIMODE_SCAN: WIFI_MODE = 2;
pub const WIFIMODE_ASSOCIATE: WIFI_MODE = 3;
pub const WIFIMODE_ASSOCIATED: WIFI_MODE = 4;
pub const WIFIMODE_DISASSOCIATE: WIFI_MODE = 5;
pub const WIFIMODE_CANNOTASSOCIATE: WIFI_MODE = 6;
pub type WIFI_MODE = ::libc::c_uint;
pub const WIFI_AUTHLEVEL_DISCONNECTED: WIFI_AUTHLEVEL = 0;
pub const WIFI_AUTHLEVEL_AUTHENTICATED: WIFI_AUTHLEVEL = 1;
pub const WIFI_AUTHLEVEL_ASSOCIATED: WIFI_AUTHLEVEL = 2;
pub const WIFI_AUTHLEVEL_DEASSOCIATED: WIFI_AUTHLEVEL = 3;
pub type WIFI_AUTHLEVEL = ::libc::c_uint;
pub const WIFIGETDATA_MACADDRESS: WIFIGETDATA = 0;
pub const WIFIGETDATA_NUMWFCAPS: WIFIGETDATA = 1;
pub const MAX_WIFIGETDATA: WIFIGETDATA = 2;
pub type WIFIGETDATA = ::libc::c_uint;
pub const WEPMODE_NONE: WEPMODES = 0;
pub const WEPMODE_40BIT: WEPMODES = 1;
pub const WEPMODE_128BIT: WEPMODES = 2;
pub type WEPMODES = ::libc::c_uint;
pub const ASSOCSTATUS_DISCONNECTED: WIFI_ASSOCSTATUS = 0;
pub const ASSOCSTATUS_SEARCHING: WIFI_ASSOCSTATUS = 1;
pub const ASSOCSTATUS_AUTHENTICATING: WIFI_ASSOCSTATUS = 2;
pub const ASSOCSTATUS_ASSOCIATING: WIFI_ASSOCSTATUS = 3;
pub const ASSOCSTATUS_ACQUIRINGDHCP: WIFI_ASSOCSTATUS = 4;
pub const ASSOCSTATUS_ASSOCIATED: WIFI_ASSOCSTATUS = 5;
pub const ASSOCSTATUS_CANNOTCONNECT: WIFI_ASSOCSTATUS = 6;
pub type WIFI_ASSOCSTATUS = ::libc::c_uint;
extern "C" {
    pub static mut ASSOCSTATUS_STRINGS: [*const ::libc::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WIFI_TXHEADER {
    pub enable_flags: u16_,
    pub unknown: u16_,
    pub countup: u16_,
    pub beaconfreq: u16_,
    pub tx_rate: u16_,
    pub tx_length: u16_,
}
pub type Wifi_TxHeader = WIFI_TXHEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WIFI_RXHEADER {
    pub a: u16_,
    pub b: u16_,
    pub c: u16_,
    pub d: u16_,
    pub byteLength: u16_,
    pub rssi_: u16_,
}
pub type Wifi_RxHeader = WIFI_RXHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WIFI_ACCESSPOINT {
    pub ssid: [::libc::c_char; 33usize],
    pub ssid_len: ::libc::c_char,
    pub bssid: [u8_; 6usize],
    pub macaddr: [u8_; 6usize],
    pub maxrate: u16_,
    pub timectr: u32_,
    pub rssi: u16_,
    pub flags: u16_,
    pub spinlock: u32_,
    pub channel: u8_,
    pub rssi_past: [u8_; 8usize],
    pub base_rates: [u8_; 16usize],
}
impl Default for WIFI_ACCESSPOINT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Wifi_AccessPoint = WIFI_ACCESSPOINT;
pub type WifiPacketHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int, arg2: ::libc::c_int)>;
pub type WifiSyncHandler = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn Wifi_Init(initflags: ::libc::c_int) -> ::libc::c_ulong;
}
extern "C" {
    pub fn Wifi_CheckInit() -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_DisableWifi();
}
extern "C" {
    pub fn Wifi_EnableWifi();
}
extern "C" {
    pub fn Wifi_SetPromiscuousMode(enable: ::libc::c_int);
}
extern "C" {
    pub fn Wifi_ScanMode();
}
extern "C" {
    pub fn Wifi_SetChannel(channel: ::libc::c_int);
}
extern "C" {
    pub fn Wifi_GetNumAP() -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_GetAPData(apnum: ::libc::c_int, apdata: *mut Wifi_AccessPoint) -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_FindMatchingAP(
        numaps: ::libc::c_int,
        apdata: *mut Wifi_AccessPoint,
        match_dest: *mut Wifi_AccessPoint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_ConnectAP(
        apdata: *mut Wifi_AccessPoint,
        wepmode: ::libc::c_int,
        wepkeyid: ::libc::c_int,
        wepkey: *mut ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_AutoConnect();
}
extern "C" {
    pub fn Wifi_AssocStatus() -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_DisconnectAP() -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_Timer(num_ms: ::libc::c_int);
}
extern "C" {
    pub fn Wifi_GetIP() -> ::libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn Wifi_GetIPInfo(
        pGateway: *mut in_addr,
        pSnmask: *mut in_addr,
        pDns1: *mut in_addr,
        pDns2: *mut in_addr,
    ) -> in_addr;
}
extern "C" {
    pub fn Wifi_SetIP(
        IPaddr: ::libc::c_ulong,
        gateway: ::libc::c_ulong,
        subnetmask: ::libc::c_ulong,
        dns1: ::libc::c_ulong,
        dns2: ::libc::c_ulong,
    );
}
extern "C" {
    pub fn Wifi_GetData(
        datatype: ::libc::c_int,
        bufferlen: ::libc::c_int,
        buffer: *mut ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_GetStats(statnum: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn Wifi_RawTxFrame(
        datalen: ::libc::c_ushort,
        rate: ::libc::c_ushort,
        data: *mut ::libc::c_ushort,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_RawSetPacketHandler(wphfunc: WifiPacketHandler);
}
extern "C" {
    pub fn Wifi_RxRawReadPacket(
        packetID: ::libc::c_long,
        readlength: ::libc::c_long,
        data: *mut ::libc::c_ushort,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_Update();
}
extern "C" {
    pub fn Wifi_Sync();
}
extern "C" {
    pub fn Wifi_SetSyncHandler(sh: WifiSyncHandler);
}
extern "C" {
    pub fn Wifi_InitDefault(useFirmwareSettings: bool) -> bool;
}
pub type mm_word = ::libc::c_uint;
pub type mm_hword = ::libc::c_ushort;
pub type mm_byte = ::libc::c_uchar;
pub type mm_sfxhand = ::libc::c_ushort;
pub type mm_bool = ::libc::c_uchar;
pub type mm_addr = *mut ::libc::c_void;
pub type mm_reg = *mut ::libc::c_void;
pub const MM_MODE_A: mm_mode_enum = 0;
pub const MM_MODE_B: mm_mode_enum = 1;
pub const MM_MODE_C: mm_mode_enum = 2;
pub type mm_mode_enum = ::libc::c_uint;
pub const MM_STREAM_8BIT_MONO: mm_stream_formats = 0;
pub const MM_STREAM_8BIT_STEREO: mm_stream_formats = 1;
pub const MM_STREAM_16BIT_MONO: mm_stream_formats = 2;
pub const MM_STREAM_16BIT_STEREO: mm_stream_formats = 3;
pub type mm_stream_formats = ::libc::c_uint;
pub type mm_callback =
    ::core::option::Option<unsafe extern "C" fn(msg: mm_word, param: mm_word) -> mm_word>;
pub type mm_stream_func = ::core::option::Option<
    unsafe extern "C" fn(length: mm_word, dest: mm_addr, format: mm_stream_formats) -> mm_word,
>;
pub const MMRF_MEMORY: mm_reverbflags = 1;
pub const MMRF_DELAY: mm_reverbflags = 2;
pub const MMRF_RATE: mm_reverbflags = 4;
pub const MMRF_FEEDBACK: mm_reverbflags = 8;
pub const MMRF_PANNING: mm_reverbflags = 16;
pub const MMRF_LEFT: mm_reverbflags = 32;
pub const MMRF_RIGHT: mm_reverbflags = 64;
pub const MMRF_BOTH: mm_reverbflags = 96;
pub const MMRF_INVERSEPAN: mm_reverbflags = 128;
pub const MMRF_NODRYLEFT: mm_reverbflags = 256;
pub const MMRF_NODRYRIGHT: mm_reverbflags = 512;
pub const MMRF_8BITLEFT: mm_reverbflags = 1024;
pub const MMRF_16BITLEFT: mm_reverbflags = 2048;
pub const MMRF_8BITRIGHT: mm_reverbflags = 4096;
pub const MMRF_16BITRIGHT: mm_reverbflags = 8192;
pub const MMRF_DRYLEFT: mm_reverbflags = 16384;
pub const MMRF_DRYRIGHT: mm_reverbflags = 32768;
pub type mm_reverbflags = ::libc::c_uint;
pub const MMRC_LEFT: mm_reverbch = 1;
pub const MMRC_RIGHT: mm_reverbch = 2;
pub const MMRC_BOTH: mm_reverbch = 3;
pub type mm_reverbch = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmreverbcfg {
    pub flags: mm_word,
    pub memory: mm_addr,
    pub delay: mm_hword,
    pub rate: mm_hword,
    pub feedback: mm_hword,
    pub panning: mm_byte,
}
impl Default for mmreverbcfg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_reverb_cfg = mmreverbcfg;
pub const MM_PLAY_LOOP: mm_pmode = 0;
pub const MM_PLAY_ONCE: mm_pmode = 1;
pub type mm_pmode = ::libc::c_uint;
pub const MM_MIX_8KHZ: mm_mixmode = 0;
pub const MM_MIX_10KHZ: mm_mixmode = 1;
pub const MM_MIX_13KHZ: mm_mixmode = 2;
pub const MM_MIX_16KHZ: mm_mixmode = 3;
pub const MM_MIX_18KHZ: mm_mixmode = 4;
pub const MM_MIX_21KHZ: mm_mixmode = 5;
pub const MM_MIX_27KHZ: mm_mixmode = 6;
pub const MM_MIX_31KHZ: mm_mixmode = 7;
pub type mm_mixmode = ::libc::c_uint;
pub const MM_TIMER0: mm_stream_timer = 0;
pub const MM_TIMER1: mm_stream_timer = 1;
pub const MM_TIMER2: mm_stream_timer = 2;
pub const MM_TIMER3: mm_stream_timer = 3;
pub type mm_stream_timer = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct t_mmdssample {
    pub loop_start: mm_word,
    pub __bindgen_anon_1: t_mmdssample__bindgen_ty_1,
    pub format: mm_byte,
    pub repeat_mode: mm_byte,
    pub base_rate: mm_hword,
    pub data: mm_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union t_mmdssample__bindgen_ty_1 {
    pub loop_length: mm_word,
    pub length: mm_word,
}
impl Default for t_mmdssample__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for t_mmdssample {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_ds_sample = t_mmdssample;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct t_mmsoundeffect {
    pub __bindgen_anon_1: t_mmsoundeffect__bindgen_ty_1,
    pub rate: mm_hword,
    pub handle: mm_sfxhand,
    pub volume: mm_byte,
    pub panning: mm_byte,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union t_mmsoundeffect__bindgen_ty_1 {
    pub id: mm_word,
    pub sample: *mut mm_ds_sample,
}
impl Default for t_mmsoundeffect__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for t_mmsoundeffect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_sound_effect = t_mmsoundeffect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_mmgbasystem {
    pub mixing_mode: mm_mixmode,
    pub mod_channel_count: mm_word,
    pub mix_channel_count: mm_word,
    pub module_channels: mm_addr,
    pub active_channels: mm_addr,
    pub mixing_channels: mm_addr,
    pub mixing_memory: mm_addr,
    pub wave_memory: mm_addr,
    pub soundbank: mm_addr,
}
impl Default for t_mmgbasystem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_gba_system = t_mmgbasystem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_mmdssystem {
    pub mod_count: mm_word,
    pub samp_count: mm_word,
    pub mem_bank: *mut mm_word,
    pub fifo_channel: mm_word,
}
impl Default for t_mmdssystem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_ds_system = t_mmdssystem;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct t_mmstream {
    pub sampling_rate: mm_word,
    pub buffer_length: mm_word,
    pub callback: mm_stream_func,
    pub format: mm_word,
    pub timer: mm_word,
    pub manual: mm_bool,
}
pub type mm_stream = t_mmstream;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct t_mmlayer {
    pub tick: mm_byte,
    pub row: mm_byte,
    pub position: mm_byte,
    pub nrows: mm_byte,
    pub global_volume: mm_byte,
    pub speed: mm_byte,
    pub active: mm_byte,
    pub bpm: mm_byte,
}
pub type mm_modlayer = t_mmlayer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmm_voice {
    pub source: mm_addr,
    pub length: mm_word,
    pub loop_start: mm_hword,
    pub timer: mm_hword,
    pub flags: mm_byte,
    pub format: mm_byte,
    pub repeat: mm_byte,
    pub volume: mm_byte,
    pub divider: mm_byte,
    pub panning: mm_byte,
    pub index: mm_byte,
    pub reserved: [mm_byte; 1usize],
}
impl Default for tmm_voice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_voice = tmm_voice;
pub const MMVF_FREQ: _bindgen_ty_1 = 2;
pub const MMVF_VOLUME: _bindgen_ty_1 = 4;
pub const MMVF_PANNING: _bindgen_ty_1 = 8;
pub const MMVF_SOURCE: _bindgen_ty_1 = 16;
pub const MMVF_STOP: _bindgen_ty_1 = 32;
pub type _bindgen_ty_1 = ::libc::c_uint;
extern "C" {
    #[doc = " mmInitDefault( char* soundbank_file )\n\n Initialize Maxmod using default settings.\n\n soundbank_file : Filename of the soundbank to use."]
    pub fn mmInitDefault(soundbank_file: *mut ::libc::c_char);
}
extern "C" {
    #[doc = " mmInitDefaultMem( mm_addr soundbank )\n\n Initialize Maxmod using default settings.\n Use this when you have the entire soundbank loaded into memory.\n\n soundbank : Address of soundbank data."]
    pub fn mmInitDefaultMem(soundbank: mm_addr);
}
extern "C" {
    #[doc = " mmInit( mm_ds_system* system )\n\n Initialize Maxmod\n\n system : Configuration info."]
    pub fn mmInit(system: *mut mm_ds_system);
}
extern "C" {
    #[doc = " mmSelectMode( mm_mode_enum mode )\n\n Select audio mode\n\n mode:\n   MM_MODE_A : Hardware Mixing\n   MM_MODE_B : Interpolated Mixing\n   MM_MODE_C : Extended Mixing"]
    pub fn mmSelectMode(mode: mm_mode_enum);
}
extern "C" {
    #[doc = " mmLoad( mm_word module_ID )\n\n Load a module into memory. Must be used before starting\n a module.\n\n module_ID : ID of module. (defined in soundbank header)"]
    pub fn mmLoad(module_ID: mm_word);
}
extern "C" {
    #[doc = " mmUnload( mm_word module_ID )\n\n Unload a module from memory.\n\n module_ID : ID of module. (defined in soundbank header)"]
    pub fn mmUnload(module_ID: mm_word);
}
extern "C" {
    #[doc = " mmLoadEffect( mm_word sample_ID )\n\n Load a sound effect into memory. Use before mmEffect.\n\n sample_ID : ID of sample. (defined in soundbank header)"]
    pub fn mmLoadEffect(sample_ID: mm_word);
}
extern "C" {
    #[doc = " mmUnloadEffect( mm_word sample_ID )\n\n Unload sound effect from memory.\n\n sample_ID : ID of sample. (defined in soundbank header)"]
    pub fn mmUnloadEffect(sample_ID: mm_word);
}
extern "C" {
    #[doc = " mmLockChannels( mm_word bitmask )\n\n Lock audio channels from being used by Maxmod.\n\n bitmask : Bitmask of which channels should be locked.\n (&1 = ch0, &2 = ch1, &4 = ch2, &8 = ch4, etc...)"]
    pub fn mmLockChannels(bitmask: mm_word);
}
extern "C" {
    #[doc = " mmUnlockChannels( mm_word bitmask )\n\n Unlock audio channels so Maxmod can use them.\n\n bitmask : Bitmask of which channels should be unlocked.\n (&1 = ch0, &2 = ch1, &4 = ch2, &8 = ch4, etc...)"]
    pub fn mmUnlockChannels(bitmask: mm_word);
}
extern "C" {
    #[doc = " mmSetEventHandler( mm_callback handler )\n\n Setup handler to receive playback events.\n\n handler : Pointer to your function."]
    pub fn mmSetEventHandler(handler: mm_callback);
}
extern "C" {
    #[doc = " mmSoundBankInMemory( mm_addr address )\n mmSoundBankInFiles( char* filename )\n mmSetCustomSoundBankHandler( mm_callback p_loader )\n\n Setup soundbank interface.\n This is automatically done by mmInitDefault/mmInitDefaultMem."]
    pub fn mmSoundBankInMemory(address: mm_addr);
}
extern "C" {
    pub fn mmSoundBankInFiles(filename: *mut ::libc::c_char);
}
extern "C" {
    pub fn mmSetCustomSoundBankHandler(p_loader: mm_callback);
}
extern "C" {
    #[doc = " mmStart( mm_word module_ID, mm_pmode mode )\n\n Start module playback.\n\n module_ID : ID of module to play (defined in soundbank header)\n             Make sure the module is loaded via mmLoad\n\n mode : Mode of playback: MM_PLAY_ONCE or MM_PLAY_LOOP"]
    pub fn mmStart(module_ID: mm_word, mode: mm_pmode);
}
extern "C" {
    #[doc = " mmPause()\n\n Pause module playback. Resume with mmResume()."]
    pub fn mmPause();
}
extern "C" {
    #[doc = " mmResume()\n\n Resume module playback. Pause with mmPause()."]
    pub fn mmResume();
}
extern "C" {
    #[doc = " mmStop()\n\n Stop module playback. Start again (from the beginning)\n with mmStart()."]
    pub fn mmStop();
}
extern "C" {
    #[doc = " mmPosition( mm_word position )\n\n Set playback position.\n\n position : New position in module sequence."]
    pub fn mmPosition(position: mm_word);
}
extern "C" {
    #[doc = " mmJingle( mm_word module_ID )\n\n Play module as jingle. Jingles are limited to 4 channels only.\n\n module_ID : ID of module"]
    pub fn mmJingle(module_ID: mm_word);
}
extern "C" {
    #[doc = " mmSetModuleVolume( mm_word volume )\n mmSetJingleVolume( mm_word volume )\n\n Set master volume scale for music/jingle playback.\n\n volume : 0->1024 representing 0%->100% volume"]
    pub fn mmSetModuleVolume(volume: mm_word);
}
extern "C" {
    pub fn mmSetJingleVolume(volume: mm_word);
}
extern "C" {
    #[doc = " mmSetModuleTempo( mm_word tempo )\n\n Set tempo of playback.\n\n tempo : Fixed point (Q10) value representing tempo.\n         Range = 0x200 -> 0x800 = 0.5 -> 2.0"]
    pub fn mmSetModuleTempo(tempo: mm_word);
}
extern "C" {
    #[doc = " mmSetModulePitch( mm_word pitch )\n\n Set pitch of playback.\n\n pitch : Range = 0x200 -> 0x800 = 0.5 -> 2.0"]
    pub fn mmSetModulePitch(pitch: mm_word);
}
extern "C" {
    #[doc = " mmActive()\n\n Returns nonzero if module is playing."]
    pub fn mmActive() -> mm_bool;
}
extern "C" {
    #[doc = " mmEffect( mm_word sample_ID )\n\n Play a sound effect at its default rate with full volume\n and centered panning.\n Remember to load the effect via mmLoadEffect first.\n\n sample_ID : ID of sample to play (defined in soundbank header)\n\n Returns mm_sfxhand which may be used to modify the sound later."]
    pub fn mmEffect(sample_ID: mm_word) -> mm_sfxhand;
}
extern "C" {
    #[doc = " mmEffectEx( mm_sound_effect* sound )\n\n Play a sound effect with rate/volume/panning specified.\n Remember to load the effect via mmLoadEffect first.\n\n sound : sound effect info"]
    pub fn mmEffectEx(sound: *mut mm_sound_effect) -> mm_sfxhand;
}
extern "C" {
    #[doc = " mmEffectVolume( mm_sfxhand handle, mm_byte volume )\n\n Set effect volume.\n\n handle : Sound effect handle (returned from mmEffect/Ex)\n volume : 0..255 = silent..normal"]
    pub fn mmEffectVolume(handle: mm_sfxhand, volume: mm_word);
}
extern "C" {
    #[doc = " mmEffectPanning( mm_sfxhand handle, mm_byte panning )\n\n Set effect panning.\n\n handle : Sound effect handle (returned from mmEffect/Ex)\n panning : 0..255 = hard left..hard right"]
    pub fn mmEffectPanning(handle: mm_sfxhand, panning: mm_byte);
}
extern "C" {
    #[doc = " mmEffectRate( mm_sfxhandle, mm_word rate )\n\n Set effect playback rate.\n\n handle : Sound effect handle (returned from mmEffect/Ex)\n rate : 6.10 fixed point value representing rate. A value of\n        2048 will make the pitch one octave higher than the\n        default setting"]
    pub fn mmEffectRate(handle: mm_sfxhand, rate: mm_word);
}
extern "C" {
    #[doc = " mmEffectScaleRate( mm_sfxhandle, mm_word factor )\n\n Scale effect playback rate.\n\n handle : Sound effect handle (returned from mmEffect/Ex)\n factor : 6.10 fixed point value to multiply the rate by."]
    pub fn mmEffectScaleRate(handle: mm_sfxhand, factor: mm_word);
}
extern "C" {
    #[doc = " mmEffectCancel( mm_sfx_handle handle )\n\n Stop sound effect.\n\n handle : Sound effect handle (returned from mmEffect/Ex)"]
    pub fn mmEffectCancel(handle: mm_sfxhand);
}
extern "C" {
    #[doc = " mmEffectRelease( mm_sfxhand handle )\n\n Release sound effect. This discards the handle and allows the\n effect to be overidden by music/other effects."]
    pub fn mmEffectRelease(handle: mm_sfxhand);
}
extern "C" {
    #[doc = " mmEffectExt( mm_sound_effect* sound, mm_sample* sample )\n\n Play external sound.\n\n sound : Pointer to sound effect info\n sample : Pointer to external sample"]
    pub fn mmEffectExt(sound: *mut mm_sound_effect, sample: *mut mm_ds_sample) -> mm_sfxhand;
}
extern "C" {
    #[doc = " mmSetEffectsVolume( mm_word volume )\n\n Set master volume scale for effect playback.\n\n volume : 0->1024 representing 0%->100% volume"]
    pub fn mmSetEffectsVolume(volume: mm_word);
}
extern "C" {
    #[doc = " mmEffectCancelAll()\n\n Stop all sound effects"]
    pub fn mmEffectCancelAll();
}
extern "C" {
    #[doc = " mmStreamOpen( mm_stream_info* info )\n\n Open audio stream.\n\n stream : Configuration struct"]
    pub fn mmStreamOpen(stream: *mut mm_stream);
}
extern "C" {
    #[doc = " mmStreamUpdate()\n\n Fill audio stream with data. This needs to be called\n in 'manual' mode. This is called automatically in 'auto' mode."]
    pub fn mmStreamUpdate();
}
extern "C" {
    #[doc = " mmStreamClose()\n\n Close audio stream."]
    pub fn mmStreamClose();
}
extern "C" {
    #[doc = " mmStreamGetPosition()\n\n Get number of samples elapsed since the stream was opened.\n The 32-bit value will wrap every 36 hours or so (at 32khz)"]
    pub fn mmStreamGetPosition() -> mm_word;
}
extern "C" {
    #[doc = " mmReverbEnable()\n\n Enable reverb system. (use before configuring!)"]
    pub fn mmReverbEnable();
}
extern "C" {
    #[doc = " mmReverbConfigure( mm_reverb_cfg* config )\n\n Configure reverb parameters.\n config : Configuration data."]
    pub fn mmReverbConfigure(config: *mut mm_reverb_cfg);
}
extern "C" {
    #[doc = " mmReverbStart( mm_reverbch channels )\n\n Start reverb output."]
    pub fn mmReverbStart(channels: mm_reverbch);
}
extern "C" {
    #[doc = " mmReverbStop( mm_reverch channels )\n\n Stop reverb output."]
    pub fn mmReverbStop(channels: mm_reverbch);
}
extern "C" {
    #[doc = " mmReverbBufferSize( mm_word bit_depth, mm_word sampling_rate,\n                     mm_word delay )\n\n Calculate reverb buffer size based on bit depth, delay\n and sampling rate.\n\n bit_depth : Pass 8 or 16 for 8-bit/16-bit\n sampling_rate :\n delay : In milliseconds\n\n Returns size in WORDS."]
    #[link_name = "\u{1}mmReverbBufferSize__extern"]
    pub fn mmReverbBufferSize(
        bit_depth: mm_word,
        sampling_rate: mm_word,
        delay: mm_word,
    ) -> mm_word;
}
extern "C" {
    #[doc = " mmReverbDisable()\n\n Disable reverb system."]
    pub fn mmReverbDisable();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
