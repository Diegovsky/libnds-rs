/* automatically generated by rust-bindgen 0.59.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _LIBNDS_MAJOR_: u32 = 1;
pub const _LIBNDS_MINOR_: u32 = 8;
pub const _LIBNDS_PATCH_: u32 = 0;
pub const _LIBNDS_STRING: &'static [u8; 21usize] = b"libNDS Release 1.8.0\0";
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 2;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const COPY_MODE_HWORD: u32 = 0;
pub const COPY_MODE_COPY: u32 = 0;
pub const CARD_CR1_ENABLE: u32 = 128;
pub const CARD_CR1_IRQ: u32 = 64;
pub const SPI_EEPROM_WRSR: u32 = 1;
pub const SPI_EEPROM_PP: u32 = 2;
pub const SPI_EEPROM_READ: u32 = 3;
pub const SPI_EEPROM_WRDI: u32 = 4;
pub const SPI_EEPROM_RDSR: u32 = 5;
pub const SPI_EEPROM_WREN: u32 = 6;
pub const SPI_EEPROM_PW: u32 = 10;
pub const SPI_EEPROM_FAST: u32 = 11;
pub const SPI_EEPROM_RDID: u32 = 159;
pub const SPI_EEPROM_RDP: u32 = 171;
pub const SPI_EEPROM_DPD: u32 = 185;
pub const CARD_ACTIVATE: u32 = 2147483648;
pub const CARD_WR: u32 = 1073741824;
pub const CARD_nRESET: u32 = 536870912;
pub const CARD_SEC_LARGE: u32 = 268435456;
pub const CARD_CLK_SLOW: u32 = 134217728;
pub const CARD_SEC_CMD: u32 = 4194304;
pub const CARD_SEC_SEED: u32 = 32768;
pub const CARD_SEC_EN: u32 = 16384;
pub const CARD_SEC_DAT: u32 = 8192;
pub const CARD_BUSY: u32 = 2147483648;
pub const CARD_DATA_READY: u32 = 8388608;
pub const CARD_CMD_DUMMY: u32 = 159;
pub const CARD_CMD_HEADER_READ: u32 = 0;
pub const CARD_CMD_HEADER_CHIPID: u32 = 144;
pub const CARD_CMD_ACTIVATE_BF: u32 = 60;
pub const CARD_CMD_ACTIVATE_SEC: u32 = 64;
pub const CARD_CMD_SECURE_CHIPID: u32 = 16;
pub const CARD_CMD_SECURE_READ: u32 = 32;
pub const CARD_CMD_DISABLE_SEC: u32 = 96;
pub const CARD_CMD_DATA_MODE: u32 = 160;
pub const CARD_CMD_DATA_READ: u32 = 183;
pub const CARD_CMD_DATA_CHIPID: u32 = 184;
pub const CARD_ENABLE: u32 = 32768;
pub const CARD_SPI_ENABLE: u32 = 8192;
pub const CARD_SPI_BUSY: u32 = 128;
pub const CARD_SPI_HOLD: u32 = 64;
pub const CARD_SPICNTH_ENABLE: u32 = 128;
pub const CARD_SPICNTH_IRQ: u32 = 64;
pub const DMA_START_NOW: u32 = 0;
pub const DMA_START_CARD: u32 = 671088640;
pub const DMA_16_BIT: u32 = 0;
pub const DMA_SRC_INC: u32 = 0;
pub const DMA_DST_INC: u32 = 0;
pub const DMA_DST_RESET: u32 = 6291456;
pub const MAX_INTERRUPTS: u32 = 25;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const ARGV_MAGIC: u32 = 1600221799;
pub const BOOTSIG: u64 = 7094704827215605602;
pub const BUS_CLOCK: u32 = 33513982;
pub const TIMER_ENABLE: u32 = 128;
pub const TIMER_IRQ_REQ: u32 = 64;
pub const TIMER_CASCADE: u32 = 4;
pub const TIMER_DIV_1: u32 = 0;
pub const TIMER_DIV_64: u32 = 1;
pub const TIMER_DIV_256: u32 = 2;
pub const TIMER_DIV_1024: u32 = 3;
pub const AES_WRFIFO_FLUSH: u32 = 1024;
pub const AES_RDFIFO_FLUSH: u32 = 2048;
pub const AES_CCM_PASSTRHOUGH: u32 = 524288;
pub const AES_CNT_KEY_APPLY: u32 = 16777216;
pub const AES_CNT_IRQ: u32 = 1073741824;
pub const AES_CNT_ENABLE: u32 = 2147483648;
pub const SPI_BAUD_4MHz: u32 = 0;
pub const SPI_BAUD_2MHz: u32 = 1;
pub const SPI_BAUD_1MHz: u32 = 2;
pub const SPI_BAUD_512KHz: u32 = 3;
pub const SPI_BYTE_MODE: u32 = 0;
pub const SPI_HWORD_MODE: u32 = 1024;
pub const SPI_DEVICE_POWER: u32 = 0;
pub const SPI_DEVICE_FIRMWARE: u32 = 256;
pub const SPI_DEVICE_NVRAM: u32 = 256;
pub const SPI_DEVICE_TOUCH: u32 = 512;
pub const SPI_DEVICE_MICROPHONE: u32 = 512;
pub const FIRMWARE_WREN: u32 = 6;
pub const FIRMWARE_WRDI: u32 = 4;
pub const FIRMWARE_RDID: u32 = 159;
pub const FIRMWARE_RDSR: u32 = 5;
pub const FIRMWARE_READ: u32 = 3;
pub const FIRMWARE_PW: u32 = 10;
pub const FIRMWARE_PP: u32 = 2;
pub const FIRMWARE_FAST: u32 = 11;
pub const FIRMWARE_PE: u32 = 219;
pub const FIRMWARE_SE: u32 = 216;
pub const FIRMWARE_DP: u32 = 185;
pub const FIRMWARE_RDP: u32 = 171;
pub const SOUND_FORMAT_16BIT: u32 = 536870912;
pub const SOUND_FORMAT_8BIT: u32 = 0;
pub const SOUND_FORMAT_PSG: u32 = 1610612736;
pub const SOUND_FORMAT_ADPCM: u32 = 1073741824;
pub const SNDEXTCNT_FREQ_32KHZ: u32 = 0;
pub const SNDEXTCNT_FREQ_47KHZ: u32 = 8192;
pub const WRITE_STATUS_REG1: u32 = 96;
pub const READ_STATUS_REG1: u32 = 97;
pub const STATUS_POC: u32 = 128;
pub const STATUS_BLD: u32 = 64;
pub const STATUS_INT2: u32 = 32;
pub const STATUS_INT1: u32 = 16;
pub const STATUS_SC1: u32 = 8;
pub const STATUS_SC0: u32 = 4;
pub const STATUS_24HRS: u32 = 2;
pub const STATUS_RESET: u32 = 1;
pub const WRITE_STATUS_REG2: u32 = 98;
pub const READ_STATUS_REG2: u32 = 99;
pub const STATUS_TEST: u32 = 128;
pub const STATUS_INT2AE: u32 = 64;
pub const STATUS_SC3: u32 = 32;
pub const STATUS_SC2: u32 = 16;
pub const STATUS_32kE: u32 = 8;
pub const STATUS_INT1AE: u32 = 4;
pub const STATUS_INT1ME: u32 = 2;
pub const STATUS_INT1FE: u32 = 1;
pub const WRITE_TIME_AND_DATE: u32 = 100;
pub const READ_TIME_AND_DATE: u32 = 101;
pub const WRITE_TIME: u32 = 102;
pub const READ_TIME: u32 = 103;
pub const WRITE_INT_REG1: u32 = 104;
pub const READ_INT_REG1: u32 = 105;
pub const WRITE_INT_REG2: u32 = 106;
pub const READ_INT_REG2: u32 = 107;
pub const READ_CLOCK_ADJUST_REG: u32 = 108;
pub const WRITE_CLOCK_ADJUST_REG: u32 = 109;
pub const READ_FREE_REG: u32 = 110;
pub const WRITE_FREE_REG: u32 = 111;
pub const I2CREGPM_BATUNK: u32 = 0;
pub const I2CREGPM_PWRIF: u32 = 16;
pub const I2CREGPM_PWRCNT: u32 = 17;
pub const I2CREGPM_MMCPWR: u32 = 18;
pub const I2CREGPM_BATTERY: u32 = 32;
pub const I2CREGPM_CAMLED: u32 = 49;
pub const I2CREGPM_VOL: u32 = 64;
pub const I2CREGPM_RESETFLAG: u32 = 112;
pub const SDMMC_BASE: u32 = 67127296;
pub const REG_SDCMD: u32 = 0;
pub const REG_SDPORTSEL: u32 = 2;
pub const REG_SDCMDARG: u32 = 4;
pub const REG_SDCMDARG0: u32 = 4;
pub const REG_SDCMDARG1: u32 = 6;
pub const REG_SDSTOP: u32 = 8;
pub const REG_SDRESP: u32 = 12;
pub const REG_SDBLKCOUNT: u32 = 10;
pub const REG_SDRESP0: u32 = 12;
pub const REG_SDRESP1: u32 = 14;
pub const REG_SDRESP2: u32 = 16;
pub const REG_SDRESP3: u32 = 18;
pub const REG_SDRESP4: u32 = 20;
pub const REG_SDRESP5: u32 = 22;
pub const REG_SDRESP6: u32 = 24;
pub const REG_SDRESP7: u32 = 26;
pub const REG_SDSTATUS0: u32 = 28;
pub const REG_SDSTATUS1: u32 = 30;
pub const REG_SDIRMASK0: u32 = 32;
pub const REG_SDIRMASK1: u32 = 34;
pub const REG_SDCLKCTL: u32 = 36;
pub const REG_SDBLKLEN: u32 = 38;
pub const REG_SDOPT: u32 = 40;
pub const REG_SDFIFO: u32 = 48;
pub const REG_SDDATACTL: u32 = 216;
pub const REG_SDRESET: u32 = 224;
pub const REG_SDPROTECTED: u32 = 246;
pub const REG_SDDATACTL32: u32 = 256;
pub const REG_SDBLKLEN32: u32 = 260;
pub const REG_SDBLKCOUNT32: u32 = 264;
pub const REG_SDFIFO32: u32 = 268;
pub const REG_CLK_AND_WAIT_CTL: u32 = 312;
pub const REG_RESET_SDIO: u32 = 480;
pub const TMIO_STAT0_CMDRESPEND: u32 = 1;
pub const TMIO_STAT0_DATAEND: u32 = 4;
pub const TMIO_STAT0_CARD_REMOVE: u32 = 8;
pub const TMIO_STAT0_CARD_INSERT: u32 = 16;
pub const TMIO_STAT0_SIGSTATE: u32 = 32;
pub const TMIO_STAT0_WRPROTECT: u32 = 128;
pub const TMIO_STAT0_CARD_REMOVE_A: u32 = 256;
pub const TMIO_STAT0_CARD_INSERT_A: u32 = 512;
pub const TMIO_STAT0_SIGSTATE_A: u32 = 1024;
pub const TMIO_STAT1_CMD_IDX_ERR: u32 = 1;
pub const TMIO_STAT1_CRCFAIL: u32 = 2;
pub const TMIO_STAT1_STOPBIT_ERR: u32 = 4;
pub const TMIO_STAT1_DATATIMEOUT: u32 = 8;
pub const TMIO_STAT1_RXOVERFLOW: u32 = 16;
pub const TMIO_STAT1_TXUNDERRUN: u32 = 32;
pub const TMIO_STAT1_CMDTIMEOUT: u32 = 64;
pub const TMIO_STAT1_RXRDY: u32 = 256;
pub const TMIO_STAT1_TXRQ: u32 = 512;
pub const TMIO_STAT1_ILL_FUNC: u32 = 8192;
pub const TMIO_STAT1_CMD_BUSY: u32 = 16384;
pub const TMIO_STAT1_ILL_ACCESS: u32 = 32768;
pub const SDMC_NORMAL: u32 = 0;
pub const SDMC_ERR_COMMAND: u32 = 1;
pub const SDMC_ERR_CRC: u32 = 2;
pub const SDMC_ERR_END: u32 = 4;
pub const SDMC_ERR_TIMEOUT: u32 = 8;
pub const SDMC_ERR_FIFO_OVF: u32 = 16;
pub const SDMC_ERR_FIFO_UDF: u32 = 32;
pub const SDMC_ERR_WP: u32 = 64;
pub const SDMC_ERR_ABORT: u32 = 128;
pub const SDMC_ERR_FPGA_TIMEOUT: u32 = 256;
pub const SDMC_ERR_PARAM: u32 = 512;
pub const SDMC_ERR_R1_STATUS: u32 = 2048;
pub const SDMC_ERR_NUM_WR_SECTORS: u32 = 4096;
pub const SDMC_ERR_RESET: u32 = 8192;
pub const SDMC_ERR_ILA: u32 = 16384;
pub const SDMC_ERR_INFO_DETECT: u32 = 32768;
pub const SDMC_STAT_ERR_UNKNOWN: u32 = 524288;
pub const SDMC_STAT_ERR_CC: u32 = 1048576;
pub const SDMC_STAT_ERR_ECC_FAILED: u32 = 2097152;
pub const SDMC_STAT_ERR_CRC: u32 = 8388608;
pub const SDMC_STAT_ERR_OTHER: u32 = 4190568456;
pub const TMIO_MASK_ALL: u32 = 2206139165;
pub const TMIO_MASK_GW: u32 = 32895;
pub const SCREEN_WIDTH: u32 = 256;
pub const SCREEN_HEIGHT: u32 = 192;
pub const TSC_MEASURE_TEMP1: u32 = 132;
pub const TSC_MEASURE_Y: u32 = 144;
pub const TSC_MEASURE_BATTERY: u32 = 164;
pub const TSC_MEASURE_Z1: u32 = 180;
pub const TSC_MEASURE_Z2: u32 = 196;
pub const TSC_MEASURE_X: u32 = 208;
pub const TSC_MEASURE_AUX: u32 = 228;
pub const TSC_MEASURE_TEMP2: u32 = 244;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_int;
pub type __uintptr_t = ::libc::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
#[doc = "! 8 bit unsigned integer."]
pub type uint8 = u8;
#[doc = "! 16 bit unsigned integer."]
pub type uint16 = u16;
#[doc = "! 32 bit unsigned integer."]
pub type uint32 = u32;
#[doc = "! 64 bit unsigned integer."]
pub type uint64 = u64;
#[doc = "! 8 bit signed integer."]
pub type int8 = i8;
#[doc = "! 16 bit signed integer."]
pub type int16 = i16;
#[doc = "! 32 bit signed integer."]
pub type int32 = i32;
#[doc = "! 64 bit signed integer."]
pub type int64 = i64;
#[doc = "! 32 bit signed floating point number."]
pub type float32 = f32;
#[doc = "! 64 bit signed floating point number."]
pub type float64 = f64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vuint8 = u8;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vuint16 = u16;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vuint32 = u32;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vuint64 = u64;
#[doc = "! 8 bit volatile signed integer."]
pub type vint8 = i8;
#[doc = "! 16 bit volatile signed integer."]
pub type vint16 = i16;
#[doc = "! 32 bit volatile signed integer."]
pub type vint32 = i32;
#[doc = "! 64 bit volatile signed integer."]
pub type vint64 = i64;
#[doc = "! 32 bit volatile signed floating point number."]
pub type vfloat32 = float32;
#[doc = "! 64 bit volatile signed floating point number."]
pub type vfloat64 = float64;
#[doc = "! 8 bit unsigned integer."]
pub type byte = u8;
#[doc = "! 8 bit unsigned integer."]
pub type u8_ = u8;
#[doc = "! 16 bit unsigned integer."]
pub type u16_ = u16;
#[doc = "! 32 bit unsigned integer."]
pub type u32_ = u32;
#[doc = "! 64 bit unsigned integer."]
pub type u64_ = u64;
#[doc = "! 8 bit signed integer."]
pub type s8 = i8;
#[doc = "! 16 bit signed integer."]
pub type s16 = i16;
#[doc = "! 32 bit signed integer."]
pub type s32 = i32;
#[doc = "! 64 bit signed integer."]
pub type s64 = i64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vu8 = u8_;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vu16 = u16_;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vu32 = u32_;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vu64 = u64_;
#[doc = "! 8 bit volatile signed integer."]
pub type vs8 = s8;
#[doc = "! 16 bit volatile signed integer."]
pub type vs16 = s16;
#[doc = "! 32 bit volatile signed integer."]
pub type vs32 = s32;
#[doc = "! 64 bit volatile signed integer."]
pub type vs64 = s64;
pub type sec_t = u32;
#[doc = "! a function pointer that takes no arguments and doesn't return anything."]
pub type VoidFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type IntFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type fp = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "\t\\brief Should return the header of a compressed stream of bytes."]
#[doc = ""]
#[doc = "The result is a word, with the size of decompressed data in bits 8-31,"]
#[doc = "and bits 0-7 are ignored.  This value is also returned by the bios function, unless getResult is non-NULL and returns a negative value."]
#[doc = "This useally returns the 4 bytes that source points to."]
#[doc = ""]
#[doc = "\\param source \tA pointer to the compressed data."]
#[doc = "\\param dest\t\tA pointer to the space where the decompressed data should be copied to."]
#[doc = "\\param arg\t\tA callback value that gets passed to the bios function."]
#[doc = "\\return The header of the compressed data containing the length of the data and the compression type."]
pub type getHeaderCallback = ::core::option::Option<
    unsafe extern "C" fn(source: *mut u8_, dest: *mut u16_, arg: u32_) -> ::libc::c_int,
>;
#[doc = "\t\\brief Should verify the result after data got decompressed."]
#[doc = ""]
#[doc = "getResult is used to provide a result for the bios function, given the source pointer after all data has been read"]
#[doc = "(or if getSize < 0). Its value is only returned if negative, otherwise the typical result is used, so it is likely"]
#[doc = "some sort of error-checking procedure."]
#[doc = ""]
#[doc = "\\param source The current source address."]
#[doc = "\\return 0 if it went right, or a negative number if something went wrong. value will be returned from bios function if value is negative."]
pub type getResultCallback =
    ::core::option::Option<unsafe extern "C" fn(source: *mut u8_) -> ::libc::c_int>;
#[doc = "\t\\brief Should returns a raw byte of the stream."]
#[doc = "\\param source A pointer to the byte."]
#[doc = "\\return A byte."]
pub type getByteCallback = ::core::option::Option<unsafe extern "C" fn(source: *mut u8_) -> u8_>;
#[doc = "! A struct that contains callback function pointers used by the decompression functions."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DecompressionStream {
    #[doc = "!< gets called to get the header of the stream."]
    pub getSize: getHeaderCallback,
    #[doc = "!< gets called to verify the result afterwards, can be NULL (no callback)."]
    pub getResult: getResultCallback,
    #[doc = "!< gets called to get a byte of the compressed data."]
    pub readByte: getByteCallback,
}
#[doc = "! A struct that contains callback function pointers used by the decompression functions."]
pub type TDecompressionStream = DecompressionStream;
#[doc = "! A struct and struct pointer with information about unpacking data."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UnpackStruct {
    #[doc = "!< in bytes"]
    pub sourceSize: uint16,
    #[doc = "!< 1,2,4 or 8 bits."]
    pub sourceWidth: uint8,
    #[doc = "!< 1,2,4,8,16 or 32 bits."]
    pub destWidth: uint8,
    #[doc = "!< bits 0-30 are added to all non-zero destination writes, unless bit 31 is set, which does it for zeros too."]
    pub dataOffset: uint32,
}
#[doc = "! A struct and struct pointer with information about unpacking data."]
pub type TUnpackStruct = UnpackStruct;
#[doc = "! A struct and struct pointer with information about unpacking data."]
pub type PUnpackStruct = *mut UnpackStruct;
extern "C" {
    #[doc = "\\brief resets the DS."]
    pub fn swiSoftReset();
}
extern "C" {
    #[doc = "\\brief delays the code."]
    #[doc = ""]
    #[doc = "Delays for for a period X + Y*duration where X is the swi overhead and Y is a cycle of"]
    #[doc = "<CODE><PRE>"]
    #[doc = "loop:"]
    #[doc = "sub r0, #1"]
    #[doc = "bgt loop"]
    #[doc = "</PRE></CODE>"]
    #[doc = "of thumb fetches in BIOS memory"]
    #[doc = "\\param duration length of delay"]
    #[doc = "\\note Duration should be 1 or more, a duration of 0 is a huge delay."]
    pub fn swiDelay(duration: uint32);
}
extern "C" {
    #[doc = "\\brief divides 2 numbers."]
    #[doc = "\\param numerator\tsigned integer to divide"]
    #[doc = "\\param divisor\t\tsigned integer to divide by"]
    #[doc = "\\return numerator / divisor"]
    pub fn swiDivide(numerator: ::libc::c_int, divisor: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief calculate the remainder of an division."]
    #[doc = "\\param numerator\tsigned integer to divide"]
    #[doc = "\\param divisor\t\tsigned integer to divide by"]
    #[doc = "\\return numerator % divisor"]
    pub fn swiRemainder(numerator: ::libc::c_int, divisor: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief divides 2 numbers and stores both the result and the remainder."]
    #[doc = ""]
    #[doc = "\\param numerator\tsigned integer to divide"]
    #[doc = "\\param divisor\t\tsigned integer to divide by"]
    #[doc = "\\param result\t\tpointer to integer set to numerator / divisor"]
    #[doc = "\\param remainder \tpointer to integer set to numerator % divisor"]
    pub fn swiDivMod(
        numerator: ::libc::c_int,
        divisor: ::libc::c_int,
        result: *mut ::libc::c_int,
        remainder: *mut ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory."]
    #[doc = "\\param source \tpointer to transfer source or pointer to value to fill the memory with."]
    #[doc = "\\param dest\t\tpointer to transfer destination."]
    #[doc = "\\param flags\tbits(0-20): size of data to copy/fill in words,"]
    #[doc = "or'd with the copy mode size (word or halfword) and type (copy or fill)."]
    pub fn swiCopy(source: *const ::libc::c_void, dest: *mut ::libc::c_void, flags: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory."]
    #[doc = "can only copy in word chunks."]
    #[doc = "\\param source\tpointer to transfer source or pointer to value to fill the memory with."]
    #[doc = "\\param dest\t\tpointer to transfer destination."]
    #[doc = "\\param flags\tbits(0-20): size of data to copy/fill in words,"]
    #[doc = "or'd with the type (copy or fill)."]
    #[doc = ""]
    #[doc = "\\note Transfers more quickly than swiCopy, but has higher interrupt latency."]
    pub fn swiFastCopy(
        source: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        flags: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief calculates the square root."]
    #[doc = "\\param value the value to calculate."]
    #[doc = "\\return the square root of the value as an integer."]
    #[doc = "\\note use fixed point math if you want more accuracy."]
    pub fn swiSqrt(value: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief calculates a CRC-16 checksum."]
    #[doc = "\\param crc \t\tstarting CRC-16 value."]
    #[doc = "\\param data \tpointer to data (processed nibble by nibble)"]
    #[doc = "\\param size \tsize in bytes."]
    #[doc = ""]
    #[doc = "\\return the CRC-16 after the data has been processed."]
    pub fn swiCRC16(crc: uint16, data: *mut ::libc::c_void, size: uint32) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief returns 0 if running on a nintendo hardware debugger."]
    #[doc = "\\return 0 if running on a debugger (8 MB of ram instead of 4 MB), else some other number."]
    pub fn swiIsDebugger() -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Unpack data stored in multiple elements in a byte to a larger space."]
    #[doc = ""]
    #[doc = "i.e. 8 elements per byte (i.e. b/w font), into 1 element per byte."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tSource address."]
    #[doc = "\\param destination\t\tdestination address (word aligned)."]
    #[doc = "\\param params\t\t\tpointer to an UnpackStruct."]
    pub fn swiUnpackBits(source: *mut uint8, destination: *mut uint32, params: PUnpackStruct);
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data."]
    #[doc = "\\param source\t\tpointer to a header word, followed by compressed data."]
    #[doc = "bit 0-7 of header is ignored."]
    #[doc = "bit 8-31 of header is size of uncompressed data in bytes."]
    #[doc = "\\param destination\tdestination address."]
    #[doc = "\\note Writes data a byte at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressLZSSWram(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data vram safe."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset)."]
    #[doc = "\\param destination\t\tPointer to destination."]
    #[doc = "\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer."]
    #[doc = "\\param stream\t\t\tPointer to struct with callback function pointers."]
    #[doc = ""]
    #[doc = "\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions."]
    #[doc = "\\note Writes data a halfword at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressLZSSVram(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramNTR(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramTWL(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses Huffman compressed data."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset)."]
    #[doc = "\\param destination\t\tPointer to destination."]
    #[doc = "\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer."]
    #[doc = "\\param stream\t\t\tPointer to struct with callback function pointers."]
    #[doc = ""]
    #[doc = "\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressHuffman(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data."]
    #[doc = ""]
    #[doc = "compressed data format:"]
    #[doc = "bit(7): 0= uncompressed, 1= compressed."]
    #[doc = "bit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data."]
    #[doc = "bit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated."]
    #[doc = ""]
    #[doc = "\\param source\t\tpointer to a header word, followed by compressed data."]
    #[doc = "bit 0-7 of header is ignored."]
    #[doc = "bit 8-31 of header is size of uncompressed data in bytes."]
    #[doc = "\\param destination\tdestination address."]
    #[doc = "\\note Writes data a byte at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressRLEWram(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data vram safe."]
    #[doc = ""]
    #[doc = "compressed data format:"]
    #[doc = "bit(7): 0= uncompressed, 1= compressed."]
    #[doc = "bit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data."]
    #[doc = "bit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated."]
    #[doc = ""]
    #[doc = "\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset)."]
    #[doc = "\\param destination\t\tPointer to destination."]
    #[doc = "\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer."]
    #[doc = "\\param stream\t\t\tPointer to struct with callback function pointers."]
    #[doc = ""]
    #[doc = "\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions."]
    #[doc = "\\note Writes data a halfword at a time."]
    #[doc = "\\see decompress.h"]
    pub fn swiDecompressRLEVram(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Writes a byte of the data to 0x04000301:8"]
    #[doc = "\\param data The byte to write."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiSetHaltCR(data: uint8);
}
extern "C" {
    #[doc = "\t\\brief Halts the CPU untill an interupt occures."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiHalt();
}
extern "C" {
    #[doc = "\t\\brief Halts the CPU and most of the hardware untill an interupt occures."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiSleep();
}
extern "C" {
    #[doc = "\t\\brief Switches the DS to GBA mode."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiSwitchToGBAMode();
}
extern "C" {
    #[doc = "\t\\brief Returns an entry in the sine table."]
    #[doc = "\\param index The index of the sine table (0-63)."]
    #[doc = "\\return The entry."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiGetSineTable(index: ::libc::c_int) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief Returns an entry in the pitch table."]
    #[doc = "\\param index The index of the pitch table (0-767)."]
    #[doc = "\\return The entry."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiGetPitchTable(index: ::libc::c_int) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief Returns an entry in the volume table."]
    #[doc = "\\param index The index of the volume table (0-723)."]
    #[doc = "\\return The entry."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiGetVolumeTable(index: ::libc::c_int) -> uint8;
}
extern "C" {
    #[doc = "\t\\brief increments or decrements the sound bias once per delay."]
    #[doc = "\\param enabled \t0 to decrement it until it reaches 0x000, 1 to increment it until it reaches 0x200."]
    #[doc = "\\param delay \tIs in the same units of time as swiDelay."]
    #[doc = "\\note ARM7 exclusive."]
    pub fn swiChangeSoundBias(enabled: ::libc::c_int, delay: ::libc::c_int);
}
extern "C" {
    pub fn enableSlot1();
}
extern "C" {
    pub fn disableSlot1();
}
extern "C" {
    pub fn cardWriteCommand(command: *const u8_);
}
extern "C" {
    pub fn cardPolledTransfer(
        flags: u32_,
        destination: *mut u32_,
        length: u32_,
        command: *const u8_,
    );
}
extern "C" {
    pub fn cardStartTransfer(
        command: *const u8_,
        destination: *mut u32_,
        channel: ::libc::c_int,
        flags: u32_,
    );
}
extern "C" {
    pub fn cardWriteAndRead(command: *const u8_, flags: u32_) -> uint32;
}
extern "C" {
    pub fn cardParamCommand(
        command: u8_,
        parameter: u32_,
        flags: u32_,
        destination: *mut u32_,
        length: u32_,
    );
}
extern "C" {
    pub fn cardReadHeader(header: *mut u8_);
}
extern "C" {
    pub fn cardReadID(flags: u32_) -> u32_;
}
extern "C" {
    pub fn cardReset();
}
extern "C" {
    pub fn cardReadEeprom(address: u32_, data: *mut u8_, length: u32_, addrtype: u32_);
}
extern "C" {
    pub fn cardWriteEeprom(address: u32_, data: *mut u8_, length: u32_, addrtype: u32_);
}
extern "C" {
    pub fn cardEepromReadID() -> u32_;
}
extern "C" {
    pub fn cardEepromCommand(command: u8_) -> u8_;
}
extern "C" {
    pub fn cardEepromGetType() -> ::libc::c_int;
}
extern "C" {
    pub fn cardEepromGetSize() -> u32_;
}
extern "C" {
    pub fn cardEepromChipErase();
}
extern "C" {
    pub fn cardEepromSectorErase(address: u32_);
}
extern "C" {
    pub fn nocashWrite(message: *const ::libc::c_char, len: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief Send a message to the no$gba debug window"]
    #[doc = "\\param message The message to send"]
    pub fn nocashMessage(message: *const ::libc::c_char);
}
#[doc = "< vertical blank interrupt mask"]
pub const IRQ_VBLANK: IRQ_MASKS = 1;
#[doc = "< horizontal blank interrupt mask"]
pub const IRQ_HBLANK: IRQ_MASKS = 2;
#[doc = "< vcount match interrupt mask"]
pub const IRQ_VCOUNT: IRQ_MASKS = 4;
#[doc = "< timer 0 interrupt mask"]
pub const IRQ_TIMER0: IRQ_MASKS = 8;
#[doc = "< timer 1 interrupt mask"]
pub const IRQ_TIMER1: IRQ_MASKS = 16;
#[doc = "< timer 2 interrupt mask"]
pub const IRQ_TIMER2: IRQ_MASKS = 32;
#[doc = "< timer 3 interrupt mask"]
pub const IRQ_TIMER3: IRQ_MASKS = 64;
#[doc = "< serial interrupt mask"]
pub const IRQ_NETWORK: IRQ_MASKS = 128;
#[doc = "< DMA 0 interrupt mask"]
pub const IRQ_DMA0: IRQ_MASKS = 256;
#[doc = "< DMA 1 interrupt mask"]
pub const IRQ_DMA1: IRQ_MASKS = 512;
#[doc = "< DMA 2 interrupt mask"]
pub const IRQ_DMA2: IRQ_MASKS = 1024;
#[doc = "< DMA 3 interrupt mask"]
pub const IRQ_DMA3: IRQ_MASKS = 2048;
#[doc = "< Keypad interrupt mask"]
pub const IRQ_KEYS: IRQ_MASKS = 4096;
#[doc = "< GBA cartridge interrupt mask"]
pub const IRQ_CART: IRQ_MASKS = 8192;
#[doc = "< IPC sync interrupt mask"]
pub const IRQ_IPC_SYNC: IRQ_MASKS = 65536;
#[doc = "< Send FIFO empty interrupt mask"]
pub const IRQ_FIFO_EMPTY: IRQ_MASKS = 131072;
#[doc = "< Receive FIFO not empty interrupt mask"]
pub const IRQ_FIFO_NOT_EMPTY: IRQ_MASKS = 262144;
#[doc = "< interrupt mask DS Card Slot"]
pub const IRQ_CARD: IRQ_MASKS = 524288;
#[doc = "< interrupt mask"]
pub const IRQ_CARD_LINE: IRQ_MASKS = 1048576;
#[doc = "< geometry FIFO interrupt mask"]
pub const IRQ_GEOMETRY_FIFO: IRQ_MASKS = 2097152;
#[doc = "< interrupt mask DS hinge"]
pub const IRQ_LID: IRQ_MASKS = 4194304;
#[doc = "< SPI interrupt mask"]
pub const IRQ_SPI: IRQ_MASKS = 8388608;
#[doc = "< WIFI interrupt mask (ARM7)"]
pub const IRQ_WIFI: IRQ_MASKS = 16777216;
#[doc = "< 'mask' for all interrupt"]
pub const IRQ_ALL: IRQ_MASKS = -1;
#[doc = "! values allowed for REG_IE and REG_IF"]
pub type IRQ_MASKS = ::libc::c_int;
pub use self::IRQ_MASKS as IRQ_MASK;
#[doc = "< I2C interrupt mask (DSi ARM7)"]
pub const IRQ_I2C: IRQ_MASKSAUX = 64;
#[doc = "< Sdmmc interrupt mask (DSi ARM7)"]
pub const IRQ_SDMMC: IRQ_MASKSAUX = 256;
#[doc = "! values allowed for REG_AUXIE and REG_AUXIF"]
pub type IRQ_MASKSAUX = ::libc::c_uint;
#[doc = "< Disable all interrupts."]
pub const IME_DISABLE: IME_VALUE = 0;
#[doc = "< Enable all interrupts not masked out in REG_IE"]
pub const IME_ENABLE: IME_VALUE = 1;
#[doc = "! values allowed for REG_IME"]
pub type IME_VALUE = ::libc::c_uint;
extern "C" {
    pub static mut __irq_vector: [VoidFn; 0usize];
}
extern "C" {
    pub static mut __irq_flags: [vuint32; 0usize];
}
extern "C" {
    pub static mut __irq_flagsaux: [vuint32; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntTable {
    pub handler: IntFn,
    pub mask: u32_,
}
extern "C" {
    #[doc = " \\fn irqInit()"]
    #[doc = "\\brief Initialise the libnds interrupt system."]
    #[doc = ""]
    #[doc = "This function is called internally (prior to main()) to set up irqs"]
    #[doc = "on the ARM9.  It must be called on the ARM7 prior to installing irq"]
    #[doc = "handlers."]
    pub fn irqInit();
}
extern "C" {
    #[doc = " \\fn irqSet(u32 irq, VoidFn handler)"]
    #[doc = "\\brief Add a handler for the given interrupt mask."]
    #[doc = ""]
    #[doc = "Specify the handler to use for the given interrupt. This only works with"]
    #[doc = "the default interrupt handler, do not mix the use of this routine with a"]
    #[doc = "user-installed IRQ handler."]
    #[doc = "\\param irq Mask associated with the interrupt."]
    #[doc = "\\param handler Address of the function to use as an interrupt service routine"]
    #[doc = "\\note"]
    #[doc = "When any handler specifies using IRQ_VBLANK or IRQ_HBLANK, DISP_SR"]
    #[doc = "is automatically updated to include the corresponding DISP_VBLANK_IRQ or DISP_HBLANK_IRQ."]
    #[doc = ""]
    #[doc = "\\warning Only one IRQ_MASK can be specified with this function."]
    pub fn irqSet(irq: u32_, handler: VoidFn);
}
extern "C" {
    pub fn irqSetAUX(irq: u32_, handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqClear(u32 irq)"]
    #[doc = "\\brief remove the handler associated with the interrupt mask irq."]
    #[doc = "\\param irq Mask associated with the interrupt."]
    pub fn irqClear(irq: u32_);
}
extern "C" {
    pub fn irqClearAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn irqInitHandler(VoidFn handler)"]
    #[doc = "\\brief Install a user interrupt dispatcher."]
    #[doc = ""]
    #[doc = "This function installs the main interrupt function, all interrupts are serviced through this routine. For most"]
    #[doc = "purposes the libnds interrupt dispacther should be used in preference to user code unless you know *exactly* what you're doing."]
    #[doc = ""]
    #[doc = "\\param handler Address of the function to use as an interrupt dispatcher"]
    #[doc = "\\note the function *must* be ARM code"]
    pub fn irqInitHandler(handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqEnable(u32 irq)"]
    #[doc = "\\brief Allow the given interrupt to occur."]
    #[doc = "\\param irq The set of interrupt masks to enable."]
    #[doc = "\\note Specify multiple interrupts to enable by ORing several IRQ_MASKS."]
    pub fn irqEnable(irq: u32_);
}
extern "C" {
    pub fn irqEnableAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn irqDisable(u32 irq)"]
    #[doc = "\\brief Prevent the given interrupt from occuring."]
    #[doc = "\\param irq The set of interrupt masks to disable."]
    #[doc = "\\note Specify multiple interrupts to disable by ORing several IRQ_MASKS."]
    pub fn irqDisable(irq: u32_);
}
extern "C" {
    pub fn irqDisableAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn swiIntrWait(u32 waitForSet, uint32 flags)"]
    #[doc = ""]
    #[doc = "\\brief wait for interrupt(s) to occur"]
    #[doc = ""]
    #[doc = "\\param waitForSet"]
    #[doc = "0: Return if the interrupt has already occured"]
    #[doc = "1: Wait until the interrupt has been set since the call"]
    #[doc = "\\param flags"]
    #[doc = "interrupt mask to wait for"]
    pub fn swiIntrWait(waitForSet: u32_, flags: uint32);
}
extern "C" {
    #[doc = " \\fn  swiWaitForVBlank()"]
    #[doc = "\\brief Wait for vblank interrupt"]
    #[doc = ""]
    #[doc = "Waits for a vertical blank interrupt"]
    #[doc = ""]
    #[doc = "\\note Identical to calling swiIntrWait(1, 1)"]
    pub fn swiWaitForVBlank();
}
extern "C" {
    #[doc = " \\fn  VoidFn setPowerButtonCB(VoidFn CB);"]
    #[doc = "\\brief set callback for DSi Powerbutton press"]
    #[doc = ""]
    #[doc = "\\param CB"]
    #[doc = "function to call when power button pressed"]
    #[doc = "\\return"]
    #[doc = "the previously set callback"]
    pub fn setPowerButtonCB(CB: VoidFn) -> VoidFn;
}
pub const IPC_SYNC_IRQ_ENABLE: IPC_SYNC_BITS = 16384;
pub const IPC_SYNC_IRQ_REQUEST: IPC_SYNC_BITS = 8192;
pub type IPC_SYNC_BITS = ::libc::c_uint;
pub const IPC_FIFO_SEND_EMPTY: IPC_CONTROL_BITS = 1;
pub const IPC_FIFO_SEND_FULL: IPC_CONTROL_BITS = 2;
pub const IPC_FIFO_SEND_IRQ: IPC_CONTROL_BITS = 4;
pub const IPC_FIFO_SEND_CLEAR: IPC_CONTROL_BITS = 8;
pub const IPC_FIFO_RECV_EMPTY: IPC_CONTROL_BITS = 256;
pub const IPC_FIFO_RECV_FULL: IPC_CONTROL_BITS = 512;
pub const IPC_FIFO_RECV_IRQ: IPC_CONTROL_BITS = 1024;
pub const IPC_FIFO_ERROR: IPC_CONTROL_BITS = 16384;
pub const IPC_FIFO_ENABLE: IPC_CONTROL_BITS = 32768;
pub type IPC_CONTROL_BITS = ::libc::c_uint;
extern "C" {
    pub fn __assert(arg1: *const ::libc::c_char, arg2: ::libc::c_int, arg3: *const ::libc::c_char);
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
        arg4: *const ::libc::c_char,
    );
}
#[doc = "\\brief the GBA file header format."]
#[doc = "See gbatek for more info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sGBAHeader {
    #[doc = "!< 32 bits arm opcode to jump to executable code."]
    pub entryPoint: u32_,
    #[doc = "!< nintendo logo needed for booting the game."]
    pub logo: [u8_; 156usize],
    #[doc = "!< 12 characters for the game title."]
    pub title: [::libc::c_char; 12usize],
    #[doc = "!< 4 characters for the game code. first character is usally A or B, next 2 characters is a short title"]
    #[doc = "!< and last character is for destination/language."]
    pub gamecode: [::libc::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: u16_,
    #[doc = "!< fixed value that is always 96h."]
    pub is96h: u8_,
    #[doc = "!< identifies the required hardware."]
    pub unitcode: u8_,
    #[doc = "!< used by nintedo's hardware debuggers. normally 0."]
    pub devicecode: u8_,
    pub unused: [u8_; 7usize],
    #[doc = "!< the version of the game."]
    pub version: u8_,
    #[doc = "!< complement checksum of the gba header."]
    pub complement: u8_,
    #[doc = "!< a 16 bit checksum? (gbatek says its unused/reserved)."]
    pub checksum: u16_,
}
impl Default for sGBAHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the GBA file header format."]
#[doc = "See gbatek for more info."]
pub type tGBAHeader = sGBAHeader;
#[doc = "\\brief the NDS file header format"]
#[doc = "See gbatek for more info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sNDSHeader {
    #[doc = "!< 12 characters for the game title."]
    pub gameTitle: [::libc::c_char; 12usize],
    #[doc = "!< 4 characters for the game code."]
    pub gameCode: [::libc::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: [::libc::c_char; 2usize],
    #[doc = "!< identifies the required hardware."]
    pub unitCode: u8_,
    #[doc = "!< type of device in the game card"]
    pub deviceType: u8_,
    #[doc = "!< capacity of the device (1 << n Mbit)"]
    pub deviceSize: u8_,
    pub reserved1: [u8_; 9usize],
    #[doc = "!< version of the ROM."]
    pub romversion: u8_,
    #[doc = "!< bit 2: auto-boot flag."]
    pub flags: u8_,
    #[doc = "!< offset of the arm9 binary in the nds file."]
    pub arm9romOffset: u32_,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm9executeAddress: *mut ::libc::c_void,
    #[doc = "!< destination address to where the arm9 binary should be copied."]
    pub arm9destination: *mut ::libc::c_void,
    #[doc = "!< size of the arm9 binary."]
    pub arm9binarySize: u32_,
    #[doc = "!< offset of the arm7 binary in the nds file."]
    pub arm7romOffset: u32_,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm7executeAddress: *mut ::libc::c_void,
    #[doc = "!< destination address to where the arm7 binary should be copied."]
    pub arm7destination: *mut ::libc::c_void,
    #[doc = "!< size of the arm7 binary."]
    pub arm7binarySize: u32_,
    #[doc = "!< File Name Table (FNT) offset."]
    pub filenameOffset: u32_,
    #[doc = "!< File Name Table (FNT) size."]
    pub filenameSize: u32_,
    #[doc = "!< File Allocation Table (FAT) offset."]
    pub fatOffset: u32_,
    #[doc = "!< File Allocation Table (FAT) size."]
    pub fatSize: u32_,
    #[doc = "!< File arm9 overlay offset."]
    pub arm9overlaySource: u32_,
    #[doc = "!< File arm9 overlay size."]
    pub arm9overlaySize: u32_,
    #[doc = "!< File arm7 overlay offset."]
    pub arm7overlaySource: u32_,
    #[doc = "!< File arm7 overlay size."]
    pub arm7overlaySize: u32_,
    #[doc = "!< Port 40001A4h setting for normal commands (used in modes 1 and 3)"]
    pub cardControl13: u32_,
    #[doc = "!< Port 40001A4h setting for KEY1 commands (used in mode 2)"]
    pub cardControlBF: u32_,
    #[doc = "!< offset to the banner with icon and titles etc."]
    pub bannerOffset: u32_,
    #[doc = "!< Secure Area Checksum, CRC-16."]
    pub secureCRC16: u16_,
    #[doc = "!< Secure Area Loading Timeout."]
    pub readTimeout: u16_,
    #[doc = "!< ARM9 Auto Load List RAM Address (?)"]
    pub unknownRAM1: u32_,
    #[doc = "!< ARM7 Auto Load List RAM Address (?)"]
    pub unknownRAM2: u32_,
    #[doc = "!< Secure Area Disable part 1."]
    pub bfPrime1: u32_,
    #[doc = "!< Secure Area Disable part 2."]
    pub bfPrime2: u32_,
    #[doc = "!< total size of the ROM."]
    pub romSize: u32_,
    #[doc = "!< ROM header size."]
    pub headerSize: u32_,
    pub zeros88: [u32_; 14usize],
    #[doc = "!< Nintendo logo needed for booting the game."]
    pub gbaLogo: [u8_; 156usize],
    #[doc = "!< Nintendo Logo Checksum, CRC-16."]
    pub logoCRC16: u16_,
    #[doc = "!< header checksum, CRC-16."]
    pub headerCRC16: u16_,
}
impl Default for sNDSHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the NDS file header format"]
#[doc = "See gbatek for more info."]
pub type tNDSHeader = sNDSHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __DSiHeader {
    pub ndshdr: tNDSHeader,
    #[doc = "!< debug ROM offset."]
    pub debugRomSource: u32_,
    #[doc = "!< debug size."]
    pub debugRomSize: u32_,
    #[doc = "!< debug RAM destination."]
    pub debugRomDestination: u32_,
    pub offset_0x16C: u32_,
    pub zero: [u8_; 16usize],
    pub global_mbk_setting: [[u8_; 4usize]; 5usize],
    pub arm9_mbk_setting: [u32_; 3usize],
    pub arm7_mbk_setting: [u32_; 3usize],
    pub mbk9_wramcnt_setting: u32_,
    pub region_flags: u32_,
    pub access_control: u32_,
    pub scfg_ext_mask: u32_,
    pub offset_0x1BC: [u8_; 3usize],
    pub appflags: u8_,
    pub arm9iromOffset: *mut ::libc::c_void,
    pub offset_0x1C4: u32_,
    pub arm9idestination: *mut ::libc::c_void,
    pub arm9ibinarySize: u32_,
    pub arm7iromOffset: *mut ::libc::c_void,
    pub offset_0x1D4: u32_,
    pub arm7idestination: *mut ::libc::c_void,
    pub arm7ibinarySize: u32_,
    pub digest_ntr_start: u32_,
    pub digest_ntr_size: u32_,
    pub digest_twl_start: u32_,
    pub digest_twl_size: u32_,
    pub sector_hashtable_start: u32_,
    pub sector_hashtable_size: u32_,
    pub block_hashtable_start: u32_,
    pub block_hashtable_size: u32_,
    pub digest_sector_size: u32_,
    pub digest_block_sectorcount: u32_,
    pub banner_size: u32_,
    pub offset_0x20C: u32_,
    pub total_rom_size: u32_,
    pub offset_0x214: u32_,
    pub offset_0x218: u32_,
    pub offset_0x21C: u32_,
    pub modcrypt1_start: u32_,
    pub modcrypt1_size: u32_,
    pub modcrypt2_start: u32_,
    pub modcrypt2_size: u32_,
    pub tid_low: u32_,
    pub tid_high: u32_,
    pub public_sav_size: u32_,
    pub private_sav_size: u32_,
    pub reserved3: [u8_; 176usize],
    pub age_ratings: [u8_; 16usize],
    pub hmac_arm9: [u8_; 20usize],
    pub hmac_arm7: [u8_; 20usize],
    pub hmac_digest_master: [u8_; 20usize],
    pub hmac_icon_title: [u8_; 20usize],
    pub hmac_arm9i: [u8_; 20usize],
    pub hmac_arm7i: [u8_; 20usize],
    pub reserved4: [u8_; 40usize],
    pub hmac_arm9_no_secure: [u8_; 20usize],
    pub reserved5: [u8_; 2636usize],
    pub debug_args: [u8_; 384usize],
    pub rsa_signature: [u8_; 128usize],
}
impl Default for __DSiHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type tDSiHeader = __DSiHeader;
#[doc = "\\brief the NDS banner format."]
#[doc = "See gbatek for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sNDSBanner {
    #[doc = "!< version of the banner."]
    pub version: u16_,
    #[doc = "!< 16 bit crc/checksum of the banner."]
    pub crc: u16_,
    pub reserved: [u8_; 28usize],
    #[doc = "!< 32*32 icon of the game with 4 bit per pixel."]
    pub icon: [u8_; 512usize],
    #[doc = "!< the pallete of the icon."]
    pub palette: [u16_; 16usize],
    #[doc = "!< title of the game in 6 different languages."]
    pub titles: [[u16_; 128usize]; 6usize],
}
impl Default for sNDSBanner {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the NDS banner format."]
#[doc = "See gbatek for more information."]
pub type tNDSBanner = sNDSBanner;
#[doc = "!<\tThe display currently in a vertical blank."]
pub const DISP_IN_VBLANK: DISP_BITS = 1;
#[doc = "!<\tThe display currently in a horizontal blank."]
pub const DISP_IN_HBLANK: DISP_BITS = 2;
#[doc = "!<\tCurrent scanline and %DISP_Y match."]
pub const DISP_YTRIGGERED: DISP_BITS = 4;
#[doc = "!<\tInterrupt on vertical blank."]
pub const DISP_VBLANK_IRQ: DISP_BITS = 8;
#[doc = "!<\tInterrupt on horizontal blank."]
pub const DISP_HBLANK_IRQ: DISP_BITS = 16;
#[doc = "!<\tInterrupt when current scanline and %DISP_Y match."]
pub const DISP_YTRIGGER_IRQ: DISP_BITS = 32;
#[doc = "! LCD Status register bitdefines"]
pub type DISP_BITS = ::libc::c_uint;
#[doc = "!< Power the sound hardware (needed to hear stuff in GBA mode too)."]
pub const PM_SOUND_AMP: PM_Bits = 1;
#[doc = "!< Mute the main speakers, headphone output will still work."]
pub const PM_SOUND_MUTE: PM_Bits = 2;
#[doc = "!< Enable the bottom backlight if set."]
pub const PM_BACKLIGHT_BOTTOM: PM_Bits = 4;
#[doc = "!< Enable the top backlight if set."]
pub const PM_BACKLIGHT_TOP: PM_Bits = 8;
#[doc = "!< Turn the power *off* if set."]
pub const PM_SYSTEM_PWR: PM_Bits = 64;
#[doc = "!<\tControls the power for both LCD screens."]
pub const POWER_LCD: PM_Bits = 65537;
#[doc = "!<\tControls the power for the main 2D core."]
pub const POWER_2D_A: PM_Bits = 65538;
#[doc = "!<\tControls the power for the 3D matrix."]
pub const POWER_MATRIX: PM_Bits = 65540;
#[doc = "!<\tControls the power for the main 3D core."]
pub const POWER_3D_CORE: PM_Bits = 65544;
#[doc = "!<\tControls the power for the sub 2D core."]
pub const POWER_2D_B: PM_Bits = 66048;
#[doc = "!<\tControls which screen should use the main core."]
pub const POWER_SWAP_LCDS: PM_Bits = 98304;
#[doc = "!< power just 2D hardware."]
pub const POWER_ALL_2D: PM_Bits = 66051;
#[doc = "!< power everything."]
pub const POWER_ALL: PM_Bits = 66063;
#[doc = "! Power Management control bits"]
pub type PM_Bits = ::libc::c_uint;
extern "C" {
    #[doc = "\t\\brief Causes the nds to go to sleep."]
    #[doc = "The nds will be reawakened when the lid is opened."]
    #[doc = ""]
    #[doc = "\\note By default, this is automatically called when closing the lid."]
    pub fn systemSleep();
}
extern "C" {
    #[doc = "\tSet the LED blink mode"]
    #[doc = "\\param bm What to power on."]
    pub fn ledBlink(bm: ::libc::c_int);
}
#[doc = "!<\tControls the power for the sound controller."]
pub const POWER_SOUND: ARM7_power = 1;
#[doc = "!<\tSelects the PM control register"]
pub const PM_CONTROL_REG: ARM7_power = 0;
#[doc = "!<\tSelects the PM battery register"]
pub const PM_BATTERY_REG: ARM7_power = 1;
#[doc = "!<\tSelects the PM amplifier register"]
pub const PM_AMPLIFIER_REG: ARM7_power = 2;
#[doc = "!<\tSelects the PM read register"]
pub const PM_READ_REGISTER: ARM7_power = 128;
#[doc = "!<\tSelects the PM amp register"]
pub const PM_AMP_OFFSET: ARM7_power = 2;
#[doc = "!<\tSelects the PM gain register"]
pub const PM_GAIN_OFFSET: ARM7_power = 3;
#[doc = "!<\tSelects the DS Lite backlight register"]
pub const PM_BACKLIGHT_LEVEL: ARM7_power = 4;
#[doc = "!<\tSets the mic gain to 20db"]
pub const PM_GAIN_20: ARM7_power = 0;
#[doc = "!<\tSets the mic gain to 40db"]
pub const PM_GAIN_40: ARM7_power = 1;
#[doc = "!<\tSets the mic gain to 80db"]
pub const PM_GAIN_80: ARM7_power = 2;
#[doc = "!<\tSets the mic gain to 160db"]
pub const PM_GAIN_160: ARM7_power = 3;
#[doc = "!<\tTurns the sound amp on"]
pub const PM_AMP_ON: ARM7_power = 1;
#[doc = "!<\tTurns the sound amp off"]
pub const PM_AMP_OFF: ARM7_power = 0;
#[doc = "!\tPower-controlled hardware devices accessable to the ARM7."]
#[doc = "*!\tNote that these should only be used when programming for"]
#[doc = "the ARM7.  Trying to boot up these hardware devices via"]
#[doc = "the ARM9 would lead to unexpected results."]
#[doc = "ARM7 only."]
#[doc = "*/"]
pub type ARM7_power = ::libc::c_uint;
extern "C" {
    pub fn installSystemFIFO();
}
extern "C" {
    pub fn sleepEnabled() -> ::libc::c_int;
}
extern "C" {
    pub fn writePowerManagement(reg: ::libc::c_int, command: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn readUserSettings();
}
extern "C" {
    pub fn systemShutDown();
}
#[doc = "!< low backlight setting."]
pub const BACKLIGHT_LOW: BACKLIGHT_LEVELS = 0;
#[doc = "!< medium backlight setting."]
pub const BACKLIGHT_MED: BACKLIGHT_LEVELS = 1;
#[doc = "!< high backlight setting."]
pub const BACKLIGHT_HIGH: BACKLIGHT_LEVELS = 2;
#[doc = "!< max backlight setting."]
pub const BACKLIGHT_MAX: BACKLIGHT_LEVELS = 3;
#[doc = "\t\\brief Backlight level settings."]
#[doc = "Note, these are only available on DS Lite."]
pub type BACKLIGHT_LEVELS = ::libc::c_uint;
#[doc = "\\brief User's DS settings."]
#[doc = "Defines the structure the DS firmware uses for transfer"]
#[doc = "of the user's settings to the booted program."]
#[doc = ""]
#[doc = "Theme/Color values:"]
#[doc = "- 0 = Gray"]
#[doc = "- 1 = Brown"]
#[doc = "- 2 = Red"]
#[doc = "- 3 = Pink"]
#[doc = "- 4 = Orange"]
#[doc = "- 5 = Yellow"]
#[doc = "- 6 = Yellow/Green-ish"]
#[doc = "- 7 = Green"]
#[doc = "- 8 = Dark Green"]
#[doc = "- 9 = Green/Blue-ish"]
#[doc = "- 10 = Light Blue"]
#[doc = "- 11 = Blue"]
#[doc = "- 12 = Dark Blue"]
#[doc = "- 13 = Dark Purple"]
#[doc = "- 14 = Purple"]
#[doc = "- 15 = Purple/Red-ish"]
#[doc = ""]
#[doc = "Language values:"]
#[doc = "- 0 = Japanese"]
#[doc = "- 1 = English"]
#[doc = "- 2 = French"]
#[doc = "- 3 = German"]
#[doc = "- 4 = Italian"]
#[doc = "- 5 = Spanish"]
#[doc = "- 6 = Chinese(?)"]
#[doc = "- 7 = Unknown/Reserved"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tPERSONAL_DATA {
    pub RESERVED0: [u8_; 2usize],
    #[doc = "!<\tThe user's theme color (0-15)."]
    pub theme: u8_,
    #[doc = "!<\tThe user's birth month (1-12)."]
    pub birthMonth: u8_,
    #[doc = "!<\tThe user's birth day (1-31)."]
    pub birthDay: u8_,
    pub RESERVED1: [u8_; 1usize],
    #[doc = "!<\tThe user's name in UTF-16 format."]
    pub name: [s16; 10usize],
    #[doc = "!<\tThe length of the user's name in characters."]
    pub nameLen: u16_,
    #[doc = "!<\tThe user's message."]
    pub message: [s16; 26usize],
    #[doc = "!<\tThe length of the user's message in characters."]
    pub messageLen: u16_,
    #[doc = "!<\tWhat hour the alarm clock is set to (0-23)."]
    pub alarmHour: u8_,
    #[doc = "!<\tWhat minute the alarm clock is set to (0-59)."]
    pub alarmMinute: u8_,
    pub RESERVED2: [u8_; 4usize],
    #[doc = "!<\tTouchscreen calibration: first X touch"]
    pub calX1: u16_,
    #[doc = "!<\tTouchscreen calibration: first Y touch"]
    pub calY1: u16_,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calX1px: u8_,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calY1px: u8_,
    #[doc = "!<\tTouchscreen calibration: second X touch"]
    pub calX2: u16_,
    #[doc = "!<\tTouchscreen calibration: second Y touch"]
    pub calY2: u16_,
    #[doc = "!<\tTouchscreen calibration: second X touch pixel"]
    pub calX2px: u8_,
    #[doc = "!<\tTouchscreen calibration: second Y touch pixel"]
    pub calY2px: u8_,
    pub __bindgen_anon_1: tPERSONAL_DATA__bindgen_ty_1,
    pub RESERVED3: u16_,
    #[doc = "!<\tReal Time Clock offset."]
    pub rtcOffset: u32_,
    pub RESERVED4: u32_,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tPERSONAL_DATA__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tPERSONAL_DATA__bindgen_ty_1 {
    #[inline]
    pub fn language(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_language(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn gbaScreen(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gbaScreen(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn defaultBrightness(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_defaultBrightness(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn autoMode(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoMode(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED5(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED5(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn settingsLost(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_settingsLost(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED6(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED6(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        language: ::libc::c_uint,
        gbaScreen: ::libc::c_uint,
        defaultBrightness: ::libc::c_uint,
        autoMode: ::libc::c_uint,
        RESERVED5: ::libc::c_uint,
        settingsLost: ::libc::c_uint,
        RESERVED6: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let language: u32 = unsafe { ::core::mem::transmute(language) };
            language as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gbaScreen: u32 = unsafe { ::core::mem::transmute(gbaScreen) };
            gbaScreen as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let defaultBrightness: u32 = unsafe { ::core::mem::transmute(defaultBrightness) };
            defaultBrightness as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let autoMode: u32 = unsafe { ::core::mem::transmute(autoMode) };
            autoMode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let RESERVED5: u32 = unsafe { ::core::mem::transmute(RESERVED5) };
            RESERVED5 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let settingsLost: u32 = unsafe { ::core::mem::transmute(settingsLost) };
            settingsLost as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let RESERVED6: u32 = unsafe { ::core::mem::transmute(RESERVED6) };
            RESERVED6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "\\brief User's DS settings."]
#[doc = "Defines the structure the DS firmware uses for transfer"]
#[doc = "of the user's settings to the booted program."]
#[doc = ""]
#[doc = "Theme/Color values:"]
#[doc = "- 0 = Gray"]
#[doc = "- 1 = Brown"]
#[doc = "- 2 = Red"]
#[doc = "- 3 = Pink"]
#[doc = "- 4 = Orange"]
#[doc = "- 5 = Yellow"]
#[doc = "- 6 = Yellow/Green-ish"]
#[doc = "- 7 = Green"]
#[doc = "- 8 = Dark Green"]
#[doc = "- 9 = Green/Blue-ish"]
#[doc = "- 10 = Light Blue"]
#[doc = "- 11 = Blue"]
#[doc = "- 12 = Dark Blue"]
#[doc = "- 13 = Dark Purple"]
#[doc = "- 14 = Purple"]
#[doc = "- 15 = Purple/Red-ish"]
#[doc = ""]
#[doc = "Language values:"]
#[doc = "- 0 = Japanese"]
#[doc = "- 1 = English"]
#[doc = "- 2 = French"]
#[doc = "- 3 = German"]
#[doc = "- 4 = Italian"]
#[doc = "- 5 = Spanish"]
#[doc = "- 6 = Chinese(?)"]
#[doc = "- 7 = Unknown/Reserved"]
pub type PERSONAL_DATA = tPERSONAL_DATA;
#[doc = "! struct containing time and day of the real time clock."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTCtime {
    #[doc = "!< add 2000 to get 4 digit year"]
    pub year: u8_,
    #[doc = "!< 1 to 12"]
    pub month: u8_,
    #[doc = "!< 1 to (days in month)"]
    pub day: u8_,
    #[doc = "!< day of week"]
    pub weekday: u8_,
    #[doc = "!< 0 to 11 for AM, 52 to 63 for PM"]
    pub hours: u8_,
    #[doc = "!< 0 to 59"]
    pub minutes: u8_,
    #[doc = "!< 0 to 59"]
    pub seconds: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __argv {
    pub argvMagic: ::libc::c_int,
    pub commandLine: *mut ::libc::c_char,
    pub length: ::libc::c_int,
    pub argc: ::libc::c_int,
    pub argv: *mut *mut ::libc::c_char,
    pub dummy: ::libc::c_int,
    pub host: u32_,
}
impl Default for __argv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __bootstub {
    pub bootsig: u64_,
    pub arm9reboot: VoidFn,
    pub arm7reboot: VoidFn,
    pub bootsize: u32_,
}
extern "C" {
    pub fn resetARM9(address: u32_);
}
#[doc = "!< divides the timer clock by 1 (~33513.982 kHz)"]
pub const ClockDivider_1: ClockDivider = 0;
#[doc = "!< divides the timer clock by 64 (~523.657 kHz)"]
pub const ClockDivider_64: ClockDivider = 1;
#[doc = "!< divides the timer clock by 256 (~130.914 kHz)"]
pub const ClockDivider_256: ClockDivider = 2;
#[doc = "!< divides the timer clock by 1024 (~32.7284 kHz)"]
pub const ClockDivider_1024: ClockDivider = 3;
#[doc = "! allowable timer clock dividers."]
pub type ClockDivider = ::libc::c_uint;
extern "C" {
    #[doc = "\t\\brief start a hardware timer."]
    #[doc = "Callback is tied directly to interrupt table and called directly, resulting in less latency than the attached timer."]
    #[doc = "\\param timer \tThe hardware timer to use (0 - 3)."]
    #[doc = "\\param divider \tThe timer channel clock divider (clock will tick at 33.513982 MHz / divider)"]
    #[doc = "\\param ticks\tThe number of ticks which must elapse before the timer overflows"]
    #[doc = "\\param callback The callback to be called when the timer expires (if null, no IRQ will be generated by the timer)"]
    pub fn timerStart(timer: ::libc::c_int, divider: ClockDivider, ticks: u16_, callback: VoidFn);
}
extern "C" {
    #[doc = "\t\\brief returns the ticks elapsed since the last call to timerElapsed()."]
    #[doc = "\\param timer The hardware timer to use (0 - 3)."]
    #[doc = "\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerElapsed(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief pauses the specified timer."]
    #[doc = "\\param timer The hardware timer to use (0 - 3)."]
    #[doc = "\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerPause(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief Stops the specified timer."]
    #[doc = "\\param timer The hardware timer to use (0 - 3)."]
    #[doc = "\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerStop(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief begins cpu Timing using two timers for 32bit resolution."]
    #[doc = "\\param timer The base hardware timer to use (0 - 2)."]
    pub fn cpuStartTiming(timer: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief returns the number of ticks which have elapsed since cpuStartTiming."]
    #[doc = "\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuGetTiming() -> u32_;
}
extern "C" {
    #[doc = "\t\\brief ends cpu Timing."]
    #[doc = "\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuEndTiming() -> u32_;
}
#[doc = "< \\brief fifo channel reserved for power management."]
pub const FIFO_PM: FifoChannels = 0;
#[doc = "< \\brief fifo channel reserved for sound access."]
pub const FIFO_SOUND: FifoChannels = 1;
#[doc = "< \\brief fifo channel reserved for system functions."]
pub const FIFO_SYSTEM: FifoChannels = 2;
#[doc = "< \\brief fifo channel reserved for the maxmod library."]
pub const FIFO_MAXMOD: FifoChannels = 3;
#[doc = "< \\brief fifo channel reserved for the dswifi library."]
pub const FIFO_DSWIFI: FifoChannels = 4;
#[doc = "< \\brief fifo channel reserved for dsi sdmmc control."]
pub const FIFO_SDMMC: FifoChannels = 5;
#[doc = "< \\brief fifo channel reserved for firmware access."]
pub const FIFO_FIRMWARE: FifoChannels = 6;
#[doc = "< \\brief fifo channel reserved for future use."]
pub const FIFO_RSVD_01: FifoChannels = 7;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_01: FifoChannels = 8;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_02: FifoChannels = 9;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_03: FifoChannels = 10;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_04: FifoChannels = 11;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_05: FifoChannels = 12;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_06: FifoChannels = 13;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_07: FifoChannels = 14;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_08: FifoChannels = 15;
#[doc = "! Enum values for the different fifo channels."]
pub type FifoChannels = ::libc::c_uint;
pub const SOUND_SET_PAN: FifoSoundCommand = 0;
pub const SOUND_SET_VOLUME: FifoSoundCommand = 1048576;
pub const SOUND_SET_FREQ: FifoSoundCommand = 2097152;
pub const SOUND_SET_WAVEDUTY: FifoSoundCommand = 3145728;
pub const SOUND_MASTER_ENABLE: FifoSoundCommand = 4194304;
pub const SOUND_MASTER_DISABLE: FifoSoundCommand = 5242880;
pub const SOUND_PAUSE: FifoSoundCommand = 6291456;
pub const SOUND_RESUME: FifoSoundCommand = 7340032;
pub const SOUND_KILL: FifoSoundCommand = 8388608;
pub const SOUND_SET_MASTER_VOL: FifoSoundCommand = 9437184;
pub const MIC_STOP: FifoSoundCommand = 10485760;
#[doc = "! Enum values for the fifo sound commands."]
pub type FifoSoundCommand = ::libc::c_uint;
pub const SYS_REQ_TOUCH: FifoSystemCommands = 0;
pub const SYS_REQ_KEYS: FifoSystemCommands = 1;
pub const SYS_REQ_TIME: FifoSystemCommands = 2;
pub const SYS_SET_TIME: FifoSystemCommands = 3;
pub const SDMMC_INSERT: FifoSystemCommands = 4;
pub const SDMMC_REMOVE: FifoSystemCommands = 5;
#[doc = "! Enum values for the fifo system commands."]
pub type FifoSystemCommands = ::libc::c_uint;
pub const SDMMC_HAVE_SD: FifoSdmmcCommands = 0;
pub const SDMMC_SD_START: FifoSdmmcCommands = 1;
pub const SDMMC_SD_IS_INSERTED: FifoSdmmcCommands = 2;
pub const SDMMC_SD_STOP: FifoSdmmcCommands = 3;
pub const SDMMC_NAND_START: FifoSdmmcCommands = 4;
pub const SDMMC_NAND_STOP: FifoSdmmcCommands = 5;
pub const SDMMC_NAND_SIZE: FifoSdmmcCommands = 6;
pub type FifoSdmmcCommands = ::libc::c_uint;
pub const FW_READ: FifoFirmwareCommands = 0;
pub const FW_WRITE: FifoFirmwareCommands = 1;
pub type FifoFirmwareCommands = ::libc::c_uint;
pub const PM_REQ_ON: FifoPMCommands = 65536;
pub const PM_REQ_OFF: FifoPMCommands = 131072;
pub const PM_REQ_LED: FifoPMCommands = 196608;
pub const PM_REQ_SLEEP: FifoPMCommands = 262144;
pub const PM_REQ_SLEEP_DISABLE: FifoPMCommands = 327680;
pub const PM_REQ_SLEEP_ENABLE: FifoPMCommands = 393216;
pub const PM_REQ_BATTERY: FifoPMCommands = 458752;
pub const PM_REQ_SLOT1_DISABLE: FifoPMCommands = 524288;
pub const PM_REQ_SLOT1_ENABLE: FifoPMCommands = 589824;
#[doc = "! Enum values for the fifo power management commands."]
pub type FifoPMCommands = ::libc::c_uint;
pub const WIFI_ENABLE: FifoWifiCommands = 0;
pub const WIFI_DISABLE: FifoWifiCommands = 1;
pub const WIFI_SYNC: FifoWifiCommands = 2;
pub const WIFI_STARTUP: FifoWifiCommands = 3;
#[doc = "! Enum values for the fifo wifi commands."]
pub type FifoWifiCommands = ::libc::c_uint;
#[doc = "< \\brief  Steady on"]
pub const PM_LED_ON: PM_LedBlinkMode = 0;
#[doc = "< \\brief Blinking, mostly off"]
pub const PM_LED_SLEEP: PM_LedBlinkMode = 1;
#[doc = "< \\brief Blinking, mostly on"]
pub const PM_LED_BLINK: PM_LedBlinkMode = 3;
#[doc = "! Power Management LED blink mode control bits."]
pub type PM_LedBlinkMode = ::libc::c_uint;
#[doc = "\\brief fifo callback function pointer with the sent address and the callback's user data."]
#[doc = ""]
#[doc = "The handler is called when new data arrives."]
#[doc = ""]
#[doc = "\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,"]
#[doc = "but don't call alloc, free or printf from within them, just to be safe."]
pub type FifoAddressHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(address: *mut ::libc::c_void, userdata: *mut ::libc::c_void),
>;
#[doc = "\\brief fifo callback function pointer with the sent value and the callback's user data."]
#[doc = ""]
#[doc = "The handler is called when new data arrives."]
#[doc = ""]
#[doc = "\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,"]
#[doc = "but don't call alloc, free or printf from within them, just to be safe."]
pub type FifoValue32HandlerFunc =
    ::core::option::Option<unsafe extern "C" fn(value32: u32_, userdata: *mut ::libc::c_void)>;
#[doc = "\\brief fifo callback function pointer with the number of bytes sent and the callback's user data"]
#[doc = ""]
#[doc = "The handler is called when new data arrives."]
#[doc = "This callback must call fifoGetData to actually retrieve the data. If it doesn't, the data will be destroyed on return."]
#[doc = ""]
#[doc = "\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,"]
#[doc = "but don't call alloc, free or printf from within them, just to be safe."]
pub type FifoDatamsgHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(num_bytes: ::libc::c_int, userdata: *mut ::libc::c_void),
>;
extern "C" {
    #[doc = "\\brief Initializes the fifo system."]
    #[doc = ""]
    #[doc = "Attempts to sync with the other CPU, if it fails, fifo services won't be provided."]
    #[doc = ""]
    #[doc = "\\note call irqInit() before calling this function."]
    #[doc = ""]
    #[doc = "\\return true if syncing worked, false if something went wrong."]
    pub fn fifoInit() -> bool;
}
extern "C" {
    #[doc = "\\brief Send an address to an channel."]
    #[doc = ""]
    #[doc = "Transmits an address in the range 0x02000000-0x023FFFFF to the other CPU."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param address address to send."]
    #[doc = ""]
    #[doc = "\\return true if the address has been send, false if something went wrong."]
    pub fn fifoSendAddress(channel: ::libc::c_int, address: *mut ::libc::c_void) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a 32bit value."]
    #[doc = ""]
    #[doc = "Transmits a 32bit value to the other CPU."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to"]
    #[doc = "\\param value32 32bit value to send"]
    #[doc = ""]
    #[doc = "\\return true if the value has been send, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Transfer is more efficient if the top 8 bits are zero. So sending smaller values or bitmasks that don't include the top bits is preferred."]
    pub fn fifoSendValue32(channel: ::libc::c_int, value32: u32_) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a sequence of bytes to the other CPU."]
    #[doc = ""]
    #[doc = "num_bytes can be between 0 and FIFO_MAX_DATA_BYTES - sending 0 bytes can be useful sometimes..."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to"]
    #[doc = "\\param num_bytes number of bytes to send"]
    #[doc = "\\param data_array pointer to data array"]
    #[doc = ""]
    #[doc = "\\return true if the data message has been send, false if something went wrong."]
    pub fn fifoSendDatamsg(
        channel: ::libc::c_int,
        num_bytes: ::libc::c_int,
        data_array: *mut u8_,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user address message callback."]
    #[doc = ""]
    #[doc = "Set a callback to receive incoming address messages on a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param newhandler a function pointer to the new handler function."]
    #[doc = "\\param userdata a pointer that will be passed on to the handler when it will be called."]
    #[doc = ""]
    #[doc = "\\return true if the handler has been set, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetAddressHandler(
        channel: ::libc::c_int,
        newhandler: FifoAddressHandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user value32 message callback."]
    #[doc = ""]
    #[doc = "Set a callback to receive incoming value32 messages on a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param newhandler a function pointer to the new handler function."]
    #[doc = "\\param userdata a pointer that will be passed on to the handler when it will be called."]
    #[doc = ""]
    #[doc = "\\return true if the handler has been set, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetValue32Handler(
        channel: ::libc::c_int,
        newhandler: FifoValue32HandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user data message callback."]
    #[doc = ""]
    #[doc = "Set a callback to receive incoming data messages on a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel channel number to send to."]
    #[doc = "\\param newhandler a function pointer to the new handler function."]
    #[doc = "\\param userdata a pointer that will be passed on to the handler when it will be called."]
    #[doc = ""]
    #[doc = "\\return true if the handler has been set, false if something went wrong."]
    #[doc = ""]
    #[doc = "\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetDatamsgHandler(
        channel: ::libc::c_int,
        newhandler: FifoDatamsgHandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any addresses in the fifo queue."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return true if there is any addresses in the queue and if there isn't an address handler in place for the channel."]
    pub fn fifoCheckAddress(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any values in the fifo queue."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return true if there is any values in the queue and if there isn't a value handler in place for the channel."]
    pub fn fifoCheckValue32(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any data messages in the fifo queue."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return true if there is any data messages in the queue and if there isn't a data message handler in place for the channel."]
    pub fn fifoCheckDatamsg(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief gets the number of bytes in the queue for the first data entry."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return the number of bytes in the queue for the first data entry, or -1 if there are no entries."]
    pub fn fifoCheckDatamsgLength(channel: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief Get the first address in queue for a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return the first address in queue, or NULL if there is none."]
    pub fn fifoGetAddress(channel: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "\\brief Get the first value32 in queue for a specific channel."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = ""]
    #[doc = "\\return the first value32 in queue, or 0 if there is no message."]
    pub fn fifoGetValue32(channel: ::libc::c_int) -> u32_;
}
extern "C" {
    #[doc = "\\brief Reads a data message in a given buffer and returns the number of bytes written."]
    #[doc = ""]
    #[doc = "\\param channel the channel to check."]
    #[doc = "\\param buffersize the size of the buffer where the message will be copied to."]
    #[doc = "\\param destbuffer a pointer to the buffer where the message will be copied to."]
    #[doc = ""]
    #[doc = "\\return the number of bytes written, or -1 if there is no message."]
    #[doc = ""]
    #[doc = "\\warning If your buffer is not big enough, you may lose data! Check the data length first if you're not sure what the size is."]
    pub fn fifoGetDatamsg(
        channel: ::libc::c_int,
        buffersize: ::libc::c_int,
        destbuffer: *mut u8_,
    ) -> ::libc::c_int;
}
#[doc = "! holds data related to the touch screen."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct touchPosition {
    #[doc = "!< Raw x value from the A2D"]
    pub rawx: u16_,
    #[doc = "!< Raw y value from the A2D"]
    pub rawy: u16_,
    #[doc = "!< Processes pixel X value"]
    pub px: u16_,
    #[doc = "!< Processes pixel Y value"]
    pub py: u16_,
    #[doc = "!< Raw cross panel resistance"]
    pub z1: u16_,
    #[doc = "!< Raw cross panel resistance"]
    pub z2: u16_,
}
#[doc = "!< Keypad A button."]
pub const KEY_A: KEYPAD_BITS = 1;
#[doc = "!< Keypad B button."]
pub const KEY_B: KEYPAD_BITS = 2;
#[doc = "!< Keypad SELECT button."]
pub const KEY_SELECT: KEYPAD_BITS = 4;
#[doc = "!< Keypad START button."]
pub const KEY_START: KEYPAD_BITS = 8;
#[doc = "!< Keypad RIGHT button."]
pub const KEY_RIGHT: KEYPAD_BITS = 16;
#[doc = "!< Keypad LEFT button."]
pub const KEY_LEFT: KEYPAD_BITS = 32;
#[doc = "!< Keypad UP button."]
pub const KEY_UP: KEYPAD_BITS = 64;
#[doc = "!< Keypad DOWN button."]
pub const KEY_DOWN: KEYPAD_BITS = 128;
#[doc = "!< Right shoulder button."]
pub const KEY_R: KEYPAD_BITS = 256;
#[doc = "!< Left shoulder button."]
pub const KEY_L: KEYPAD_BITS = 512;
#[doc = "!< Keypad X button."]
pub const KEY_X: KEYPAD_BITS = 1024;
#[doc = "!< Keypad Y button."]
pub const KEY_Y: KEYPAD_BITS = 2048;
#[doc = "!< Touchscreen pendown."]
pub const KEY_TOUCH: KEYPAD_BITS = 4096;
#[doc = "!< Lid state."]
pub const KEY_LID: KEYPAD_BITS = 8192;
#[doc = "! enum values for the keypad buttons."]
pub type KEYPAD_BITS = ::libc::c_uint;
pub type size_t = ::libc::c_uint;
pub type wchar_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swiSHA1context {
    #[doc = "< intermediate digest state"]
    pub state: [u32_; 5usize],
    #[doc = "< number of bytes processed"]
    pub total: [u32_; 2usize],
    #[doc = "< data block being processed"]
    pub buffer: [u8_; 64usize],
    pub fragment_size: u32_,
    #[doc = "< data block being processed"]
    pub sha_block: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut swiSHA1context, src: *const ::libc::c_void, len: size_t),
    >,
}
impl Default for swiSHA1context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type swiSHA1context_t = swiSHA1context;
extern "C" {
    #[doc = " \\brief          SHA-1 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    pub fn swiSHA1Init(ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      SHA-1 context"]
    #[doc = " \\param data     buffer to process"]
    #[doc = " \\param len      length of data"]
    pub fn swiSHA1Update(ctx: *mut swiSHA1context_t, data: *const ::libc::c_void, len: size_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 final digest"]
    #[doc = ""]
    #[doc = " \\param digest   buffer to hold SHA-1 checksum result"]
    #[doc = " \\param ctx      SHA-1 context"]
    pub fn swiSHA1Final(digest: *mut ::libc::c_void, ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 checksum"]
    #[doc = ""]
    #[doc = " \\param digest   buffer to hold SHA-1 checksum result"]
    #[doc = " \\param data     buffer to process"]
    #[doc = " \\param len      length of data"]
    pub fn swiSHA1Calc(digest: *mut ::libc::c_void, data: *const ::libc::c_void, len: size_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 verify"]
    #[doc = ""]
    #[doc = " \\param digest1  buffer containing hash to verify"]
    #[doc = " \\param digest2  buffer containing hash to verify"]
    pub fn swiSHA1Verify(digest1: *const ::libc::c_void, digest2: *const ::libc::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aes_keyslot {
    pub normalkey: [vu8; 16usize],
    pub key_x: [vu8; 16usize],
    pub key_y: [vu8; 16usize],
}
pub type aes_keyslot_t = aes_keyslot;
extern "C" {
    pub fn readFirmware(address: u32_, destination: *mut ::libc::c_void, size: u32_);
}
pub type MIC_BUF_SWAP_CB =
    ::core::option::Option<unsafe extern "C" fn(completedBuffer: *mut u8_, length: ::libc::c_int)>;
extern "C" {
    pub fn micReadData8() -> u8_;
}
extern "C" {
    pub fn micReadData12() -> u16_;
}
extern "C" {
    pub fn micStartRecording(
        buffer: *mut u8_,
        length: ::libc::c_int,
        freq: ::libc::c_int,
        timer: ::libc::c_int,
        eightBitSample: bool,
        bufferSwapCallback: MIC_BUF_SWAP_CB,
    );
}
extern "C" {
    pub fn micStopRecording() -> ::libc::c_int;
}
extern "C" {
    pub fn micTimerHandler();
}
extern "C" {
    pub fn micSetAmp(control: u8_, gain: u8_);
}
extern "C" {
    pub fn installSoundFIFO();
}
extern "C" {
    pub fn rtcReset();
}
extern "C" {
    pub fn rtcTransaction(
        command: *mut uint8,
        commandLength: uint32,
        result: *mut uint8,
        resultLength: uint32,
    );
}
extern "C" {
    pub fn rtcGetTime(time: *mut uint8);
}
extern "C" {
    pub fn rtcSetTime(time: *mut uint8);
}
extern "C" {
    pub fn rtcGetTimeAndDate(time: *mut uint8);
}
extern "C" {
    pub fn rtcSetTimeAndDate(time: *mut uint8);
}
extern "C" {
    pub fn rtcGetData(data: *mut uint8, size: uint32);
}
extern "C" {
    pub fn BCDToInteger(data: *mut uint8, length: uint32);
}
extern "C" {
    pub fn integerToBCD(data: *mut uint8, length: uint32);
}
extern "C" {
    pub fn initClockIRQ();
}
extern "C" {
    pub fn resyncClock();
}
pub const CDC_CONTROL: cdcBanks = 0;
pub const CDC_SOUND: cdcBanks = 1;
pub const CDC_TOUCHCNT: cdcBanks = 3;
pub const CDC_TOUCHDATA: cdcBanks = 252;
pub type cdcBanks = ::libc::c_uint;
extern "C" {
    pub fn cdcReadReg(bank: u8_, reg: u8_) -> u8_;
}
extern "C" {
    pub fn cdcReadRegArray(bank: u8_, reg: u8_, data: *mut ::libc::c_void, size: u8_);
}
extern "C" {
    pub fn cdcWriteReg(bank: u8_, reg: u8_, value: u8_);
}
extern "C" {
    pub fn cdcWriteRegMask(bank: u8_, reg: u8_, mask: u8_, value: u8_);
}
extern "C" {
    pub fn cdcWriteRegArray(bank: u8_, reg: u8_, data: *const ::libc::c_void, size: u8_);
}
extern "C" {
    pub fn cdcTouchInit();
}
extern "C" {
    pub fn cdcTouchPenDown() -> bool;
}
extern "C" {
    pub fn cdcTouchRead(pos: *mut touchPosition) -> bool;
}
extern "C" {
    pub fn inputGetAndSend();
}
pub const I2C_CAM0: i2cDevices = 122;
pub const I2C_CAM1: i2cDevices = 120;
pub const I2C_UNK1: i2cDevices = 160;
pub const I2C_UNK2: i2cDevices = 224;
pub const I2C_PM: i2cDevices = 74;
pub const I2C_UNK3: i2cDevices = 64;
pub const I2C_GPIO: i2cDevices = 144;
pub type i2cDevices = ::libc::c_uint;
extern "C" {
    pub fn i2cWriteRegister(device: u8_, reg: u8_, data: u8_) -> u8_;
}
extern "C" {
    pub fn i2cReadRegister(device: u8_, reg: u8_) -> u8_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmcdevice {
    pub data: *mut u8_,
    pub size: u32_,
    pub error: u32_,
    pub stat0: u16_,
    pub stat1: u16_,
    pub ret: [u32_; 4usize],
    pub initarg: u32_,
    pub isSDHC: u32_,
    pub clk: u32_,
    pub SDOPT: u32_,
    pub devicenumber: u32_,
    pub total_size: u32_,
    pub res: u32_,
}
impl Default for mmcdevice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MMC_DEVICE_SDCARD: ::libc::c_uint = 0;
pub const MMC_DEVICE_NAND: ::libc::c_uint = 1;
pub type _bindgen_ty_1 = ::libc::c_uint;
extern "C" {
    pub fn sdmmc_controller_init(force_init: bool);
}
extern "C" {
    pub fn sdmmc_initirq();
}
extern "C" {
    pub fn sdmmc_cardinserted() -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_sdcard_init() -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_nand_init() -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_get_cid(devicenumber: ::libc::c_int, cid: *mut u32_);
}
extern "C" {
    pub fn sdmmc_sdcard_readsectors(
        sector_no: u32_,
        numsectors: u32_,
        out: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_sdcard_writesectors(
        sector_no: u32_,
        numsectors: u32_,
        in_: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_nand_readsectors(
        sector_no: u32_,
        numsectors: u32_,
        out: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_nand_writesectors(
        sector_no: u32_,
        numsectors: u32_,
        in_: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static mut sdmmc_cid: [u32_; 0usize];
}
extern "C" {
    pub static mut sdmmc_curdevice: ::libc::c_int;
}
extern "C" {
    pub fn touchInit();
}
extern "C" {
    pub fn touchReadXY(touchPos: *mut touchPosition);
}
extern "C" {
    pub fn touchRead(command: uint32) -> uint16;
}
extern "C" {
    pub fn touchReadTemperature(t1: *mut ::libc::c_int, t2: *mut ::libc::c_int) -> uint32;
}
extern "C" {
    pub fn touchPenDown() -> bool;
}
