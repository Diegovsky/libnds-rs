/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _LIBNDS_MAJOR_: u32 = 1;
pub const _LIBNDS_MINOR_: u32 = 8;
pub const _LIBNDS_PATCH_: u32 = 0;
pub const _LIBNDS_STRING: &[u8; 21usize] = b"libNDS Release 1.8.0\0";
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 2;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 2usize] = b"l\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 2usize] = b"l\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 2usize] = b"l\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const COPY_MODE_HWORD: u32 = 0;
pub const COPY_MODE_COPY: u32 = 0;
pub const CARD_CR1_ENABLE: u32 = 128;
pub const CARD_CR1_IRQ: u32 = 64;
pub const SPI_EEPROM_WRSR: u32 = 1;
pub const SPI_EEPROM_PP: u32 = 2;
pub const SPI_EEPROM_READ: u32 = 3;
pub const SPI_EEPROM_WRDI: u32 = 4;
pub const SPI_EEPROM_RDSR: u32 = 5;
pub const SPI_EEPROM_WREN: u32 = 6;
pub const SPI_EEPROM_PW: u32 = 10;
pub const SPI_EEPROM_FAST: u32 = 11;
pub const SPI_EEPROM_RDID: u32 = 159;
pub const SPI_EEPROM_RDP: u32 = 171;
pub const SPI_EEPROM_DPD: u32 = 185;
pub const CARD_ACTIVATE: u32 = 2147483648;
pub const CARD_WR: u32 = 1073741824;
pub const CARD_nRESET: u32 = 536870912;
pub const CARD_SEC_LARGE: u32 = 268435456;
pub const CARD_CLK_SLOW: u32 = 134217728;
pub const CARD_SEC_CMD: u32 = 4194304;
pub const CARD_SEC_SEED: u32 = 32768;
pub const CARD_SEC_EN: u32 = 16384;
pub const CARD_SEC_DAT: u32 = 8192;
pub const CARD_BUSY: u32 = 2147483648;
pub const CARD_DATA_READY: u32 = 8388608;
pub const CARD_CMD_DUMMY: u32 = 159;
pub const CARD_CMD_HEADER_READ: u32 = 0;
pub const CARD_CMD_HEADER_CHIPID: u32 = 144;
pub const CARD_CMD_ACTIVATE_BF: u32 = 60;
pub const CARD_CMD_ACTIVATE_SEC: u32 = 64;
pub const CARD_CMD_SECURE_CHIPID: u32 = 16;
pub const CARD_CMD_SECURE_READ: u32 = 32;
pub const CARD_CMD_DISABLE_SEC: u32 = 96;
pub const CARD_CMD_DATA_MODE: u32 = 160;
pub const CARD_CMD_DATA_READ: u32 = 183;
pub const CARD_CMD_DATA_CHIPID: u32 = 184;
pub const CARD_ENABLE: u32 = 32768;
pub const CARD_SPI_ENABLE: u32 = 8192;
pub const CARD_SPI_BUSY: u32 = 128;
pub const CARD_SPI_HOLD: u32 = 64;
pub const CARD_SPICNTH_ENABLE: u32 = 128;
pub const CARD_SPICNTH_IRQ: u32 = 64;
pub const DMA_START_NOW: u32 = 0;
pub const DMA_START_CARD: u32 = 671088640;
pub const DMA_16_BIT: u32 = 0;
pub const DMA_SRC_INC: u32 = 0;
pub const DMA_DST_INC: u32 = 0;
pub const DMA_DST_RESET: u32 = 6291456;
pub const MAX_INTERRUPTS: u32 = 25;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const ARGV_MAGIC: u32 = 1600221799;
pub const BOOTSIG: u64 = 7094704827215605602;
pub const BUS_CLOCK: u32 = 33513982;
pub const TIMER_ENABLE: u32 = 128;
pub const TIMER_IRQ_REQ: u32 = 64;
pub const TIMER_CASCADE: u32 = 4;
pub const TIMER_DIV_1: u32 = 0;
pub const TIMER_DIV_64: u32 = 1;
pub const TIMER_DIV_256: u32 = 2;
pub const TIMER_DIV_1024: u32 = 3;
pub const AES_WRFIFO_FLUSH: u32 = 1024;
pub const AES_RDFIFO_FLUSH: u32 = 2048;
pub const AES_CCM_PASSTRHOUGH: u32 = 524288;
pub const AES_CNT_KEY_APPLY: u32 = 16777216;
pub const AES_CNT_IRQ: u32 = 1073741824;
pub const AES_CNT_ENABLE: u32 = 2147483648;
pub const SPI_BAUD_4MHz: u32 = 0;
pub const SPI_BAUD_2MHz: u32 = 1;
pub const SPI_BAUD_1MHz: u32 = 2;
pub const SPI_BAUD_512KHz: u32 = 3;
pub const SPI_BYTE_MODE: u32 = 0;
pub const SPI_HWORD_MODE: u32 = 1024;
pub const SPI_DEVICE_POWER: u32 = 0;
pub const SPI_DEVICE_FIRMWARE: u32 = 256;
pub const SPI_DEVICE_NVRAM: u32 = 256;
pub const SPI_DEVICE_TOUCH: u32 = 512;
pub const SPI_DEVICE_MICROPHONE: u32 = 512;
pub const FIRMWARE_WREN: u32 = 6;
pub const FIRMWARE_WRDI: u32 = 4;
pub const FIRMWARE_RDID: u32 = 159;
pub const FIRMWARE_RDSR: u32 = 5;
pub const FIRMWARE_READ: u32 = 3;
pub const FIRMWARE_PW: u32 = 10;
pub const FIRMWARE_PP: u32 = 2;
pub const FIRMWARE_FAST: u32 = 11;
pub const FIRMWARE_PE: u32 = 219;
pub const FIRMWARE_SE: u32 = 216;
pub const FIRMWARE_DP: u32 = 185;
pub const FIRMWARE_RDP: u32 = 171;
pub const SOUND_FORMAT_16BIT: u32 = 536870912;
pub const SOUND_FORMAT_8BIT: u32 = 0;
pub const SOUND_FORMAT_PSG: u32 = 1610612736;
pub const SOUND_FORMAT_ADPCM: u32 = 1073741824;
pub const SNDEXTCNT_FREQ_32KHZ: u32 = 0;
pub const SNDEXTCNT_FREQ_47KHZ: u32 = 8192;
pub const WRITE_STATUS_REG1: u32 = 96;
pub const READ_STATUS_REG1: u32 = 97;
pub const STATUS_POC: u32 = 128;
pub const STATUS_BLD: u32 = 64;
pub const STATUS_INT2: u32 = 32;
pub const STATUS_INT1: u32 = 16;
pub const STATUS_SC1: u32 = 8;
pub const STATUS_SC0: u32 = 4;
pub const STATUS_24HRS: u32 = 2;
pub const STATUS_RESET: u32 = 1;
pub const WRITE_STATUS_REG2: u32 = 98;
pub const READ_STATUS_REG2: u32 = 99;
pub const STATUS_TEST: u32 = 128;
pub const STATUS_INT2AE: u32 = 64;
pub const STATUS_SC3: u32 = 32;
pub const STATUS_SC2: u32 = 16;
pub const STATUS_32kE: u32 = 8;
pub const STATUS_INT1AE: u32 = 4;
pub const STATUS_INT1ME: u32 = 2;
pub const STATUS_INT1FE: u32 = 1;
pub const WRITE_TIME_AND_DATE: u32 = 100;
pub const READ_TIME_AND_DATE: u32 = 101;
pub const WRITE_TIME: u32 = 102;
pub const READ_TIME: u32 = 103;
pub const WRITE_INT_REG1: u32 = 104;
pub const READ_INT_REG1: u32 = 105;
pub const WRITE_INT_REG2: u32 = 106;
pub const READ_INT_REG2: u32 = 107;
pub const READ_CLOCK_ADJUST_REG: u32 = 108;
pub const WRITE_CLOCK_ADJUST_REG: u32 = 109;
pub const READ_FREE_REG: u32 = 110;
pub const WRITE_FREE_REG: u32 = 111;
pub const I2CREGPM_BATUNK: u32 = 0;
pub const I2CREGPM_PWRIF: u32 = 16;
pub const I2CREGPM_PWRCNT: u32 = 17;
pub const I2CREGPM_MMCPWR: u32 = 18;
pub const I2CREGPM_BATTERY: u32 = 32;
pub const I2CREGPM_CAMLED: u32 = 49;
pub const I2CREGPM_VOL: u32 = 64;
pub const I2CREGPM_RESETFLAG: u32 = 112;
pub const SDMMC_BASE: u32 = 67127296;
pub const REG_SDCMD: u32 = 0;
pub const REG_SDPORTSEL: u32 = 2;
pub const REG_SDCMDARG: u32 = 4;
pub const REG_SDCMDARG0: u32 = 4;
pub const REG_SDCMDARG1: u32 = 6;
pub const REG_SDSTOP: u32 = 8;
pub const REG_SDRESP: u32 = 12;
pub const REG_SDBLKCOUNT: u32 = 10;
pub const REG_SDRESP0: u32 = 12;
pub const REG_SDRESP1: u32 = 14;
pub const REG_SDRESP2: u32 = 16;
pub const REG_SDRESP3: u32 = 18;
pub const REG_SDRESP4: u32 = 20;
pub const REG_SDRESP5: u32 = 22;
pub const REG_SDRESP6: u32 = 24;
pub const REG_SDRESP7: u32 = 26;
pub const REG_SDSTATUS0: u32 = 28;
pub const REG_SDSTATUS1: u32 = 30;
pub const REG_SDIRMASK0: u32 = 32;
pub const REG_SDIRMASK1: u32 = 34;
pub const REG_SDCLKCTL: u32 = 36;
pub const REG_SDBLKLEN: u32 = 38;
pub const REG_SDOPT: u32 = 40;
pub const REG_SDFIFO: u32 = 48;
pub const REG_SDDATACTL: u32 = 216;
pub const REG_SDRESET: u32 = 224;
pub const REG_SDPROTECTED: u32 = 246;
pub const REG_SDDATACTL32: u32 = 256;
pub const REG_SDBLKLEN32: u32 = 260;
pub const REG_SDBLKCOUNT32: u32 = 264;
pub const REG_SDFIFO32: u32 = 268;
pub const REG_CLK_AND_WAIT_CTL: u32 = 312;
pub const REG_RESET_SDIO: u32 = 480;
pub const TMIO_STAT0_CMDRESPEND: u32 = 1;
pub const TMIO_STAT0_DATAEND: u32 = 4;
pub const TMIO_STAT0_CARD_REMOVE: u32 = 8;
pub const TMIO_STAT0_CARD_INSERT: u32 = 16;
pub const TMIO_STAT0_SIGSTATE: u32 = 32;
pub const TMIO_STAT0_WRPROTECT: u32 = 128;
pub const TMIO_STAT0_CARD_REMOVE_A: u32 = 256;
pub const TMIO_STAT0_CARD_INSERT_A: u32 = 512;
pub const TMIO_STAT0_SIGSTATE_A: u32 = 1024;
pub const TMIO_STAT1_CMD_IDX_ERR: u32 = 1;
pub const TMIO_STAT1_CRCFAIL: u32 = 2;
pub const TMIO_STAT1_STOPBIT_ERR: u32 = 4;
pub const TMIO_STAT1_DATATIMEOUT: u32 = 8;
pub const TMIO_STAT1_RXOVERFLOW: u32 = 16;
pub const TMIO_STAT1_TXUNDERRUN: u32 = 32;
pub const TMIO_STAT1_CMDTIMEOUT: u32 = 64;
pub const TMIO_STAT1_RXRDY: u32 = 256;
pub const TMIO_STAT1_TXRQ: u32 = 512;
pub const TMIO_STAT1_ILL_FUNC: u32 = 8192;
pub const TMIO_STAT1_CMD_BUSY: u32 = 16384;
pub const TMIO_STAT1_ILL_ACCESS: u32 = 32768;
pub const SDMC_NORMAL: u32 = 0;
pub const SDMC_ERR_COMMAND: u32 = 1;
pub const SDMC_ERR_CRC: u32 = 2;
pub const SDMC_ERR_END: u32 = 4;
pub const SDMC_ERR_TIMEOUT: u32 = 8;
pub const SDMC_ERR_FIFO_OVF: u32 = 16;
pub const SDMC_ERR_FIFO_UDF: u32 = 32;
pub const SDMC_ERR_WP: u32 = 64;
pub const SDMC_ERR_ABORT: u32 = 128;
pub const SDMC_ERR_FPGA_TIMEOUT: u32 = 256;
pub const SDMC_ERR_PARAM: u32 = 512;
pub const SDMC_ERR_R1_STATUS: u32 = 2048;
pub const SDMC_ERR_NUM_WR_SECTORS: u32 = 4096;
pub const SDMC_ERR_RESET: u32 = 8192;
pub const SDMC_ERR_ILA: u32 = 16384;
pub const SDMC_ERR_INFO_DETECT: u32 = 32768;
pub const SDMC_STAT_ERR_UNKNOWN: u32 = 524288;
pub const SDMC_STAT_ERR_CC: u32 = 1048576;
pub const SDMC_STAT_ERR_ECC_FAILED: u32 = 2097152;
pub const SDMC_STAT_ERR_CRC: u32 = 8388608;
pub const SDMC_STAT_ERR_OTHER: u32 = 4190568456;
pub const TMIO_MASK_ALL: u32 = 2206139165;
pub const TMIO_MASK_GW: u32 = 32895;
pub const SCREEN_WIDTH: u32 = 256;
pub const SCREEN_HEIGHT: u32 = 192;
pub const TSC_MEASURE_TEMP1: u32 = 132;
pub const TSC_MEASURE_Y: u32 = 144;
pub const TSC_MEASURE_BATTERY: u32 = 164;
pub const TSC_MEASURE_Z1: u32 = 180;
pub const TSC_MEASURE_Z2: u32 = 196;
pub const TSC_MEASURE_X: u32 = 208;
pub const TSC_MEASURE_AUX: u32 = 228;
pub const TSC_MEASURE_TEMP2: u32 = 244;
pub const DSWIFI_MAJOR: u32 = 0;
pub const DSWIFI_MINOR: u32 = 4;
pub const DSWIFI_REVISION: u32 = 2;
pub const DSWIFI_VERSION: &[u8; 6usize] = b"0.4.2\0";
pub const MMCB_SONGMESSAGE: u32 = 42;
pub const MMCB_SONGFINISHED: u32 = 43;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_long;
pub type __uint_least64_t = ::libc::c_ulong;
pub type __intmax_t = ::libc::c_long;
pub type __uintmax_t = ::libc::c_ulong;
pub type __intptr_t = ::libc::c_long;
pub type __uintptr_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast64_t = ::libc::c_ulong;
#[doc = "! 8 bit unsigned integer."]
pub type uint8 = u8;
#[doc = "! 16 bit unsigned integer."]
pub type uint16 = u16;
#[doc = "! 32 bit unsigned integer."]
pub type uint32 = u32;
#[doc = "! 64 bit unsigned integer."]
pub type uint64 = u64;
#[doc = "! 8 bit signed integer."]
pub type int8 = i8;
#[doc = "! 16 bit signed integer."]
pub type int16 = i16;
#[doc = "! 32 bit signed integer."]
pub type int32 = i32;
#[doc = "! 64 bit signed integer."]
pub type int64 = i64;
#[doc = "! 32 bit signed floating point number."]
pub type float32 = f32;
#[doc = "! 64 bit signed floating point number."]
pub type float64 = f64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vuint8 = u8;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vuint16 = u16;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vuint32 = u32;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vuint64 = u64;
#[doc = "! 8 bit volatile signed integer."]
pub type vint8 = i8;
#[doc = "! 16 bit volatile signed integer."]
pub type vint16 = i16;
#[doc = "! 32 bit volatile signed integer."]
pub type vint32 = i32;
#[doc = "! 64 bit volatile signed integer."]
pub type vint64 = i64;
#[doc = "! 32 bit volatile signed floating point number."]
pub type vfloat32 = float32;
#[doc = "! 64 bit volatile signed floating point number."]
pub type vfloat64 = float64;
#[doc = "! 8 bit unsigned integer."]
pub type byte = u8;
#[doc = "! 8 bit unsigned integer."]
pub type u8_ = u8;
#[doc = "! 16 bit unsigned integer."]
pub type u16_ = u16;
#[doc = "! 32 bit unsigned integer."]
pub type u32_ = u32;
#[doc = "! 64 bit unsigned integer."]
pub type u64_ = u64;
#[doc = "! 8 bit signed integer."]
pub type s8 = i8;
#[doc = "! 16 bit signed integer."]
pub type s16 = i16;
#[doc = "! 32 bit signed integer."]
pub type s32 = i32;
#[doc = "! 64 bit signed integer."]
pub type s64 = i64;
#[doc = "! 8 bit volatile unsigned integer."]
pub type vu8 = u8_;
#[doc = "! 16 bit volatile unsigned integer."]
pub type vu16 = u16_;
#[doc = "! 32 bit volatile unsigned integer."]
pub type vu32 = u32_;
#[doc = "! 64 bit volatile unsigned integer."]
pub type vu64 = u64_;
#[doc = "! 8 bit volatile signed integer."]
pub type vs8 = s8;
#[doc = "! 16 bit volatile signed integer."]
pub type vs16 = s16;
#[doc = "! 32 bit volatile signed integer."]
pub type vs32 = s32;
#[doc = "! 64 bit volatile signed integer."]
pub type vs64 = s64;
pub type sec_t = u32;
#[doc = "! a function pointer that takes no arguments and doesn't return anything."]
pub type VoidFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type IntFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type fp = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "\t\\brief Should return the header of a compressed stream of bytes.\n\nThe result is a word, with the size of decompressed data in bits 8-31,\nand bits 0-7 are ignored.  This value is also returned by the bios function, unless getResult is non-NULL and returns a negative value.\nThis useally returns the 4 bytes that source points to.\n\n\\param source \tA pointer to the compressed data.\n\\param dest\t\tA pointer to the space where the decompressed data should be copied to.\n\\param arg\t\tA callback value that gets passed to the bios function.\n\\return The header of the compressed data containing the length of the data and the compression type."]
pub type getHeaderCallback = ::core::option::Option<
    unsafe extern "C" fn(source: *mut u8_, dest: *mut u16_, arg: u32_) -> ::libc::c_int,
>;
#[doc = "\t\\brief Should verify the result after data got decompressed.\n\ngetResult is used to provide a result for the bios function, given the source pointer after all data has been read\n(or if getSize < 0). Its value is only returned if negative, otherwise the typical result is used, so it is likely\nsome sort of error-checking procedure.\n\n\\param source The current source address.\n\\return 0 if it went right, or a negative number if something went wrong. value will be returned from bios function if value is negative."]
pub type getResultCallback =
    ::core::option::Option<unsafe extern "C" fn(source: *mut u8_) -> ::libc::c_int>;
#[doc = "\t\\brief Should returns a raw byte of the stream.\n\\param source A pointer to the byte.\n\\return A byte."]
pub type getByteCallback = ::core::option::Option<unsafe extern "C" fn(source: *mut u8_) -> u8_>;
#[doc = "! A struct that contains callback function pointers used by the decompression functions."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DecompressionStream {
    #[doc = "!< gets called to get the header of the stream."]
    pub getSize: getHeaderCallback,
    #[doc = "!< gets called to verify the result afterwards, can be NULL (no callback)."]
    pub getResult: getResultCallback,
    #[doc = "!< gets called to get a byte of the compressed data."]
    pub readByte: getByteCallback,
}
#[doc = "! A struct that contains callback function pointers used by the decompression functions."]
pub type TDecompressionStream = DecompressionStream;
#[doc = "! A struct and struct pointer with information about unpacking data."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UnpackStruct {
    #[doc = "!< in bytes"]
    pub sourceSize: uint16,
    #[doc = "!< 1,2,4 or 8 bits."]
    pub sourceWidth: uint8,
    #[doc = "!< 1,2,4,8,16 or 32 bits."]
    pub destWidth: uint8,
    #[doc = "!< bits 0-30 are added to all non-zero destination writes, unless bit 31 is set, which does it for zeros too."]
    pub dataOffset: uint32,
}
#[doc = "! A struct and struct pointer with information about unpacking data."]
pub type TUnpackStruct = UnpackStruct;
#[doc = "! A struct and struct pointer with information about unpacking data."]
pub type PUnpackStruct = *mut UnpackStruct;
extern "C" {
    #[doc = "\\brief resets the DS."]
    pub fn swiSoftReset();
}
extern "C" {
    #[doc = "\\brief delays the code.\n\nDelays for for a period X + Y*duration where X is the swi overhead and Y is a cycle of\n<CODE><PRE>\nloop:\nsub r0, #1\nbgt loop\n</PRE></CODE>\nof thumb fetches in BIOS memory\n\\param duration length of delay\n\\note Duration should be 1 or more, a duration of 0 is a huge delay."]
    pub fn swiDelay(duration: uint32);
}
extern "C" {
    #[doc = "\\brief divides 2 numbers.\n\\param numerator\tsigned integer to divide\n\\param divisor\t\tsigned integer to divide by\n\\return numerator / divisor"]
    pub fn swiDivide(numerator: ::libc::c_int, divisor: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief calculate the remainder of an division.\n\\param numerator\tsigned integer to divide\n\\param divisor\t\tsigned integer to divide by\n\\return numerator % divisor"]
    pub fn swiRemainder(numerator: ::libc::c_int, divisor: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief divides 2 numbers and stores both the result and the remainder.\n\n\\param numerator\tsigned integer to divide\n\\param divisor\t\tsigned integer to divide by\n\\param result\t\tpointer to integer set to numerator / divisor\n\\param remainder \tpointer to integer set to numerator % divisor"]
    pub fn swiDivMod(
        numerator: ::libc::c_int,
        divisor: ::libc::c_int,
        result: *mut ::libc::c_int,
        remainder: *mut ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory.\n\\param source \tpointer to transfer source or pointer to value to fill the memory with.\n\\param dest\t\tpointer to transfer destination.\n\\param flags\tbits(0-20): size of data to copy/fill in words,\nor'd with the copy mode size (word or halfword) and type (copy or fill)."]
    pub fn swiCopy(source: *const ::libc::c_void, dest: *mut ::libc::c_void, flags: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief copies or fills some memory.\ncan only copy in word chunks.\n\\param source\tpointer to transfer source or pointer to value to fill the memory with.\n\\param dest\t\tpointer to transfer destination.\n\\param flags\tbits(0-20): size of data to copy/fill in words,\nor'd with the type (copy or fill).\n\n\\note Transfers more quickly than swiCopy, but has higher interrupt latency."]
    pub fn swiFastCopy(
        source: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        flags: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "\t\\brief calculates the square root.\n\\param value the value to calculate.\n\\return the square root of the value as an integer.\n\\note use fixed point math if you want more accuracy."]
    pub fn swiSqrt(value: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief calculates a CRC-16 checksum.\n\\param crc \t\tstarting CRC-16 value.\n\\param data \tpointer to data (processed nibble by nibble)\n\\param size \tsize in bytes.\n\n\\return the CRC-16 after the data has been processed."]
    pub fn swiCRC16(crc: uint16, data: *mut ::libc::c_void, size: uint32) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief returns 0 if running on a nintendo hardware debugger.\n\\return 0 if running on a debugger (8 MB of ram instead of 4 MB), else some other number."]
    pub fn swiIsDebugger() -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Unpack data stored in multiple elements in a byte to a larger space.\n\ni.e. 8 elements per byte (i.e. b/w font), into 1 element per byte.\n\n\\param source\t\t\tSource address.\n\\param destination\t\tdestination address (word aligned).\n\\param params\t\t\tpointer to an UnpackStruct."]
    pub fn swiUnpackBits(source: *mut uint8, destination: *mut uint32, params: PUnpackStruct);
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data.\n\\param source\t\tpointer to a header word, followed by compressed data.\nbit 0-7 of header is ignored.\nbit 8-31 of header is size of uncompressed data in bytes.\n\\param destination\tdestination address.\n\\note Writes data a byte at a time.\n\\see decompress.h"]
    pub fn swiDecompressLZSSWram(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decompresses LZSS compressed data vram safe.\n\n\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset).\n\\param destination\t\tPointer to destination.\n\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer.\n\\param stream\t\t\tPointer to struct with callback function pointers.\n\n\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions.\n\\note Writes data a halfword at a time.\n\\see decompress.h"]
    pub fn swiDecompressLZSSVram(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramNTR(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn swiDecompressLZSSVramTWL(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses Huffman compressed data.\n\n\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset).\n\\param destination\t\tPointer to destination.\n\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer.\n\\param stream\t\t\tPointer to struct with callback function pointers.\n\n\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions.\n\\see decompress.h"]
    pub fn swiDecompressHuffman(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data.\n\ncompressed data format:\nbit(7): 0= uncompressed, 1= compressed.\nbit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data.\nbit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated.\n\n\\param source\t\tpointer to a header word, followed by compressed data.\nbit 0-7 of header is ignored.\nbit 8-31 of header is size of uncompressed data in bytes.\n\\param destination\tdestination address.\n\\note Writes data a byte at a time.\n\\see decompress.h"]
    pub fn swiDecompressRLEWram(source: *mut ::libc::c_void, destination: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "\t\\brief Decompresses RLE compressed data vram safe.\n\ncompressed data format:\nbit(7): 0= uncompressed, 1= compressed.\nbit(0-6) when uncompressed: run length - 1, followed by run_length bytes of true data.\nbit(0-6) when compressed: run length - 3, followed by one byte of true data, to be repeated.\n\n\\param source\t\t\tPointer to source data (always goes through the function pointers, so could just be an offset).\n\\param destination\t\tPointer to destination.\n\\param toGetSize\t\tCallback value that is passed to getHeaderCallback function pointer.\n\\param stream\t\t\tPointer to struct with callback function pointers.\n\n\\return The length of the decompressed data, or a signed errorcode from the Open/Close functions.\n\\note Writes data a halfword at a time.\n\\see decompress.h"]
    pub fn swiDecompressRLEVram(
        source: *mut ::libc::c_void,
        destination: *mut ::libc::c_void,
        toGetSize: uint32,
        stream: *mut TDecompressionStream,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\t\\brief Writes a byte of the data to 0x04000301:8\n\\param data The byte to write.\n\\note ARM7 exclusive."]
    pub fn swiSetHaltCR(data: uint8);
}
extern "C" {
    #[doc = "\t\\brief Halts the CPU untill an interupt occures.\n\\note ARM7 exclusive."]
    pub fn swiHalt();
}
extern "C" {
    #[doc = "\t\\brief Halts the CPU and most of the hardware untill an interupt occures.\n\\note ARM7 exclusive."]
    pub fn swiSleep();
}
extern "C" {
    #[doc = "\t\\brief Switches the DS to GBA mode.\n\\note ARM7 exclusive."]
    pub fn swiSwitchToGBAMode();
}
extern "C" {
    #[doc = "\t\\brief Returns an entry in the sine table.\n\\param index The index of the sine table (0-63).\n\\return The entry.\n\\note ARM7 exclusive."]
    pub fn swiGetSineTable(index: ::libc::c_int) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief Returns an entry in the pitch table.\n\\param index The index of the pitch table (0-767).\n\\return The entry.\n\\note ARM7 exclusive."]
    pub fn swiGetPitchTable(index: ::libc::c_int) -> uint16;
}
extern "C" {
    #[doc = "\t\\brief Returns an entry in the volume table.\n\\param index The index of the volume table (0-723).\n\\return The entry.\n\\note ARM7 exclusive."]
    pub fn swiGetVolumeTable(index: ::libc::c_int) -> uint8;
}
extern "C" {
    #[doc = "\t\\brief increments or decrements the sound bias once per delay.\n\\param enabled \t0 to decrement it until it reaches 0x000, 1 to increment it until it reaches 0x200.\n\\param delay \tIs in the same units of time as swiDelay.\n\\note ARM7 exclusive."]
    pub fn swiChangeSoundBias(enabled: ::libc::c_int, delay: ::libc::c_int);
}
extern "C" {
    pub fn enableSlot1();
}
extern "C" {
    pub fn disableSlot1();
}
extern "C" {
    pub fn cardWriteCommand(command: *const u8_);
}
extern "C" {
    pub fn cardPolledTransfer(
        flags: u32_,
        destination: *mut u32_,
        length: u32_,
        command: *const u8_,
    );
}
extern "C" {
    pub fn cardStartTransfer(
        command: *const u8_,
        destination: *mut u32_,
        channel: ::libc::c_int,
        flags: u32_,
    );
}
extern "C" {
    pub fn cardWriteAndRead(command: *const u8_, flags: u32_) -> uint32;
}
extern "C" {
    pub fn cardParamCommand(
        command: u8_,
        parameter: u32_,
        flags: u32_,
        destination: *mut u32_,
        length: u32_,
    );
}
extern "C" {
    pub fn cardReadHeader(header: *mut u8_);
}
extern "C" {
    pub fn cardReadID(flags: u32_) -> u32_;
}
extern "C" {
    pub fn cardReset();
}
extern "C" {
    #[link_name = "\u{1}eepromWaitBusy__extern"]
    pub fn eepromWaitBusy();
}
extern "C" {
    pub fn cardReadEeprom(address: u32_, data: *mut u8_, length: u32_, addrtype: u32_);
}
extern "C" {
    pub fn cardWriteEeprom(address: u32_, data: *mut u8_, length: u32_, addrtype: u32_);
}
extern "C" {
    pub fn cardEepromReadID() -> u32_;
}
extern "C" {
    pub fn cardEepromCommand(command: u8_) -> u8_;
}
extern "C" {
    pub fn cardEepromGetType() -> ::libc::c_int;
}
extern "C" {
    pub fn cardEepromGetSize() -> u32_;
}
extern "C" {
    pub fn cardEepromChipErase();
}
extern "C" {
    pub fn cardEepromSectorErase(address: u32_);
}
extern "C" {
    pub fn nocashWrite(message: *const ::libc::c_char, len: ::libc::c_int);
}
extern "C" {
    #[doc = " \\brief Send a message to the no$gba debug window\n\\param message The message to send"]
    pub fn nocashMessage(message: *const ::libc::c_char);
}
extern "C" {
    #[doc = " \\fn void dmaCopyWords(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in words\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest word (4 bytes)"]
    #[link_name = "\u{1}dmaCopyWords__extern"]
    pub fn dmaCopyWords(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopyHalfWords(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in half words\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopyHalfWords__extern"]
    pub fn dmaCopyHalfWords(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopy(const void * source, void * dest, uint32 size)\n\\brief copies from source to destination using channel 3 of DMA available channels in half words\n\\param source the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopy__extern"]
    pub fn dmaCopy(source: *const ::libc::c_void, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn void dmaCopyWordsAsynch(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in half words.\nThis function returns immediately after starting the transfer.\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest word (4 bytes)"]
    #[link_name = "\u{1}dmaCopyWordsAsynch__extern"]
    pub fn dmaCopyWordsAsynch(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopyHalfWordsAsynch(uint8 channel, const void* src, void* dest, uint32 size)\n\\brief copies from source to destination on one of the 4 available channels in half words.\nThis function returns immediately after starting the transfer.\n\\param channel the dma channel to use (0 - 3).\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopyHalfWordsAsynch__extern"]
    pub fn dmaCopyHalfWordsAsynch(
        channel: uint8,
        src: *const ::libc::c_void,
        dest: *mut ::libc::c_void,
        size: uint32,
    );
}
extern "C" {
    #[doc = " \\fn void dmaCopyAsynch(const void* src, void* dest, uint32 size)\n\\brief copies from source to destination using channel 3 of DMA available channels in half words.\nThis function returns immediately after starting the transfer.\n\\param src the source to copy from\n\\param dest the destination to copy to\n\\param size the size in bytes of the data to copy.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaCopyAsynch__extern"]
    pub fn dmaCopyAsynch(source: *const ::libc::c_void, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn void dmaFillWords( u32 value, void* dest, uint32 size)\n\\brief fills the source with the supplied value using DMA channel 3\n\n\\param value the 32 byte value to fill memory with\n\\param dest the destination to copy to\n\\param size the size in bytes of the area to fill.  Will be truncated to the nearest word (4 bytes)"]
    #[link_name = "\u{1}dmaFillWords__extern"]
    pub fn dmaFillWords(value: u32_, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn void dmaFillHalfWords( u16 value, void* dest, uint32 size)\n\\brief fills the source with the supplied value using DMA channel 3\n\n\\param value the 16 byte value to fill memory with\n\\param dest the destination to copy to\n\\param size the size in bytes of the area to fill.  Will be truncated to the nearest half word (2 bytes)"]
    #[link_name = "\u{1}dmaFillHalfWords__extern"]
    pub fn dmaFillHalfWords(value: u16_, dest: *mut ::libc::c_void, size: uint32);
}
extern "C" {
    #[doc = " \\fn dmaBusy(uint8 channel)\n\\brief determines if the specified channel is busy\n\\param channel the dma channel to check (0 - 3).\n\\return non zero if busy, 0 if channel is free"]
    #[link_name = "\u{1}dmaBusy__extern"]
    pub fn dmaBusy(channel: uint8) -> ::libc::c_int;
}
#[doc = "< vertical blank interrupt mask"]
pub const IRQ_VBLANK: IRQ_MASKS = 1;
#[doc = "< horizontal blank interrupt mask"]
pub const IRQ_HBLANK: IRQ_MASKS = 2;
#[doc = "< vcount match interrupt mask"]
pub const IRQ_VCOUNT: IRQ_MASKS = 4;
#[doc = "< timer 0 interrupt mask"]
pub const IRQ_TIMER0: IRQ_MASKS = 8;
#[doc = "< timer 1 interrupt mask"]
pub const IRQ_TIMER1: IRQ_MASKS = 16;
#[doc = "< timer 2 interrupt mask"]
pub const IRQ_TIMER2: IRQ_MASKS = 32;
#[doc = "< timer 3 interrupt mask"]
pub const IRQ_TIMER3: IRQ_MASKS = 64;
#[doc = "< serial interrupt mask"]
pub const IRQ_NETWORK: IRQ_MASKS = 128;
#[doc = "< DMA 0 interrupt mask"]
pub const IRQ_DMA0: IRQ_MASKS = 256;
#[doc = "< DMA 1 interrupt mask"]
pub const IRQ_DMA1: IRQ_MASKS = 512;
#[doc = "< DMA 2 interrupt mask"]
pub const IRQ_DMA2: IRQ_MASKS = 1024;
#[doc = "< DMA 3 interrupt mask"]
pub const IRQ_DMA3: IRQ_MASKS = 2048;
#[doc = "< Keypad interrupt mask"]
pub const IRQ_KEYS: IRQ_MASKS = 4096;
#[doc = "< GBA cartridge interrupt mask"]
pub const IRQ_CART: IRQ_MASKS = 8192;
#[doc = "< IPC sync interrupt mask"]
pub const IRQ_IPC_SYNC: IRQ_MASKS = 65536;
#[doc = "< Send FIFO empty interrupt mask"]
pub const IRQ_FIFO_EMPTY: IRQ_MASKS = 131072;
#[doc = "< Receive FIFO not empty interrupt mask"]
pub const IRQ_FIFO_NOT_EMPTY: IRQ_MASKS = 262144;
#[doc = "< interrupt mask DS Card Slot"]
pub const IRQ_CARD: IRQ_MASKS = 524288;
#[doc = "< interrupt mask"]
pub const IRQ_CARD_LINE: IRQ_MASKS = 1048576;
#[doc = "< geometry FIFO interrupt mask"]
pub const IRQ_GEOMETRY_FIFO: IRQ_MASKS = 2097152;
#[doc = "< interrupt mask DS hinge"]
pub const IRQ_LID: IRQ_MASKS = 4194304;
#[doc = "< SPI interrupt mask"]
pub const IRQ_SPI: IRQ_MASKS = 8388608;
#[doc = "< WIFI interrupt mask (ARM7)"]
pub const IRQ_WIFI: IRQ_MASKS = 16777216;
#[doc = "< 'mask' for all interrupt"]
pub const IRQ_ALL: IRQ_MASKS = -1;
#[doc = "! values allowed for REG_IE and REG_IF"]
pub type IRQ_MASKS = ::libc::c_int;
#[doc = "! values allowed for REG_IE and REG_IF"]
pub use self::IRQ_MASKS as IRQ_MASK;
#[doc = "< I2C interrupt mask (DSi ARM7)"]
pub const IRQ_I2C: IRQ_MASKSAUX = 64;
#[doc = "< Sdmmc interrupt mask (DSi ARM7)"]
pub const IRQ_SDMMC: IRQ_MASKSAUX = 256;
#[doc = "! values allowed for REG_AUXIE and REG_AUXIF"]
pub type IRQ_MASKSAUX = ::libc::c_uint;
#[doc = "< Disable all interrupts."]
pub const IME_DISABLE: IME_VALUE = 0;
#[doc = "< Enable all interrupts not masked out in REG_IE"]
pub const IME_ENABLE: IME_VALUE = 1;
#[doc = "! values allowed for REG_IME"]
pub type IME_VALUE = ::libc::c_uint;
extern "C" {
    pub static mut __irq_vector: [VoidFn; 0usize];
}
extern "C" {
    pub static mut __irq_flags: [vuint32; 0usize];
}
extern "C" {
    pub static mut __irq_flagsaux: [vuint32; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntTable {
    pub handler: IntFn,
    pub mask: u32_,
}
extern "C" {
    #[doc = " \\fn irqInit()\n\\brief Initialise the libnds interrupt system.\n\nThis function is called internally (prior to main()) to set up irqs\non the ARM9.  It must be called on the ARM7 prior to installing irq\nhandlers."]
    pub fn irqInit();
}
extern "C" {
    #[doc = " \\fn irqSet(u32 irq, VoidFn handler)\n\\brief Add a handler for the given interrupt mask.\n\nSpecify the handler to use for the given interrupt. This only works with\nthe default interrupt handler, do not mix the use of this routine with a\nuser-installed IRQ handler.\n\\param irq Mask associated with the interrupt.\n\\param handler Address of the function to use as an interrupt service routine\n\\note\nWhen any handler specifies using IRQ_VBLANK or IRQ_HBLANK, DISP_SR\nis automatically updated to include the corresponding DISP_VBLANK_IRQ or DISP_HBLANK_IRQ.\n\n\\warning Only one IRQ_MASK can be specified with this function."]
    pub fn irqSet(irq: u32_, handler: VoidFn);
}
extern "C" {
    pub fn irqSetAUX(irq: u32_, handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqClear(u32 irq)\n\\brief remove the handler associated with the interrupt mask irq.\n\\param irq Mask associated with the interrupt."]
    pub fn irqClear(irq: u32_);
}
extern "C" {
    pub fn irqClearAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn irqInitHandler(VoidFn handler)\n\\brief Install a user interrupt dispatcher.\n\nThis function installs the main interrupt function, all interrupts are serviced through this routine. For most\npurposes the libnds interrupt dispacther should be used in preference to user code unless you know *exactly* what you're doing.\n\n\\param handler Address of the function to use as an interrupt dispatcher\n\\note the function *must* be ARM code"]
    pub fn irqInitHandler(handler: VoidFn);
}
extern "C" {
    #[doc = " \\fn irqEnable(u32 irq)\n\\brief Allow the given interrupt to occur.\n\\param irq The set of interrupt masks to enable.\n\\note Specify multiple interrupts to enable by ORing several IRQ_MASKS."]
    pub fn irqEnable(irq: u32_);
}
extern "C" {
    pub fn irqEnableAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn irqDisable(u32 irq)\n\\brief Prevent the given interrupt from occuring.\n\\param irq The set of interrupt masks to disable.\n\\note Specify multiple interrupts to disable by ORing several IRQ_MASKS."]
    pub fn irqDisable(irq: u32_);
}
extern "C" {
    pub fn irqDisableAUX(irq: u32_);
}
extern "C" {
    #[doc = " \\fn swiIntrWait(u32 waitForSet, uint32 flags)\n\n\\brief wait for interrupt(s) to occur\n\n\\param waitForSet\n0: Return if the interrupt has already occured\n1: Wait until the interrupt has been set since the call\n\\param flags\ninterrupt mask to wait for"]
    pub fn swiIntrWait(waitForSet: u32_, flags: uint32);
}
extern "C" {
    #[doc = " \\fn  swiWaitForVBlank()\n\\brief Wait for vblank interrupt\n\nWaits for a vertical blank interrupt\n\n\\note Identical to calling swiIntrWait(1, 1)"]
    pub fn swiWaitForVBlank();
}
extern "C" {
    #[doc = " \\fn  VoidFn setPowerButtonCB(VoidFn CB);\n\\brief set callback for DSi Powerbutton press\n\n\\param CB\nfunction to call when power button pressed\n\\return\nthe previously set callback"]
    pub fn setPowerButtonCB(CB: VoidFn) -> VoidFn;
}
extern "C" {
    #[link_name = "\u{1}enterCriticalSection__extern"]
    pub fn enterCriticalSection() -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}leaveCriticalSection__extern"]
    pub fn leaveCriticalSection(oldIME: ::libc::c_int);
}
pub const IPC_SYNC_IRQ_ENABLE: IPC_SYNC_BITS = 16384;
pub const IPC_SYNC_IRQ_REQUEST: IPC_SYNC_BITS = 8192;
pub type IPC_SYNC_BITS = ::libc::c_uint;
extern "C" {
    #[link_name = "\u{1}IPC_SendSync__extern"]
    pub fn IPC_SendSync(sync: ::libc::c_uint);
}
extern "C" {
    #[link_name = "\u{1}IPC_GetSync__extern"]
    pub fn IPC_GetSync() -> ::libc::c_int;
}
pub const IPC_FIFO_SEND_EMPTY: IPC_CONTROL_BITS = 1;
pub const IPC_FIFO_SEND_FULL: IPC_CONTROL_BITS = 2;
pub const IPC_FIFO_SEND_IRQ: IPC_CONTROL_BITS = 4;
pub const IPC_FIFO_SEND_CLEAR: IPC_CONTROL_BITS = 8;
pub const IPC_FIFO_RECV_EMPTY: IPC_CONTROL_BITS = 256;
pub const IPC_FIFO_RECV_FULL: IPC_CONTROL_BITS = 512;
pub const IPC_FIFO_RECV_IRQ: IPC_CONTROL_BITS = 1024;
pub const IPC_FIFO_ERROR: IPC_CONTROL_BITS = 16384;
pub const IPC_FIFO_ENABLE: IPC_CONTROL_BITS = 32768;
pub type IPC_CONTROL_BITS = ::libc::c_uint;
extern "C" {
    pub fn __assert(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
        arg4: *const ::libc::c_char,
    ) -> !;
}
#[doc = "\\brief the GBA file header format.\nSee gbatek for more info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sGBAHeader {
    #[doc = "!< 32 bits arm opcode to jump to executable code."]
    pub entryPoint: u32_,
    #[doc = "!< nintendo logo needed for booting the game."]
    pub logo: [u8_; 156usize],
    #[doc = "!< 12 characters for the game title."]
    pub title: [::libc::c_char; 12usize],
    #[doc = "!< 4 characters for the game code. first character is usally A or B, next 2 characters is a short title\n!< and last character is for destination/language."]
    pub gamecode: [::libc::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: u16_,
    #[doc = "!< fixed value that is always 96h."]
    pub is96h: u8_,
    #[doc = "!< identifies the required hardware."]
    pub unitcode: u8_,
    #[doc = "!< used by nintedo's hardware debuggers. normally 0."]
    pub devicecode: u8_,
    pub unused: [u8_; 7usize],
    #[doc = "!< the version of the game."]
    pub version: u8_,
    #[doc = "!< complement checksum of the gba header."]
    pub complement: u8_,
    #[doc = "!< a 16 bit checksum? (gbatek says its unused/reserved)."]
    pub checksum: u16_,
}
impl Default for sGBAHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the GBA file header format.\nSee gbatek for more info."]
pub type tGBAHeader = sGBAHeader;
#[doc = "\\brief the NDS file header format\nSee gbatek for more info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sNDSHeader {
    #[doc = "!< 12 characters for the game title."]
    pub gameTitle: [::libc::c_char; 12usize],
    #[doc = "!< 4 characters for the game code."]
    pub gameCode: [::libc::c_char; 4usize],
    #[doc = "!< identifies the (commercial) developer."]
    pub makercode: [::libc::c_char; 2usize],
    #[doc = "!< identifies the required hardware."]
    pub unitCode: u8_,
    #[doc = "!< type of device in the game card"]
    pub deviceType: u8_,
    #[doc = "!< capacity of the device (1 << n Mbit)"]
    pub deviceSize: u8_,
    pub reserved1: [u8_; 9usize],
    #[doc = "!< version of the ROM."]
    pub romversion: u8_,
    #[doc = "!< bit 2: auto-boot flag."]
    pub flags: u8_,
    #[doc = "!< offset of the arm9 binary in the nds file."]
    pub arm9romOffset: u32_,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm9executeAddress: *mut ::libc::c_void,
    #[doc = "!< destination address to where the arm9 binary should be copied."]
    pub arm9destination: *mut ::libc::c_void,
    #[doc = "!< size of the arm9 binary."]
    pub arm9binarySize: u32_,
    #[doc = "!< offset of the arm7 binary in the nds file."]
    pub arm7romOffset: u32_,
    #[doc = "!< adress that should be executed after the binary has been copied."]
    pub arm7executeAddress: *mut ::libc::c_void,
    #[doc = "!< destination address to where the arm7 binary should be copied."]
    pub arm7destination: *mut ::libc::c_void,
    #[doc = "!< size of the arm7 binary."]
    pub arm7binarySize: u32_,
    #[doc = "!< File Name Table (FNT) offset."]
    pub filenameOffset: u32_,
    #[doc = "!< File Name Table (FNT) size."]
    pub filenameSize: u32_,
    #[doc = "!< File Allocation Table (FAT) offset."]
    pub fatOffset: u32_,
    #[doc = "!< File Allocation Table (FAT) size."]
    pub fatSize: u32_,
    #[doc = "!< File arm9 overlay offset."]
    pub arm9overlaySource: u32_,
    #[doc = "!< File arm9 overlay size."]
    pub arm9overlaySize: u32_,
    #[doc = "!< File arm7 overlay offset."]
    pub arm7overlaySource: u32_,
    #[doc = "!< File arm7 overlay size."]
    pub arm7overlaySize: u32_,
    #[doc = "!< Port 40001A4h setting for normal commands (used in modes 1 and 3)"]
    pub cardControl13: u32_,
    #[doc = "!< Port 40001A4h setting for KEY1 commands (used in mode 2)"]
    pub cardControlBF: u32_,
    #[doc = "!< offset to the banner with icon and titles etc."]
    pub bannerOffset: u32_,
    #[doc = "!< Secure Area Checksum, CRC-16."]
    pub secureCRC16: u16_,
    #[doc = "!< Secure Area Loading Timeout."]
    pub readTimeout: u16_,
    #[doc = "!< ARM9 Auto Load List RAM Address (?)"]
    pub unknownRAM1: u32_,
    #[doc = "!< ARM7 Auto Load List RAM Address (?)"]
    pub unknownRAM2: u32_,
    #[doc = "!< Secure Area Disable part 1."]
    pub bfPrime1: u32_,
    #[doc = "!< Secure Area Disable part 2."]
    pub bfPrime2: u32_,
    #[doc = "!< total size of the ROM."]
    pub romSize: u32_,
    #[doc = "!< ROM header size."]
    pub headerSize: u32_,
    pub zeros88: [u32_; 14usize],
    #[doc = "!< Nintendo logo needed for booting the game."]
    pub gbaLogo: [u8_; 156usize],
    #[doc = "!< Nintendo Logo Checksum, CRC-16."]
    pub logoCRC16: u16_,
    #[doc = "!< header checksum, CRC-16."]
    pub headerCRC16: u16_,
}
impl Default for sNDSHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the NDS file header format\nSee gbatek for more info."]
pub type tNDSHeader = sNDSHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __DSiHeader {
    pub ndshdr: tNDSHeader,
    #[doc = "!< debug ROM offset."]
    pub debugRomSource: u32_,
    #[doc = "!< debug size."]
    pub debugRomSize: u32_,
    #[doc = "!< debug RAM destination."]
    pub debugRomDestination: u32_,
    pub offset_0x16C: u32_,
    pub zero: [u8_; 16usize],
    pub global_mbk_setting: [[u8_; 4usize]; 5usize],
    pub arm9_mbk_setting: [u32_; 3usize],
    pub arm7_mbk_setting: [u32_; 3usize],
    pub mbk9_wramcnt_setting: u32_,
    pub region_flags: u32_,
    pub access_control: u32_,
    pub scfg_ext_mask: u32_,
    pub offset_0x1BC: [u8_; 3usize],
    pub appflags: u8_,
    pub arm9iromOffset: *mut ::libc::c_void,
    pub offset_0x1C4: u32_,
    pub arm9idestination: *mut ::libc::c_void,
    pub arm9ibinarySize: u32_,
    pub arm7iromOffset: *mut ::libc::c_void,
    pub offset_0x1D4: u32_,
    pub arm7idestination: *mut ::libc::c_void,
    pub arm7ibinarySize: u32_,
    pub digest_ntr_start: u32_,
    pub digest_ntr_size: u32_,
    pub digest_twl_start: u32_,
    pub digest_twl_size: u32_,
    pub sector_hashtable_start: u32_,
    pub sector_hashtable_size: u32_,
    pub block_hashtable_start: u32_,
    pub block_hashtable_size: u32_,
    pub digest_sector_size: u32_,
    pub digest_block_sectorcount: u32_,
    pub banner_size: u32_,
    pub offset_0x20C: u32_,
    pub total_rom_size: u32_,
    pub offset_0x214: u32_,
    pub offset_0x218: u32_,
    pub offset_0x21C: u32_,
    pub modcrypt1_start: u32_,
    pub modcrypt1_size: u32_,
    pub modcrypt2_start: u32_,
    pub modcrypt2_size: u32_,
    pub tid_low: u32_,
    pub tid_high: u32_,
    pub public_sav_size: u32_,
    pub private_sav_size: u32_,
    pub reserved3: [u8_; 176usize],
    pub age_ratings: [u8_; 16usize],
    pub hmac_arm9: [u8_; 20usize],
    pub hmac_arm7: [u8_; 20usize],
    pub hmac_digest_master: [u8_; 20usize],
    pub hmac_icon_title: [u8_; 20usize],
    pub hmac_arm9i: [u8_; 20usize],
    pub hmac_arm7i: [u8_; 20usize],
    pub reserved4: [u8_; 40usize],
    pub hmac_arm9_no_secure: [u8_; 20usize],
    pub reserved5: [u8_; 2636usize],
    pub debug_args: [u8_; 384usize],
    pub rsa_signature: [u8_; 128usize],
}
impl Default for __DSiHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type tDSiHeader = __DSiHeader;
#[doc = "\\brief the NDS banner format.\nSee gbatek for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sNDSBanner {
    #[doc = "!< version of the banner."]
    pub version: u16_,
    #[doc = "!< 16 bit crc/checksum of the banner."]
    pub crc: u16_,
    pub reserved: [u8_; 28usize],
    #[doc = "!< 32*32 icon of the game with 4 bit per pixel."]
    pub icon: [u8_; 512usize],
    #[doc = "!< the pallete of the icon."]
    pub palette: [u16_; 16usize],
    #[doc = "!< title of the game in 6 different languages."]
    pub titles: [[u16_; 128usize]; 6usize],
}
impl Default for sNDSBanner {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\\brief the NDS banner format.\nSee gbatek for more information."]
pub type tNDSBanner = sNDSBanner;
#[doc = "!<\tThe display currently in a vertical blank."]
pub const DISP_IN_VBLANK: DISP_BITS = 1;
#[doc = "!<\tThe display currently in a horizontal blank."]
pub const DISP_IN_HBLANK: DISP_BITS = 2;
#[doc = "!<\tCurrent scanline and %DISP_Y match."]
pub const DISP_YTRIGGERED: DISP_BITS = 4;
#[doc = "!<\tInterrupt on vertical blank."]
pub const DISP_VBLANK_IRQ: DISP_BITS = 8;
#[doc = "!<\tInterrupt on horizontal blank."]
pub const DISP_HBLANK_IRQ: DISP_BITS = 16;
#[doc = "!<\tInterrupt when current scanline and %DISP_Y match."]
pub const DISP_YTRIGGER_IRQ: DISP_BITS = 32;
#[doc = "! LCD Status register bitdefines"]
pub type DISP_BITS = ::libc::c_uint;
extern "C" {
    #[doc = "\\brief sets the Y trigger(?)\n\n\\param Yvalue the value for the Y trigger."]
    #[link_name = "\u{1}SetYtrigger__extern"]
    pub fn SetYtrigger(Yvalue: ::libc::c_int);
}
#[doc = "!< Power the sound hardware (needed to hear stuff in GBA mode too)."]
pub const PM_SOUND_AMP: PM_Bits = 1;
#[doc = "!< Mute the main speakers, headphone output will still work."]
pub const PM_SOUND_MUTE: PM_Bits = 2;
#[doc = "!< Enable the bottom backlight if set."]
pub const PM_BACKLIGHT_BOTTOM: PM_Bits = 4;
#[doc = "!< Enable the top backlight if set."]
pub const PM_BACKLIGHT_TOP: PM_Bits = 8;
#[doc = "!< Turn the power *off* if set."]
pub const PM_SYSTEM_PWR: PM_Bits = 64;
#[doc = "!<\tControls the power for both LCD screens."]
pub const POWER_LCD: PM_Bits = 65537;
#[doc = "!<\tControls the power for the main 2D core."]
pub const POWER_2D_A: PM_Bits = 65538;
#[doc = "!<\tControls the power for the 3D matrix."]
pub const POWER_MATRIX: PM_Bits = 65540;
#[doc = "!<\tControls the power for the main 3D core."]
pub const POWER_3D_CORE: PM_Bits = 65544;
#[doc = "!<\tControls the power for the sub 2D core."]
pub const POWER_2D_B: PM_Bits = 66048;
#[doc = "!<\tControls which screen should use the main core."]
pub const POWER_SWAP_LCDS: PM_Bits = 98304;
#[doc = "!< power just 2D hardware."]
pub const POWER_ALL_2D: PM_Bits = 66051;
#[doc = "!< power everything."]
pub const POWER_ALL: PM_Bits = 66063;
#[doc = "! Power Management control bits"]
pub type PM_Bits = ::libc::c_uint;
extern "C" {
    #[doc = "\t\\brief Causes the nds to go to sleep.\nThe nds will be reawakened when the lid is opened.\n\n\\note By default, this is automatically called when closing the lid."]
    pub fn systemSleep();
}
extern "C" {
    #[doc = "\tSet the LED blink mode\n\\param bm What to power on."]
    pub fn ledBlink(bm: ::libc::c_int);
}
extern "C" {
    #[doc = "!\tChecks whether the application is running in DSi mode."]
    #[link_name = "\u{1}isDSiMode__extern"]
    pub fn isDSiMode() -> bool;
}
#[doc = "!<\tControls the power for the sound controller."]
pub const POWER_SOUND: ARM7_power = 1;
#[doc = "!<\tSelects the PM control register"]
pub const PM_CONTROL_REG: ARM7_power = 0;
#[doc = "!<\tSelects the PM battery register"]
pub const PM_BATTERY_REG: ARM7_power = 1;
#[doc = "!<\tSelects the PM amplifier register"]
pub const PM_AMPLIFIER_REG: ARM7_power = 2;
#[doc = "!<\tSelects the PM read register"]
pub const PM_READ_REGISTER: ARM7_power = 128;
#[doc = "!<\tSelects the PM amp register"]
pub const PM_AMP_OFFSET: ARM7_power = 2;
#[doc = "!<\tSelects the PM gain register"]
pub const PM_GAIN_OFFSET: ARM7_power = 3;
#[doc = "!<\tSelects the DS Lite backlight register"]
pub const PM_BACKLIGHT_LEVEL: ARM7_power = 4;
#[doc = "!<\tSets the mic gain to 20db"]
pub const PM_GAIN_20: ARM7_power = 0;
#[doc = "!<\tSets the mic gain to 40db"]
pub const PM_GAIN_40: ARM7_power = 1;
#[doc = "!<\tSets the mic gain to 80db"]
pub const PM_GAIN_80: ARM7_power = 2;
#[doc = "!<\tSets the mic gain to 160db"]
pub const PM_GAIN_160: ARM7_power = 3;
#[doc = "!<\tTurns the sound amp on"]
pub const PM_AMP_ON: ARM7_power = 1;
#[doc = "!<\tTurns the sound amp off"]
pub const PM_AMP_OFF: ARM7_power = 0;
#[doc = "!\tPower-controlled hardware devices accessable to the ARM7.\n*!\tNote that these should only be used when programming for\nthe ARM7.  Trying to boot up these hardware devices via\nthe ARM9 would lead to unexpected results.\nARM7 only.\n*/"]
pub type ARM7_power = ::libc::c_uint;
extern "C" {
    pub fn installSystemFIFO();
}
extern "C" {
    pub fn sleepEnabled() -> ::libc::c_int;
}
extern "C" {
    pub fn writePowerManagement(reg: ::libc::c_int, command: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}readPowerManagement__extern"]
    pub fn readPowerManagement(reg: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}powerOn__extern"]
    pub fn powerOn(bits: ::libc::c_int);
}
extern "C" {
    #[link_name = "\u{1}powerOff__extern"]
    pub fn powerOff(bits: PM_Bits);
}
extern "C" {
    pub fn readUserSettings();
}
extern "C" {
    pub fn systemShutDown();
}
#[doc = "!< low backlight setting."]
pub const BACKLIGHT_LOW: BACKLIGHT_LEVELS = 0;
#[doc = "!< medium backlight setting."]
pub const BACKLIGHT_MED: BACKLIGHT_LEVELS = 1;
#[doc = "!< high backlight setting."]
pub const BACKLIGHT_HIGH: BACKLIGHT_LEVELS = 2;
#[doc = "!< max backlight setting."]
pub const BACKLIGHT_MAX: BACKLIGHT_LEVELS = 3;
#[doc = "\t\\brief Backlight level settings.\nNote, these are only available on DS Lite."]
pub type BACKLIGHT_LEVELS = ::libc::c_uint;
#[doc = "\\brief User's DS settings.\nDefines the structure the DS firmware uses for transfer\nof the user's settings to the booted program.\n\nTheme/Color values:\n- 0 = Gray\n- 1 = Brown\n- 2 = Red\n- 3 = Pink\n- 4 = Orange\n- 5 = Yellow\n- 6 = Yellow/Green-ish\n- 7 = Green\n- 8 = Dark Green\n- 9 = Green/Blue-ish\n- 10 = Light Blue\n- 11 = Blue\n- 12 = Dark Blue\n- 13 = Dark Purple\n- 14 = Purple\n- 15 = Purple/Red-ish\n\nLanguage values:\n- 0 = Japanese\n- 1 = English\n- 2 = French\n- 3 = German\n- 4 = Italian\n- 5 = Spanish\n- 6 = Chinese(?)\n- 7 = Unknown/Reserved"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tPERSONAL_DATA {
    pub RESERVED0: [u8_; 2usize],
    #[doc = "!<\tThe user's theme color (0-15)."]
    pub theme: u8_,
    #[doc = "!<\tThe user's birth month (1-12)."]
    pub birthMonth: u8_,
    #[doc = "!<\tThe user's birth day (1-31)."]
    pub birthDay: u8_,
    pub RESERVED1: [u8_; 1usize],
    #[doc = "!<\tThe user's name in UTF-16 format."]
    pub name: [s16; 10usize],
    #[doc = "!<\tThe length of the user's name in characters."]
    pub nameLen: u16_,
    #[doc = "!<\tThe user's message."]
    pub message: [s16; 26usize],
    #[doc = "!<\tThe length of the user's message in characters."]
    pub messageLen: u16_,
    #[doc = "!<\tWhat hour the alarm clock is set to (0-23)."]
    pub alarmHour: u8_,
    #[doc = "!<\tWhat minute the alarm clock is set to (0-59)."]
    pub alarmMinute: u8_,
    pub RESERVED2: [u8_; 4usize],
    #[doc = "!<\tTouchscreen calibration: first X touch"]
    pub calX1: u16_,
    #[doc = "!<\tTouchscreen calibration: first Y touch"]
    pub calY1: u16_,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calX1px: u8_,
    #[doc = "!<\tTouchscreen calibration: first X touch pixel"]
    pub calY1px: u8_,
    #[doc = "!<\tTouchscreen calibration: second X touch"]
    pub calX2: u16_,
    #[doc = "!<\tTouchscreen calibration: second Y touch"]
    pub calY2: u16_,
    #[doc = "!<\tTouchscreen calibration: second X touch pixel"]
    pub calX2px: u8_,
    #[doc = "!<\tTouchscreen calibration: second Y touch pixel"]
    pub calY2px: u8_,
    pub __bindgen_anon_1: tPERSONAL_DATA__bindgen_ty_1,
    pub RESERVED3: u16_,
    #[doc = "!<\tReal Time Clock offset."]
    pub rtcOffset: u32_,
    pub RESERVED4: u32_,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tPERSONAL_DATA__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tPERSONAL_DATA__bindgen_ty_1 {
    #[inline]
    pub fn language(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_language(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn gbaScreen(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gbaScreen(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn defaultBrightness(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_defaultBrightness(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn autoMode(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoMode(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED5(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED5(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn settingsLost(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_settingsLost(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESERVED6(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_RESERVED6(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        language: ::libc::c_uint,
        gbaScreen: ::libc::c_uint,
        defaultBrightness: ::libc::c_uint,
        autoMode: ::libc::c_uint,
        RESERVED5: ::libc::c_uint,
        settingsLost: ::libc::c_uint,
        RESERVED6: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let language: u32 = unsafe { ::core::mem::transmute(language) };
            language as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gbaScreen: u32 = unsafe { ::core::mem::transmute(gbaScreen) };
            gbaScreen as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let defaultBrightness: u32 = unsafe { ::core::mem::transmute(defaultBrightness) };
            defaultBrightness as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let autoMode: u32 = unsafe { ::core::mem::transmute(autoMode) };
            autoMode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let RESERVED5: u32 = unsafe { ::core::mem::transmute(RESERVED5) };
            RESERVED5 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let settingsLost: u32 = unsafe { ::core::mem::transmute(settingsLost) };
            settingsLost as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let RESERVED6: u32 = unsafe { ::core::mem::transmute(RESERVED6) };
            RESERVED6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "\\brief User's DS settings.\nDefines the structure the DS firmware uses for transfer\nof the user's settings to the booted program.\n\nTheme/Color values:\n- 0 = Gray\n- 1 = Brown\n- 2 = Red\n- 3 = Pink\n- 4 = Orange\n- 5 = Yellow\n- 6 = Yellow/Green-ish\n- 7 = Green\n- 8 = Dark Green\n- 9 = Green/Blue-ish\n- 10 = Light Blue\n- 11 = Blue\n- 12 = Dark Blue\n- 13 = Dark Purple\n- 14 = Purple\n- 15 = Purple/Red-ish\n\nLanguage values:\n- 0 = Japanese\n- 1 = English\n- 2 = French\n- 3 = German\n- 4 = Italian\n- 5 = Spanish\n- 6 = Chinese(?)\n- 7 = Unknown/Reserved"]
pub type PERSONAL_DATA = tPERSONAL_DATA;
#[doc = "! struct containing time and day of the real time clock."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTCtime {
    #[doc = "!< add 2000 to get 4 digit year"]
    pub year: u8_,
    #[doc = "!< 1 to 12"]
    pub month: u8_,
    #[doc = "!< 1 to (days in month)"]
    pub day: u8_,
    #[doc = "!< day of week"]
    pub weekday: u8_,
    #[doc = "!< 0 to 11 for AM, 52 to 63 for PM"]
    pub hours: u8_,
    #[doc = "!< 0 to 59"]
    pub minutes: u8_,
    #[doc = "!< 0 to 59"]
    pub seconds: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __argv {
    pub argvMagic: ::libc::c_int,
    pub commandLine: *mut ::libc::c_char,
    pub length: ::libc::c_int,
    pub argc: ::libc::c_int,
    pub argv: *mut *mut ::libc::c_char,
    pub dummy: ::libc::c_int,
    pub host: u32_,
}
impl Default for __argv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __bootstub {
    pub bootsig: u64_,
    pub arm9reboot: VoidFn,
    pub arm7reboot: VoidFn,
    pub bootsize: u32_,
}
extern "C" {
    pub fn resetARM9(address: u32_);
}
#[doc = "!< divides the timer clock by 1 (~33513.982 kHz)"]
pub const ClockDivider_1: ClockDivider = 0;
#[doc = "!< divides the timer clock by 64 (~523.657 kHz)"]
pub const ClockDivider_64: ClockDivider = 1;
#[doc = "!< divides the timer clock by 256 (~130.914 kHz)"]
pub const ClockDivider_256: ClockDivider = 2;
#[doc = "!< divides the timer clock by 1024 (~32.7284 kHz)"]
pub const ClockDivider_1024: ClockDivider = 3;
#[doc = "! allowable timer clock dividers."]
pub type ClockDivider = ::libc::c_uint;
extern "C" {
    #[doc = "\t\\brief start a hardware timer.\nCallback is tied directly to interrupt table and called directly, resulting in less latency than the attached timer.\n\\param timer \tThe hardware timer to use (0 - 3).\n\\param divider \tThe timer channel clock divider (clock will tick at 33.513982 MHz / divider)\n\\param ticks\tThe number of ticks which must elapse before the timer overflows\n\\param callback The callback to be called when the timer expires (if null, no IRQ will be generated by the timer)"]
    pub fn timerStart(timer: ::libc::c_int, divider: ClockDivider, ticks: u16_, callback: VoidFn);
}
extern "C" {
    #[doc = "\t\\brief returns the ticks elapsed since the last call to timerElapsed().\n\\param timer The hardware timer to use (0 - 3).\n\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerElapsed(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief returns the raw ticks of the specified timer.\n\\param timer The hardware timer to use (0 - 3).\n\\return the raw ticks of the specified timer data register."]
    #[link_name = "\u{1}timerTick__extern"]
    pub fn timerTick(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief pauses the specified timer.\n\\param timer The hardware timer to use (0 - 3).\n\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerPause(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief unpauses the specified timer.\n\\param timer The hardware timer to use (0 - 3)."]
    #[link_name = "\u{1}timerUnpause__extern"]
    pub fn timerUnpause(timer: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief Stops the specified timer.\n\\param timer The hardware timer to use (0 - 3).\n\\return The number of ticks which have elapsed since the last call to timerElapsed()."]
    pub fn timerStop(timer: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "\t\\brief begins cpu Timing using two timers for 32bit resolution.\n\\param timer The base hardware timer to use (0 - 2)."]
    pub fn cpuStartTiming(timer: ::libc::c_int);
}
extern "C" {
    #[doc = "\t\\brief returns the number of ticks which have elapsed since cpuStartTiming.\n\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuGetTiming() -> u32_;
}
extern "C" {
    #[doc = "\t\\brief ends cpu Timing.\n\\return The number of ticks which have elapsed since cpuStartTiming."]
    pub fn cpuEndTiming() -> u32_;
}
extern "C" {
    #[link_name = "\u{1}timerTicks2usec__extern"]
    pub fn timerTicks2usec(ticks: u32_) -> u32_;
}
extern "C" {
    #[link_name = "\u{1}timerTicks2msec__extern"]
    pub fn timerTicks2msec(ticks: u32_) -> u32_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_1__extern"]
    pub fn timerFreqToTicks_1(freq: ::libc::c_int) -> u16_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_64__extern"]
    pub fn timerFreqToTicks_64(freq: ::libc::c_int) -> u16_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_256__extern"]
    pub fn timerFreqToTicks_256(freq: ::libc::c_int) -> u16_;
}
extern "C" {
    #[link_name = "\u{1}timerFreqToTicks_1024__extern"]
    pub fn timerFreqToTicks_1024(freq: ::libc::c_int) -> u16_;
}
#[doc = "< \\brief fifo channel reserved for power management."]
pub const FIFO_PM: FifoChannels = 0;
#[doc = "< \\brief fifo channel reserved for sound access."]
pub const FIFO_SOUND: FifoChannels = 1;
#[doc = "< \\brief fifo channel reserved for system functions."]
pub const FIFO_SYSTEM: FifoChannels = 2;
#[doc = "< \\brief fifo channel reserved for the maxmod library."]
pub const FIFO_MAXMOD: FifoChannels = 3;
#[doc = "< \\brief fifo channel reserved for the dswifi library."]
pub const FIFO_DSWIFI: FifoChannels = 4;
#[doc = "< \\brief fifo channel reserved for dsi sdmmc control."]
pub const FIFO_SDMMC: FifoChannels = 5;
#[doc = "< \\brief fifo channel reserved for firmware access."]
pub const FIFO_FIRMWARE: FifoChannels = 6;
#[doc = "< \\brief fifo channel reserved for future use."]
pub const FIFO_RSVD_01: FifoChannels = 7;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_01: FifoChannels = 8;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_02: FifoChannels = 9;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_03: FifoChannels = 10;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_04: FifoChannels = 11;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_05: FifoChannels = 12;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_06: FifoChannels = 13;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_07: FifoChannels = 14;
#[doc = "< \\brief fifo channel available for users."]
pub const FIFO_USER_08: FifoChannels = 15;
#[doc = "! Enum values for the different fifo channels."]
pub type FifoChannels = ::libc::c_uint;
pub const SOUND_SET_PAN: FifoSoundCommand = 0;
pub const SOUND_SET_VOLUME: FifoSoundCommand = 1048576;
pub const SOUND_SET_FREQ: FifoSoundCommand = 2097152;
pub const SOUND_SET_WAVEDUTY: FifoSoundCommand = 3145728;
pub const SOUND_MASTER_ENABLE: FifoSoundCommand = 4194304;
pub const SOUND_MASTER_DISABLE: FifoSoundCommand = 5242880;
pub const SOUND_PAUSE: FifoSoundCommand = 6291456;
pub const SOUND_RESUME: FifoSoundCommand = 7340032;
pub const SOUND_KILL: FifoSoundCommand = 8388608;
pub const SOUND_SET_MASTER_VOL: FifoSoundCommand = 9437184;
pub const MIC_STOP: FifoSoundCommand = 10485760;
#[doc = "! Enum values for the fifo sound commands."]
pub type FifoSoundCommand = ::libc::c_uint;
pub const SYS_REQ_TOUCH: FifoSystemCommands = 0;
pub const SYS_REQ_KEYS: FifoSystemCommands = 1;
pub const SYS_REQ_TIME: FifoSystemCommands = 2;
pub const SYS_SET_TIME: FifoSystemCommands = 3;
pub const SDMMC_INSERT: FifoSystemCommands = 4;
pub const SDMMC_REMOVE: FifoSystemCommands = 5;
#[doc = "! Enum values for the fifo system commands."]
pub type FifoSystemCommands = ::libc::c_uint;
pub const SDMMC_HAVE_SD: FifoSdmmcCommands = 0;
pub const SDMMC_SD_START: FifoSdmmcCommands = 1;
pub const SDMMC_SD_IS_INSERTED: FifoSdmmcCommands = 2;
pub const SDMMC_SD_STOP: FifoSdmmcCommands = 3;
pub const SDMMC_NAND_START: FifoSdmmcCommands = 4;
pub const SDMMC_NAND_STOP: FifoSdmmcCommands = 5;
pub const SDMMC_NAND_SIZE: FifoSdmmcCommands = 6;
pub type FifoSdmmcCommands = ::libc::c_uint;
pub const FW_READ: FifoFirmwareCommands = 0;
pub const FW_WRITE: FifoFirmwareCommands = 1;
pub type FifoFirmwareCommands = ::libc::c_uint;
pub const PM_REQ_ON: FifoPMCommands = 65536;
pub const PM_REQ_OFF: FifoPMCommands = 131072;
pub const PM_REQ_LED: FifoPMCommands = 196608;
pub const PM_REQ_SLEEP: FifoPMCommands = 262144;
pub const PM_REQ_SLEEP_DISABLE: FifoPMCommands = 327680;
pub const PM_REQ_SLEEP_ENABLE: FifoPMCommands = 393216;
pub const PM_REQ_BATTERY: FifoPMCommands = 458752;
pub const PM_REQ_SLOT1_DISABLE: FifoPMCommands = 524288;
pub const PM_REQ_SLOT1_ENABLE: FifoPMCommands = 589824;
#[doc = "! Enum values for the fifo power management commands."]
pub type FifoPMCommands = ::libc::c_uint;
pub const WIFI_ENABLE: FifoWifiCommands = 0;
pub const WIFI_DISABLE: FifoWifiCommands = 1;
pub const WIFI_SYNC: FifoWifiCommands = 2;
pub const WIFI_STARTUP: FifoWifiCommands = 3;
#[doc = "! Enum values for the fifo wifi commands."]
pub type FifoWifiCommands = ::libc::c_uint;
#[doc = "< \\brief  Steady on"]
pub const PM_LED_ON: PM_LedBlinkMode = 0;
#[doc = "< \\brief Blinking, mostly off"]
pub const PM_LED_SLEEP: PM_LedBlinkMode = 1;
#[doc = "< \\brief Blinking, mostly on"]
pub const PM_LED_BLINK: PM_LedBlinkMode = 3;
#[doc = "! Power Management LED blink mode control bits."]
pub type PM_LedBlinkMode = ::libc::c_uint;
#[doc = "\\brief fifo callback function pointer with the sent address and the callback's user data.\n\nThe handler is called when new data arrives.\n\n\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,\nbut don't call alloc, free or printf from within them, just to be safe."]
pub type FifoAddressHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(address: *mut ::libc::c_void, userdata: *mut ::libc::c_void),
>;
#[doc = "\\brief fifo callback function pointer with the sent value and the callback's user data.\n\nThe handler is called when new data arrives.\n\n\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,\nbut don't call alloc, free or printf from within them, just to be safe."]
pub type FifoValue32HandlerFunc =
    ::core::option::Option<unsafe extern "C" fn(value32: u32_, userdata: *mut ::libc::c_void)>;
#[doc = "\\brief fifo callback function pointer with the number of bytes sent and the callback's user data\n\nThe handler is called when new data arrives.\nThis callback must call fifoGetData to actually retrieve the data. If it doesn't, the data will be destroyed on return.\n\n\\note callback functions are called from interrupt level, but are well secured. not too much caution is necessary,\nbut don't call alloc, free or printf from within them, just to be safe."]
pub type FifoDatamsgHandlerFunc = ::core::option::Option<
    unsafe extern "C" fn(num_bytes: ::libc::c_int, userdata: *mut ::libc::c_void),
>;
extern "C" {
    #[doc = "\\brief Initializes the fifo system.\n\nAttempts to sync with the other CPU, if it fails, fifo services won't be provided.\n\n\\note call irqInit() before calling this function.\n\n\\return true if syncing worked, false if something went wrong."]
    pub fn fifoInit() -> bool;
}
extern "C" {
    #[doc = "\\brief Send an address to an channel.\n\nTransmits an address in the range 0x02000000-0x023FFFFF to the other CPU.\n\n\\param channel channel number to send to.\n\\param address address to send.\n\n\\return true if the address has been send, false if something went wrong."]
    pub fn fifoSendAddress(channel: ::libc::c_int, address: *mut ::libc::c_void) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a 32bit value.\n\nTransmits a 32bit value to the other CPU.\n\n\\param channel channel number to send to\n\\param value32 32bit value to send\n\n\\return true if the value has been send, false if something went wrong.\n\n\\note Transfer is more efficient if the top 8 bits are zero. So sending smaller values or bitmasks that don't include the top bits is preferred."]
    pub fn fifoSendValue32(channel: ::libc::c_int, value32: u32_) -> bool;
}
extern "C" {
    #[doc = "\\brief Send a sequence of bytes to the other CPU.\n\nnum_bytes can be between 0 and FIFO_MAX_DATA_BYTES - sending 0 bytes can be useful sometimes...\n\n\\param channel channel number to send to\n\\param num_bytes number of bytes to send\n\\param data_array pointer to data array\n\n\\return true if the data message has been send, false if something went wrong."]
    pub fn fifoSendDatamsg(
        channel: ::libc::c_int,
        num_bytes: ::libc::c_int,
        data_array: *mut u8_,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user address message callback.\n\nSet a callback to receive incoming address messages on a specific channel.\n\n\\param channel channel number to send to.\n\\param newhandler a function pointer to the new handler function.\n\\param userdata a pointer that will be passed on to the handler when it will be called.\n\n\\return true if the handler has been set, false if something went wrong.\n\n\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetAddressHandler(
        channel: ::libc::c_int,
        newhandler: FifoAddressHandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user value32 message callback.\n\nSet a callback to receive incoming value32 messages on a specific channel.\n\n\\param channel channel number to send to.\n\\param newhandler a function pointer to the new handler function.\n\\param userdata a pointer that will be passed on to the handler when it will be called.\n\n\\return true if the handler has been set, false if something went wrong.\n\n\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetValue32Handler(
        channel: ::libc::c_int,
        newhandler: FifoValue32HandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Set user data message callback.\n\nSet a callback to receive incoming data messages on a specific channel.\n\n\\param channel channel number to send to.\n\\param newhandler a function pointer to the new handler function.\n\\param userdata a pointer that will be passed on to the handler when it will be called.\n\n\\return true if the handler has been set, false if something went wrong.\n\n\\note Setting the handler for a channel feeds the queue of buffered messages to the new handler, if there are any unread messages."]
    pub fn fifoSetDatamsgHandler(
        channel: ::libc::c_int,
        newhandler: FifoDatamsgHandlerFunc,
        userdata: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any addresses in the fifo queue.\n\n\\param channel the channel to check.\n\n\\return true if there is any addresses in the queue and if there isn't an address handler in place for the channel."]
    pub fn fifoCheckAddress(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any values in the fifo queue.\n\n\\param channel the channel to check.\n\n\\return true if there is any values in the queue and if there isn't a value handler in place for the channel."]
    pub fn fifoCheckValue32(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief checks if there is any data messages in the fifo queue.\n\n\\param channel the channel to check.\n\n\\return true if there is any data messages in the queue and if there isn't a data message handler in place for the channel."]
    pub fn fifoCheckDatamsg(channel: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief gets the number of bytes in the queue for the first data entry.\n\n\\param channel the channel to check.\n\n\\return the number of bytes in the queue for the first data entry, or -1 if there are no entries."]
    pub fn fifoCheckDatamsgLength(channel: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief Get the first address in queue for a specific channel.\n\n\\param channel the channel to check.\n\n\\return the first address in queue, or NULL if there is none."]
    pub fn fifoGetAddress(channel: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "\\brief Get the first value32 in queue for a specific channel.\n\n\\param channel the channel to check.\n\n\\return the first value32 in queue, or 0 if there is no message."]
    pub fn fifoGetValue32(channel: ::libc::c_int) -> u32_;
}
extern "C" {
    #[doc = "\\brief Reads a data message in a given buffer and returns the number of bytes written.\n\n\\param channel the channel to check.\n\\param buffersize the size of the buffer where the message will be copied to.\n\\param destbuffer a pointer to the buffer where the message will be copied to.\n\n\\return the number of bytes written, or -1 if there is no message.\n\n\\warning If your buffer is not big enough, you may lose data! Check the data length first if you're not sure what the size is."]
    pub fn fifoGetDatamsg(
        channel: ::libc::c_int,
        buffersize: ::libc::c_int,
        destbuffer: *mut u8_,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "\\brief waits for any data messages in the fifo queue.\n\n\\param channel the channel to check."]
    #[link_name = "\u{1}fifoWaitValue32__extern"]
    pub fn fifoWaitValue32(channel: ::libc::c_int);
}
#[doc = "! holds data related to the touch screen."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct touchPosition {
    #[doc = "!< Raw x value from the A2D"]
    pub rawx: u16_,
    #[doc = "!< Raw y value from the A2D"]
    pub rawy: u16_,
    #[doc = "!< Processes pixel X value"]
    pub px: u16_,
    #[doc = "!< Processes pixel Y value"]
    pub py: u16_,
    #[doc = "!< Raw cross panel resistance"]
    pub z1: u16_,
    #[doc = "!< Raw cross panel resistance"]
    pub z2: u16_,
}
#[doc = "!< Keypad A button."]
pub const KEY_A: KEYPAD_BITS = 1;
#[doc = "!< Keypad B button."]
pub const KEY_B: KEYPAD_BITS = 2;
#[doc = "!< Keypad SELECT button."]
pub const KEY_SELECT: KEYPAD_BITS = 4;
#[doc = "!< Keypad START button."]
pub const KEY_START: KEYPAD_BITS = 8;
#[doc = "!< Keypad RIGHT button."]
pub const KEY_RIGHT: KEYPAD_BITS = 16;
#[doc = "!< Keypad LEFT button."]
pub const KEY_LEFT: KEYPAD_BITS = 32;
#[doc = "!< Keypad UP button."]
pub const KEY_UP: KEYPAD_BITS = 64;
#[doc = "!< Keypad DOWN button."]
pub const KEY_DOWN: KEYPAD_BITS = 128;
#[doc = "!< Right shoulder button."]
pub const KEY_R: KEYPAD_BITS = 256;
#[doc = "!< Left shoulder button."]
pub const KEY_L: KEYPAD_BITS = 512;
#[doc = "!< Keypad X button."]
pub const KEY_X: KEYPAD_BITS = 1024;
#[doc = "!< Keypad Y button."]
pub const KEY_Y: KEYPAD_BITS = 2048;
#[doc = "!< Touchscreen pendown."]
pub const KEY_TOUCH: KEYPAD_BITS = 4096;
#[doc = "!< Lid state."]
pub const KEY_LID: KEYPAD_BITS = 8192;
#[doc = "! enum values for the keypad buttons."]
pub type KEYPAD_BITS = ::libc::c_uint;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swiSHA1context {
    #[doc = "< intermediate digest state"]
    pub state: [u32_; 5usize],
    #[doc = "< number of bytes processed"]
    pub total: [u32_; 2usize],
    #[doc = "< data block being processed"]
    pub buffer: [u8_; 64usize],
    pub fragment_size: u32_,
    #[doc = "< data block being processed"]
    pub sha_block: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut swiSHA1context, src: *const ::libc::c_void, len: usize),
    >,
}
impl Default for swiSHA1context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type swiSHA1context_t = swiSHA1context;
extern "C" {
    #[doc = " \\brief          SHA-1 context setup\n\n \\param ctx      context to be initialized"]
    pub fn swiSHA1Init(ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 process buffer\n\n \\param ctx      SHA-1 context\n \\param data     buffer to process\n \\param len      length of data"]
    pub fn swiSHA1Update(ctx: *mut swiSHA1context_t, data: *const ::libc::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief          SHA-1 final digest\n\n \\param digest   buffer to hold SHA-1 checksum result\n \\param ctx      SHA-1 context"]
    pub fn swiSHA1Final(digest: *mut ::libc::c_void, ctx: *mut swiSHA1context_t);
}
extern "C" {
    #[doc = " \\brief          SHA-1 checksum\n\n \\param digest   buffer to hold SHA-1 checksum result\n \\param data     buffer to process\n \\param len      length of data"]
    pub fn swiSHA1Calc(digest: *mut ::libc::c_void, data: *const ::libc::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief          SHA-1 verify\n\n \\param digest1  buffer containing hash to verify\n \\param digest2  buffer containing hash to verify"]
    pub fn swiSHA1Verify(digest1: *const ::libc::c_void, digest2: *const ::libc::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aes_keyslot {
    pub normalkey: [vu8; 16usize],
    pub key_x: [vu8; 16usize],
    pub key_y: [vu8; 16usize],
}
pub type aes_keyslot_t = aes_keyslot;
extern "C" {
    #[link_name = "\u{1}SerialWaitBusy__extern"]
    pub fn SerialWaitBusy();
}
extern "C" {
    pub fn readFirmware(address: u32_, destination: *mut ::libc::c_void, size: u32_);
}
pub type MIC_BUF_SWAP_CB =
    ::core::option::Option<unsafe extern "C" fn(completedBuffer: *mut u8_, length: ::libc::c_int)>;
extern "C" {
    pub fn micReadData8() -> u8_;
}
extern "C" {
    pub fn micReadData12() -> u16_;
}
extern "C" {
    pub fn micStartRecording(
        buffer: *mut u8_,
        length: ::libc::c_int,
        freq: ::libc::c_int,
        timer: ::libc::c_int,
        eightBitSample: bool,
        bufferSwapCallback: MIC_BUF_SWAP_CB,
    );
}
extern "C" {
    pub fn micStopRecording() -> ::libc::c_int;
}
extern "C" {
    pub fn micTimerHandler();
}
extern "C" {
    pub fn micSetAmp(control: u8_, gain: u8_);
}
extern "C" {
    #[link_name = "\u{1}micOn__extern"]
    pub fn micOn();
}
extern "C" {
    #[link_name = "\u{1}micOff__extern"]
    pub fn micOff();
}
extern "C" {
    pub fn installSoundFIFO();
}
extern "C" {
    pub fn rtcReset();
}
extern "C" {
    pub fn rtcTransaction(
        command: *mut uint8,
        commandLength: uint32,
        result: *mut uint8,
        resultLength: uint32,
    );
}
extern "C" {
    pub fn rtcGetTime(time: *mut uint8);
}
extern "C" {
    pub fn rtcSetTime(time: *mut uint8);
}
extern "C" {
    pub fn rtcGetTimeAndDate(time: *mut uint8);
}
extern "C" {
    pub fn rtcSetTimeAndDate(time: *mut uint8);
}
extern "C" {
    pub fn rtcGetData(data: *mut uint8, size: uint32);
}
extern "C" {
    pub fn BCDToInteger(data: *mut uint8, length: uint32);
}
extern "C" {
    pub fn integerToBCD(data: *mut uint8, length: uint32);
}
extern "C" {
    pub fn initClockIRQ();
}
extern "C" {
    pub fn resyncClock();
}
extern "C" {
    #[link_name = "\u{1}cdcIsAvailable__extern"]
    pub fn cdcIsAvailable() -> bool;
}
pub const CDC_CONTROL: cdcBanks = 0;
pub const CDC_SOUND: cdcBanks = 1;
pub const CDC_TOUCHCNT: cdcBanks = 3;
pub const CDC_TOUCHDATA: cdcBanks = 252;
pub type cdcBanks = ::libc::c_uint;
extern "C" {
    pub fn cdcReadReg(bank: u8_, reg: u8_) -> u8_;
}
extern "C" {
    pub fn cdcReadRegArray(bank: u8_, reg: u8_, data: *mut ::libc::c_void, size: u8_);
}
extern "C" {
    pub fn cdcWriteReg(bank: u8_, reg: u8_, value: u8_);
}
extern "C" {
    pub fn cdcWriteRegMask(bank: u8_, reg: u8_, mask: u8_, value: u8_);
}
extern "C" {
    pub fn cdcWriteRegArray(bank: u8_, reg: u8_, data: *const ::libc::c_void, size: u8_);
}
extern "C" {
    pub fn cdcTouchInit();
}
extern "C" {
    pub fn cdcTouchPenDown() -> bool;
}
extern "C" {
    pub fn cdcTouchRead(pos: *mut touchPosition) -> bool;
}
extern "C" {
    pub fn inputGetAndSend();
}
extern "C" {
    #[link_name = "\u{1}i2cWaitBusy__extern"]
    pub fn i2cWaitBusy();
}
pub const I2C_CAM0: i2cDevices = 122;
pub const I2C_CAM1: i2cDevices = 120;
pub const I2C_UNK1: i2cDevices = 160;
pub const I2C_UNK2: i2cDevices = 224;
pub const I2C_PM: i2cDevices = 74;
pub const I2C_UNK3: i2cDevices = 64;
pub const I2C_GPIO: i2cDevices = 144;
pub type i2cDevices = ::libc::c_uint;
extern "C" {
    pub fn i2cWriteRegister(device: u8_, reg: u8_, data: u8_) -> u8_;
}
extern "C" {
    pub fn i2cReadRegister(device: u8_, reg: u8_) -> u8_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmcdevice {
    pub data: *mut u8_,
    pub size: u32_,
    pub error: u32_,
    pub stat0: u16_,
    pub stat1: u16_,
    pub ret: [u32_; 4usize],
    pub initarg: u32_,
    pub isSDHC: u32_,
    pub clk: u32_,
    pub SDOPT: u32_,
    pub devicenumber: u32_,
    pub total_size: u32_,
    pub res: u32_,
}
impl Default for mmcdevice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MMC_DEVICE_SDCARD: _bindgen_ty_1 = 0;
pub const MMC_DEVICE_NAND: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::libc::c_uint;
extern "C" {
    pub fn sdmmc_controller_init(force_init: bool);
}
extern "C" {
    pub fn sdmmc_initirq();
}
extern "C" {
    pub fn sdmmc_cardinserted() -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_sdcard_init() -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_nand_init() -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_get_cid(devicenumber: ::libc::c_int, cid: *mut u32_);
}
extern "C" {
    #[link_name = "\u{1}sdmmc_nand_cid__extern"]
    pub fn sdmmc_nand_cid(cid: *mut u32_);
}
extern "C" {
    #[link_name = "\u{1}sdmmc_sdcard_cid__extern"]
    pub fn sdmmc_sdcard_cid(cid: *mut u32_);
}
extern "C" {
    pub fn sdmmc_sdcard_readsectors(
        sector_no: u32_,
        numsectors: u32_,
        out: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_sdcard_writesectors(
        sector_no: u32_,
        numsectors: u32_,
        in_: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_nand_readsectors(
        sector_no: u32_,
        numsectors: u32_,
        out: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sdmmc_nand_writesectors(
        sector_no: u32_,
        numsectors: u32_,
        in_: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static mut sdmmc_cid: [u32_; 0usize];
}
extern "C" {
    pub static mut sdmmc_curdevice: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}sdmmc_read16__extern"]
    pub fn sdmmc_read16(reg: u16_) -> u16_;
}
extern "C" {
    #[link_name = "\u{1}sdmmc_write16__extern"]
    pub fn sdmmc_write16(reg: u16_, val: u16_);
}
extern "C" {
    #[link_name = "\u{1}sdmmc_read32__extern"]
    pub fn sdmmc_read32(reg: u16_) -> u32_;
}
extern "C" {
    #[link_name = "\u{1}sdmmc_write32__extern"]
    pub fn sdmmc_write32(reg: u16_, val: u32_);
}
extern "C" {
    #[link_name = "\u{1}sdmmc_mask16__extern"]
    pub fn sdmmc_mask16(reg: u16_, clear: u16_, set: u16_);
}
extern "C" {
    #[link_name = "\u{1}setckl__extern"]
    pub fn setckl(data: u32_);
}
extern "C" {
    pub fn touchInit();
}
extern "C" {
    pub fn touchReadXY(touchPos: *mut touchPosition);
}
extern "C" {
    pub fn touchRead(command: uint32) -> uint16;
}
extern "C" {
    pub fn touchReadTemperature(t1: *mut ::libc::c_int, t2: *mut ::libc::c_int) -> uint32;
}
extern "C" {
    pub fn touchPenDown() -> bool;
}
pub type WifiSyncHandler = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn Read_Flash(
        address: ::libc::c_int,
        destination: *mut ::libc::c_char,
        length: ::libc::c_int,
    );
}
extern "C" {
    pub fn PowerChip_ReadWrite(cmd: ::libc::c_int, data: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn Wifi_Interrupt();
}
extern "C" {
    pub fn Wifi_Update();
}
extern "C" {
    pub fn Wifi_Init(WifiData: ::libc::c_ulong);
}
extern "C" {
    pub fn Wifi_Deinit();
}
extern "C" {
    pub fn Wifi_Sync();
}
extern "C" {
    pub fn Wifi_SetSyncHandler(sh: WifiSyncHandler);
}
extern "C" {
    pub fn installWifiFIFO();
}
pub type mm_word = ::libc::c_uint;
pub type mm_hword = ::libc::c_ushort;
pub type mm_byte = ::libc::c_uchar;
pub type mm_sfxhand = ::libc::c_ushort;
pub type mm_bool = ::libc::c_uchar;
pub type mm_addr = *mut ::libc::c_void;
pub type mm_reg = *mut ::libc::c_void;
pub const MM_MODE_A: mm_mode_enum = 0;
pub const MM_MODE_B: mm_mode_enum = 1;
pub const MM_MODE_C: mm_mode_enum = 2;
pub type mm_mode_enum = ::libc::c_uint;
pub const MM_STREAM_8BIT_MONO: mm_stream_formats = 0;
pub const MM_STREAM_8BIT_STEREO: mm_stream_formats = 1;
pub const MM_STREAM_16BIT_MONO: mm_stream_formats = 2;
pub const MM_STREAM_16BIT_STEREO: mm_stream_formats = 3;
pub type mm_stream_formats = ::libc::c_uint;
pub type mm_callback =
    ::core::option::Option<unsafe extern "C" fn(msg: mm_word, param: mm_word) -> mm_word>;
pub type mm_stream_func = ::core::option::Option<
    unsafe extern "C" fn(length: mm_word, dest: mm_addr, format: mm_stream_formats) -> mm_word,
>;
pub const MMRF_MEMORY: mm_reverbflags = 1;
pub const MMRF_DELAY: mm_reverbflags = 2;
pub const MMRF_RATE: mm_reverbflags = 4;
pub const MMRF_FEEDBACK: mm_reverbflags = 8;
pub const MMRF_PANNING: mm_reverbflags = 16;
pub const MMRF_LEFT: mm_reverbflags = 32;
pub const MMRF_RIGHT: mm_reverbflags = 64;
pub const MMRF_BOTH: mm_reverbflags = 96;
pub const MMRF_INVERSEPAN: mm_reverbflags = 128;
pub const MMRF_NODRYLEFT: mm_reverbflags = 256;
pub const MMRF_NODRYRIGHT: mm_reverbflags = 512;
pub const MMRF_8BITLEFT: mm_reverbflags = 1024;
pub const MMRF_16BITLEFT: mm_reverbflags = 2048;
pub const MMRF_8BITRIGHT: mm_reverbflags = 4096;
pub const MMRF_16BITRIGHT: mm_reverbflags = 8192;
pub const MMRF_DRYLEFT: mm_reverbflags = 16384;
pub const MMRF_DRYRIGHT: mm_reverbflags = 32768;
pub type mm_reverbflags = ::libc::c_uint;
pub const MMRC_LEFT: mm_reverbch = 1;
pub const MMRC_RIGHT: mm_reverbch = 2;
pub const MMRC_BOTH: mm_reverbch = 3;
pub type mm_reverbch = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmreverbcfg {
    pub flags: mm_word,
    pub memory: mm_addr,
    pub delay: mm_hword,
    pub rate: mm_hword,
    pub feedback: mm_hword,
    pub panning: mm_byte,
}
impl Default for mmreverbcfg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_reverb_cfg = mmreverbcfg;
pub const MM_PLAY_LOOP: mm_pmode = 0;
pub const MM_PLAY_ONCE: mm_pmode = 1;
pub type mm_pmode = ::libc::c_uint;
pub const MM_MIX_8KHZ: mm_mixmode = 0;
pub const MM_MIX_10KHZ: mm_mixmode = 1;
pub const MM_MIX_13KHZ: mm_mixmode = 2;
pub const MM_MIX_16KHZ: mm_mixmode = 3;
pub const MM_MIX_18KHZ: mm_mixmode = 4;
pub const MM_MIX_21KHZ: mm_mixmode = 5;
pub const MM_MIX_27KHZ: mm_mixmode = 6;
pub const MM_MIX_31KHZ: mm_mixmode = 7;
pub type mm_mixmode = ::libc::c_uint;
pub const MM_TIMER0: mm_stream_timer = 0;
pub const MM_TIMER1: mm_stream_timer = 1;
pub const MM_TIMER2: mm_stream_timer = 2;
pub const MM_TIMER3: mm_stream_timer = 3;
pub type mm_stream_timer = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct t_mmdssample {
    pub loop_start: mm_word,
    pub __bindgen_anon_1: t_mmdssample__bindgen_ty_1,
    pub format: mm_byte,
    pub repeat_mode: mm_byte,
    pub base_rate: mm_hword,
    pub data: mm_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union t_mmdssample__bindgen_ty_1 {
    pub loop_length: mm_word,
    pub length: mm_word,
}
impl Default for t_mmdssample__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for t_mmdssample {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_ds_sample = t_mmdssample;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct t_mmsoundeffect {
    pub __bindgen_anon_1: t_mmsoundeffect__bindgen_ty_1,
    pub rate: mm_hword,
    pub handle: mm_sfxhand,
    pub volume: mm_byte,
    pub panning: mm_byte,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union t_mmsoundeffect__bindgen_ty_1 {
    pub id: mm_word,
    pub sample: *mut mm_ds_sample,
}
impl Default for t_mmsoundeffect__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for t_mmsoundeffect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_sound_effect = t_mmsoundeffect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_mmgbasystem {
    pub mixing_mode: mm_mixmode,
    pub mod_channel_count: mm_word,
    pub mix_channel_count: mm_word,
    pub module_channels: mm_addr,
    pub active_channels: mm_addr,
    pub mixing_channels: mm_addr,
    pub mixing_memory: mm_addr,
    pub wave_memory: mm_addr,
    pub soundbank: mm_addr,
}
impl Default for t_mmgbasystem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_gba_system = t_mmgbasystem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t_mmdssystem {
    pub mod_count: mm_word,
    pub samp_count: mm_word,
    pub mem_bank: *mut mm_word,
    pub fifo_channel: mm_word,
}
impl Default for t_mmdssystem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_ds_system = t_mmdssystem;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct t_mmstream {
    pub sampling_rate: mm_word,
    pub buffer_length: mm_word,
    pub callback: mm_stream_func,
    pub format: mm_word,
    pub timer: mm_word,
    pub manual: mm_bool,
}
pub type mm_stream = t_mmstream;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct t_mmlayer {
    pub tick: mm_byte,
    pub row: mm_byte,
    pub position: mm_byte,
    pub nrows: mm_byte,
    pub global_volume: mm_byte,
    pub speed: mm_byte,
    pub active: mm_byte,
    pub bpm: mm_byte,
}
pub type mm_modlayer = t_mmlayer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmm_voice {
    pub source: mm_addr,
    pub length: mm_word,
    pub loop_start: mm_hword,
    pub timer: mm_hword,
    pub flags: mm_byte,
    pub format: mm_byte,
    pub repeat: mm_byte,
    pub volume: mm_byte,
    pub divider: mm_byte,
    pub panning: mm_byte,
    pub index: mm_byte,
    pub reserved: [mm_byte; 1usize],
}
impl Default for tmm_voice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mm_voice = tmm_voice;
pub const MMVF_FREQ: _bindgen_ty_2 = 2;
pub const MMVF_VOLUME: _bindgen_ty_2 = 4;
pub const MMVF_PANNING: _bindgen_ty_2 = 8;
pub const MMVF_SOURCE: _bindgen_ty_2 = 16;
pub const MMVF_STOP: _bindgen_ty_2 = 32;
pub type _bindgen_ty_2 = ::libc::c_uint;
extern "C" {
    #[doc = " mmInstall( channel )\n\n Install Maxmod.\n\n channel : IPC/FIFO channel to use, usually 7."]
    pub fn mmInstall(fifo_channel: ::libc::c_int);
}
extern "C" {
    #[doc = " mmLockChannels( mm_word bitmask )\n\n Lock audio channels from being used by Maxmod.\n\n bitmask : Bitmask of which channels should be locked.\n (&1 = ch0, &2 = ch1, &4 = ch2, &8 = ch4, etc...)"]
    pub fn mmLockChannels(bitmask: mm_word);
}
extern "C" {
    #[doc = " mmUnlockChannels( mm_word bitmask )\n\n Unlock audio channels so Maxmod can use them.\n\n bitmask : Bitmask of which channels should be unlocked.\n (&1 = ch0, &2 = ch1, &4 = ch2, &8 = ch4, etc...)"]
    pub fn mmUnlockChannels(bitmask: mm_word);
}
extern "C" {
    #[doc = " mmIsInitialize()\n\n Returns whether or not the system is ready for playback."]
    pub fn mmIsInitialized() -> mm_bool;
}
extern "C" {
    #[doc = " mmSelectMode( mm_mode_enum mode )\n\n Select audio mode\n\n mode:\n   MM_MODE_A : Hardware Mixing\n   MM_MODE_B : Interpolated Mixing\n   MM_MODE_C : Extended Mixing"]
    pub fn mmSelectMode(mode: mm_mode_enum);
}
extern "C" {
    #[doc = " mmFrame()\n\n Work routine (called automatically)"]
    pub fn mmFrame();
}
extern "C" {
    #[doc = " mmStart( mm_word module_ID, mm_pmode mode )\n\n Start module playback\n\n module_ID : Index of module to play. (defined in soundbank header)\n mode : Mode of playback: MM_PLAY_ONCE or MM_PLAY_LOOP"]
    pub fn mmStart(module_ID: mm_word, mode: mm_pmode);
}
extern "C" {
    #[doc = " mmPause()\n\n Pause module playback."]
    pub fn mmPause();
}
extern "C" {
    #[doc = " mmResume()\n\n Resume module playback"]
    pub fn mmResume();
}
extern "C" {
    #[doc = " mmStop()\n\n Stop module playback. Start again (from the beginning)\n with mmStart(...)."]
    pub fn mmStop();
}
extern "C" {
    #[doc = " mmPosition( mm_word position )\n\n Set playback position.\n\n position : New position in module sequence."]
    pub fn mmPosition(position: mm_word);
}
extern "C" {
    #[doc = " mmActive()\n\n Returns nonzero if module is playing"]
    pub fn mmActive() -> mm_bool;
}
extern "C" {
    #[doc = " mmJingle( mm_word module_ID )\n\n Play module as jingle. Jingles are limited to 4 channels only.\n\n module_ID : ID of module (defined in soundbank header)"]
    pub fn mmJingle(module_ID: mm_word);
}
extern "C" {
    #[doc = " mmActiveSub()\n\n Returns nonzero if a jingle is actively playing."]
    pub fn mmActiveSub() -> mm_bool;
}
extern "C" {
    #[doc = " mmSetModuleVolume( mm_word volume )\n mmSetJingleVolume( mm_word volume )\n\n Set volume scaler for music/jingles.\n\n volume : 0->1024 = silent..normal"]
    pub fn mmSetModuleVolume(volume: mm_word);
}
extern "C" {
    pub fn mmSetJingleVolume(volume: mm_word);
}
extern "C" {
    #[doc = " mmPlayModule( mm_word address, mm_word mode, mm_word layer )\n\n Play direct MAS file"]
    pub fn mmPlayModule(address: mm_word, mode: mm_word, layer: mm_word);
}
extern "C" {
    #[doc = " mmEffect( mm_word sample_ID )\n\n Play a sound effect at its default frequency with full volume\n and centered panning. Effect must be loaded first via\n mmLoadEffect.\n\n sample_ID : Sound effect ID. (defined in soundbank header)"]
    pub fn mmEffect(sample_ID: mm_word) -> mm_sfxhand;
}
extern "C" {
    #[doc = " mmEffectEx( mm_sound_effect* sound )\n\n Play a sound effect with the parameters supplied.\n\n sound : Sound effect attributes."]
    pub fn mmEffectEx(sound: *mut mm_sound_effect) -> mm_sfxhand;
}
extern "C" {
    #[doc = " mmEffectVolume( mm_sfxhand handle, mm_word volume )\n\n Set the volume of a sound effect.\n\n handle : Sound effect handle.\n volume : 0->65535"]
    pub fn mmEffectVolume(handle: mm_sfxhand, volume: mm_word);
}
extern "C" {
    #[doc = " mmEffectPanning( mm_sfxhand handle, mm_word panning )\n\n Set the panning of a sound effect.\n\n handle : Sound effect handle.\n panning : 0->255 = left..right"]
    pub fn mmEffectPanning(handle: mm_sfxhand, panning: mm_byte);
}
extern "C" {
    #[doc = " mmEffectRate( mm_sfxhand handle, mm_word rate )\n\n Set the playback rate of an effect.\n\n handle : Sound effect handle.\n rate: 6.10 factor"]
    pub fn mmEffectRate(handle: mm_sfxhand, rate: mm_word);
}
extern "C" {
    #[doc = " mmEffectScaleRate( mm_sfxhand handle, mm_word factor )\n\n Scale the playback rate of an effect.\n\n handle : Sound effect handle.\n factor : 6.10 fixed point factor."]
    pub fn mmEffectScaleRate(handle: mm_sfxhand, factor: mm_word);
}
extern "C" {
    #[doc = " mmEffectCancel( mm_sfxhand handle )\n\n Stop sound effect.\n\n handle : Sound effect handle."]
    pub fn mmEffectCancel(handle: mm_sfxhand);
}
extern "C" {
    #[doc = " mmEffectRelease( mm_sfxhand handle )\n\n Release sound effect (invalidate handle and allow interruption)\n\n handle : Sound effect handle."]
    pub fn mmEffectRelease(handle: mm_sfxhand);
}
extern "C" {
    #[doc = " mmSetEffectsVolume( mm_word volume )\n\n Set master volume scale for effect playback.\n\n volume : 0->1024 representing 0%->100% volume"]
    pub fn mmSetEffectsVolume(volume: mm_word);
}
extern "C" {
    #[doc = " mmEffectCancelAll()\n\n Stop all sound effects"]
    pub fn mmEffectCancelAll();
}
extern "C" {
    #[doc = " mmStreamOpen( mm_stream* stream, mm_addr wavebuffer, mm_addr workbuffer )\n\n Open audio stream.\n\n stream : Configuration struct\n wavebuffer : wave memory, must be aligned\n workbuffer : work memory, must be aligned"]
    pub fn mmStreamOpen(stream: *mut mm_stream, wavebuffer: mm_addr, workbuffer: mm_addr);
}
extern "C" {
    #[doc = " mmStreamUpdate()\n\n Fills the stream with wave data.\n This only needs to be called in 'manual' mode. It\n is called automatically in 'auto' mode."]
    pub fn mmStreamUpdate();
}
extern "C" {
    #[doc = " mmStreamClose()\n\n Close audio stream."]
    pub fn mmStreamClose();
}
extern "C" {
    #[doc = " mmStreamGetPosition()\n\n Get number of samples elapsed since the stream was opened.\n The 32-bit value will wrap every 36 hours or so (at 32khz)"]
    pub fn mmStreamGetPosition() -> mm_word;
}
extern "C" {
    #[doc = " mmReverbEnable()\n\n Enable reverb system. (use before configuring!)"]
    pub fn mmReverbEnable();
}
extern "C" {
    #[doc = " mmReverbConfigure( mm_reverb_cfg* config )\n\n Configure reverb parameters.\n config : Configuration data."]
    pub fn mmReverbConfigure(config: *mut mm_reverb_cfg);
}
extern "C" {
    #[doc = " mmReverbStart( mm_reverbch channels )\n\n Start reverb output."]
    pub fn mmReverbStart(channels: mm_reverbch);
}
extern "C" {
    #[doc = " mmReverbStop( mm_reverch channels )\n\n Stop reverb output."]
    pub fn mmReverbStop(channels: mm_reverbch);
}
extern "C" {
    #[doc = " mmReverbBufferSize( mm_word bit_depth, mm_word sampling_rate,\n                     mm_word delay )\n\n Calculate reverb buffer size based on bit depth, delay\n and sampling rate.\n\n bit_depth : Pass 8 or 16 for 8-bit/16-bit\n sampling_rate :\n delay : In milliseconds\n\n Returns size in WORDS."]
    #[link_name = "\u{1}mmReverbBufferSize__extern"]
    pub fn mmReverbBufferSize(
        bit_depth: mm_word,
        sampling_rate: mm_word,
        delay: mm_word,
    ) -> mm_word;
}
extern "C" {
    #[doc = " mmReverbDisable()\n\n Disable reverb system."]
    pub fn mmReverbDisable();
}
extern "C" {
    pub static mut mmLayerMain: mm_modlayer;
}
extern "C" {
    pub static mut mmLayerSub: mm_modlayer;
}
